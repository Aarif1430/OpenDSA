<!DOCTYPE html>
<html data-require="math spin word-problems graphie graphie-helpers-arithmetic">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>OpenDSA Hashing Exercise</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js"></script>
	<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/1.1-latest/MathJax.js?config=http://algoviz.org/OpenDSA/dev/OpenDSA/ODSAkhan-exercises/KAthJax-77111459c7d82564a705f9c5480e2c88.js">
</script>
	<script>urlBaseOverride = "../../ODSAkhan-exercises/";</script>
	<script src="../../ODSAkhan-exercises/khan-exercise.js"></script>
	<script src="../../JSAV/build/JSAV-min.js"></script>	
	<script src="../../JSAV/lib/jquery.transform.light.js"></script>
	<script type="text/javascript" src="../../AV/Queue.js"></script>
    <link rel="stylesheet" href="../../JSAV/css/JSAV.css" type="text/css" />
<body>
  
  <script type="text/javascript">
  // To do
  // make table size 2^n for double hashing
  // check compatibility
	// Constants, to tune the exercise
	var 
	PREFERRED_TABLE_SIZE = 10,		// Preferred table size in 0.75 of the time
	PROB_OF_SPECIAL_CASES = 0.25,	// Probability of generating hash table of special cases
	MIN_KEY = 0,					// The min value of generated keys
	MAX_KEY = 99;					// The max value of generated keys
	
	// Hash table variables
	var 
	start = true,					// indicator of the first load of the page
	hashTable,						// an array of numbers, the actual hash table.
	keys = new Queue(),				// A queue of keys to be inserted	
	currentKey,						// The key to be insert
	currentAnswer,					// The answer of current key, i.e its location in the hash table
	collisionResolution;			// 0 : Linear Probing
									// 1 : Quadratic Probing
									// 2 : Double hashing
	// display variables
	var 
	jsav, 		// JSAV variable
	array;		// Table used by jsav in the GUI
  
	// This function is considered the controller, it references the model (data structure) and
	// the view (GUI). 
	function initJSAV() 
	{
		initTable(); 				// Initialize the core data structure and variables								
		jsav = new JSAV("jsav");		
		var array = jsav.ds.array(hashTable,{indexed: true, layout: "vertical"});	
		for (i=0; i<hashTable.length; i++)
		{
			// If position is empty, highlight it
			if ((typeof hashTable[i]) == 'undefined') 
				array.highlight(i);			
		}
	}
 	
	function addFunction(fun) {
		return "<code>" + fun + "</code>";			
	}
</script>

	<!-- For testing, drawing the table should be inside the problem class, but here mouse clicks can be caught--> 
	<!-- <div id="jsav"></div>-->


	<div class="exercise">
		<div class="vars">								
			<var id="JSAV">initJSAV()</var>
			<var id="hashFunction">"h(k) = k  mod "+hashTable.length</var>
			<var id="secondHashFunction">"P(k,i) = (h(k)+i* h2(k) ) mod "+hashTable.length+",  h2(k)=floor[2((k/10) mod (M/2))+1]"</var>
			<var id="collisionMethod">new Array("Linear probing","Quadratic Probing","Double Hashing")</var>									
		</div>
		
		<div class="problems">
			<div id="DisplayTableProblem">							
				<p class="problem">
					Given the following hash table, with the hash function <var>addFunction(hashFunction)</var>
					and handling collisions using <var>collisionMethod[collisionResolution]</var>.	
					<var>(collisionResolution==2)? "Second hash function is: "+addFunction(secondHashFunction):""</var>						
				</p>					
				<p class="question"> 
					In which slot element <var>currentKey </var> should be inserted?
					(The answer is: <var>currentAnswer</var>).
					<div id="jsav"></div>
				</p>
				<div class="solution" data-forms="integer"><var>currentAnswer</var></div>
			</div>		
			
		</div>
		
	</div>	
	
	
	<script>
	
	/*
		This function is to get the answer by mouse click on the table cell
		NOT WORKING IF THE TABLE IS INSIDE KHAN-ACADEMY CLASSES
	**/
	$(document).ready(function() {	
		//$('.exercise').find("#jsav").click( function() {alert("testing");});
		
		// register click handlers for the array indices
		$("#jsav").on("click", ".jsavindex", function() {			
			var index = $(this).parent(".jsavarray").find(".jsavindex").index(this)		
			jsav._redo = []; // clear the forward stack   
			  if (!array.isHighlight(index)) 
				{array.highlight(index);} 
			  else 
				{array.unhighlight(index);}			  		
		});		
	});
	
	
	// Initialization function 
	function initTable()
	{
		// If not first run, insert current key
		if (start==false)
		{
			hashTable[currentAnswer] = currentKey;			
		}
		// If first run, or hash table is full --> initialize the problem			
		if (start || keys.isEmpty()) 
			getNewHashTable();		
		
		// use current table and get next key to be inserted
		// The wile loop is used to check if the key can  be inserted
		// in case of quadratic hashing or any case where the key can't
		// be inserted.
		var pos = -1;
		while (pos<0)
		{
			if (keys.isEmpty())
				getNewHashTable();
			currentKey = keys.dequeue();
			pos = getInsertPosition(currentKey);
			//alert("current key="+currentKey+", pos="+pos);				
		}		
		currentAnswer = pos;		
	}

	// Generate new problem
	function getNewHashTable()
	{
		var key, pos; 	// temp variables
		start = false;	
		//alert("Now in init....");
		// generate random choice of collision resolution to this table
		collisionResolution = KhanUtil.randRange(0,2);	////////////////// should be from (0,2)			
		// Genetae random lenght to the table, with weighted probability
		hashTable = new Array();
		hashTable.length = generateHashTableSize();		
				
		// Generate random load factor, 0.4 or 0.6 with equal probability
		var loadFactor = generateLoadFactor();		
		var numKeysToInsert = Math.floor((loadFactor * hashTable.length));	
		
		for (i=0; i<numKeysToInsert; )
		{
			key = KhanUtil.randRange(MIN_KEY, MAX_KEY);				
			pos = getInsertPosition(key);
			//alert("key="+key+"pos="+pos);
			if (pos < 0) //something wrong in getting positon, ignore this key
				continue;
			hashTable[pos] = key;
			i++;
		}
		// generate (hashTable.length-numKeysToInsert-1) number of keys to insert by the student
		// one cell in the table is left empty so that last insert won't be trivial.
		for (i=0; i<hashTable.length-numKeysToInsert-1; i++)
		{
			keys.enqueue(KhanUtil.randRange(MIN_KEY, MAX_KEY));
		}
	}
	
	// Generate Hash table size
	// M belongs to [7,11] by prob PROB_OF_SPECIAL_CASES, and M = 10 by probability 1-PROB_OF_SPECIAL_CASES
	function generateHashTableSize()
	{
		var prob = KhanUtil.rand();
		if (prob < PROB_OF_SPECIAL_CASES)
			return PREFERRED_TABLE_SIZE;
		else
			return KhanUtil.randRange(7,11);
	}
	
	function generateLoadFactor()
	{
		if (KhanUtil.randRange(0,1)== 1)
			return 0.6;
		else
			return 0.4;
	}
	
	/*********************************************************/
	/******************  Hash Functions **********************/
	/*********************************************************/
	    
	/* Insert key into the hash table. Collision resolution:
		0 : Linear Probing
		1 : Quadratic Probing
		2 : Double hashing
	*/
	function getInsertPosition(key)
	{
		// Simple Mod Function
		var pos = key % hashTable.length;	
		//alert("Got position: "+pos);
		// If position pos is empty, insert key
		if (typeof hashTable[pos]=='undefined') 
		{
			return pos;
		}
		else	// position is full, look for another empty pos
		{
			//alert("collisionResolution="+collisionResolution);
			switch(collisionResolution)
			{
				case 0:
					return linearProbing(key, pos);		
					break;
				case 1:
					return quadraticProbing(key, pos);	
					break;
				case 2:				
					return doubleHashing(key, pos);
					break;
			}
		}
		return -2; // can't be here
	}
	
	/* Collision Resolutions */
				
	// Linear Probing
	// only pos is used
	function linearProbing(key, pos) 
	{						
		// Temp pointer that will point to the correct position at the end of the loop
		var i = pos;
		// Counter that counts how many times the array ran
		var count = 0;
		var fullArray = false;	
		// Loop across the array. "infinite" loop. Breaks if array is full.
		for (;;) 
		{				
			// If array is full, break out
			if (count == hashTable.length) {
				fullArray = true;
				break;
			}
					
			// If space is available, break
			if (typeof hashTable[i]=='undefined') 
				break;				
				
			// If i is last element of arr, restart to position 0 of the array
			if (i == hashTable.length - 1) 
				i = 0;							
			// Otherwise just increment i by 1 (to check for next pos of array next iteration)
			else 
				i++;	
			 
			count++;
		}
	
		// Empty spot found. return positon i
		if (!fullArray) 
			return i;
		else // cannot insert, array full (should happen to avoid infinite loops
			return -1;
		
	}

	// Quadratic Probing (i^2)
	// only pos is used
	function quadraticProbing(key, pos) 
	{						
		// Temp pointer that will point to the correct position at the end of the loop
		var i = 1;
		// Counter that counts how many times the array ran
		var count = 0;
		var fullArray = false;	
		var currentPos;
		// Loop across the array. "infinite" loop. Breaks if array is full.
		for (;;) 
		{				
			// If array is full, or max num of iterations, break out
			if (count == hashTable.length) {
				fullArray = true;
				break;
			}
			currentPos = (pos + Math.pow(i,2)) % hashTable.length;	
			//alert("key="+key+", pos="+pos+", i="+i+"currentPos="+currentPos);			
			// If space is available, break
			if (typeof hashTable[currentPos]=='undefined') 
				break;				
									
			i++;				
			count++;
		}
	
		// Empty spot found. return positon i
		if (!fullArray) 
			return currentPos;
		else // cannot insert, array full (should happen to avoid infinite loops
			return -1;
		
	}
	
	// Double Hashing 	
	// P(k,i) = (h(k)+i* h2(k) ) mod hashTable.length,  h2(k)=2((k/10) mod (M/2))+1
	function doubleHashing(key, pos) 
	{						
		// Temp pointer that will point to the correct position at the end of the loop
		var i = 1;
		// Counter that counts how many times the array ran
		var count = 0;
		var fullArray = false;	
		var currentPos;
		// Loop across the array. "infinite" loop. Breaks if array is full.
		for (;;) 
		{				
			// If array is full, or max num of iterations, break out
			if (count == hashTable.length) {
				fullArray = true;
				break;
			}
			var m = key +1;			
			currentPos = (pos+i* Math.floor(2*((key/10) % (hashTable.length/2))+1) ) % hashTable.length;	
			// If space is available, break
			if (typeof hashTable[currentPos]=='undefined') 
				break;				
									
			i++;				
			count++;
		}
	
		// Empty spot found. return positon i
		if (!fullArray) 
			return currentPos;
		else // cannot insert, array full (should happen to avoid infinite loops
			return -1;
		
	}
   </script>
	
</body>
</html>
