<!--
Linked List Deletion mini-proficiency exercise.
Written by Junyang Chen and Cliff Shaffer
-->

<!DOCTYPE html>
<html data-require="math">
<head>
  <title>Linked List Deletion Proficiency Exercise</title>
  <script src="../../lib/jquery.min.js"></script>
  <script src="../../lib/jquery-ui.min.js"></script>
  <script src="../../JSAV/lib/jquery.transform.light.js"></script>
  <script src="../../JSAV/lib/raphael.js"></script>
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/1.1-latest/MathJax.js?config=http://algoviz.org/OpenDSA/dev/OpenDSA/ODSAkhan-exercises/KAthJax-77111459c7d82564a705f9c5480e2c88.js">
  </script>
  <script>urlBaseOverride = "../../ODSAkhan-exercises/";</script>
  <script src="../../lib/khan-exercise-min.js"></script>
  <script src="../../JSAV/build/JSAV-min.js"></script>
  <link rel="stylesheet" href="../../JSAV/css/JSAV.css" type="text/css" />

  <style>
    .jsavcontainer {
      height: 225px;
      border: 0px;
    }
	.jsavcanvas{
      height: 225px;
    }
    .jsavhorizontallist.jsavautoresize .jsavnode {
      min-width: 30px;
      max-width: 30px;
      min-height: 30px;
      max-height: 30px;
      line-height: 30px;
      padding-right: 12px;
    }
    .bgColor{
      font-size: 130%;
      background-color: yellow;
    }
    .jsavlist.jsavautoresize.jsavhorizontallist{
      height: 300px;
    }
    .jsavcanvas svg{
      height: 300px;
    }	
    .jsavnode {
      line-height: 30px !important;
      min-width: 30px !important;
      max-width: 30px !important;
      min-height: 30px !important;
      max-height: 30px !important;
	  cursor: pointer;
    }
    .jsavpointer{
      width: 40px;
      border: 1px solid #bbb;
      text-align: center;
	  cursor: pointer;
    }
    .highlight{
      background-color: yellow;
    }
    #reset { margin-right: 20px;}
  </style>
</head>
<body>
<script>
var jsav,           // The JSAV object
  answerArr = [], // The (internal) array that stores the correct answer
  answerOrderArr = [], // The (internal) array that stores the correct order of nodes
  answerHead,
  answerCurr,
  answerTail,
  answerCopyFrom,
  answerCopyVal,
  orderArr = [],  
  listArr = [],
  status = 0,    // Nothing is currently selected, status = 0;
                 // Data area of the node is selected, status = 1;
                 // Pointer area of the node is selected, status = 2.
				 // Label area of the pointer is clicked, status = 3.
  odsa_head,      // head of the list
  connections = [],
  fromNode,
  toNode,
  headNode,
  currNode,
  tailNode,
  copyFrom,
  jsavList,        // JSAV list
  listSize,        // JSAV list size
  jsavCopyArr,
  currPosition,  // Position to be inserted
  userInput,      // Boolean: Tells us if user ever did anything
  selected_pointer,
  selected_node; // Position that has been selected by user for swap

JSAV._types.ds.ListNode.prototype.odsa_next = {};
JSAV._types.ds.ListNode.prototype.odsa_tail = {};
JSAV._types.ds.ListNode.prototype.odsa_edgeToNext = {};

JSAV._types.ds.ListNode.prototype.odsa_pleft = null;
JSAV._types.ds.ListNode.prototype.odsa_pright = null;
JSAV._types.Pointer.prototype.click = function(fn){
  var pointer = this;
  this.element.click(function(){fn(pointer)});
}
var pclick = function(pointer){
  if(status == 1){
    selected_node.removeClass('bgColor');
    selected_node = null;
  }else if(status == 3){
    if(selected_pointer !== pointer){
      selected_pointer.element.removeClass('highlight');
    }else{
      selected_pointer.element.removeClass('highlight');
      selected_pointer = null;
      status = 0;
      return;
    }
  }
  selected_pointer = pointer;
  selected_pointer.element.toggleClass('highlight');
  status = 3;
}

// Helper function for seting pointer
function setPointer(name, newnode, oldpointer, opt){
	
  if(oldpointer){
    if(newnode === oldpointer.target()){return;}
  }
  if(newnode.odsa_pleft && newnode.odsa_pright){return;}
  pointerRight = {visible: true,
    anchor: "right top",
    myAnchor: "left bottom",
    left: -5,
    top: -20};
  pointerLeft = {visible: true,
    anchor: "left top",
    myAnchor: "right bottom",
    left: 15,
    top: -20};

  if(oldpointer){
    if(oldpointer.target().odsa_pleft === oldpointer){
      oldpointer.target().odsa_pleft = null;
    }else if(oldpointer.target().odsa_pright === oldpointer){
      oldpointer.target().odsa_pright = null;
    }
    oldpointer.element.remove();
    oldpointer.arrow.element.remove();
  }

  if(!newnode.odsa_pleft){
    newnode.odsa_pleft = newnode.jsav.pointer(name, newnode, pointerLeft);
    newnode.odsa_pleft.click(pclick);
    return newnode.odsa_pleft;
  }else if(!newnode.odsa_pright){
    newnode.odsa_pright = newnode.jsav.pointer(name, newnode, pointerRight);
    newnode.odsa_pright.click(pclick);
    return newnode.odsa_pright; 
  }
}

// Add an edge from obj1 to obj2 
function connection(obj1, obj2){
  if(obj1 == obj2){ return;}
  var left = obj1.jsav.container.find(".jsavcanvas:first").offset().left;
  var top = obj1.jsav.container.find(".jsavcanvas:first").offset().top;
  var fx = obj1.element.offset().left + 39 - left;
  var tx = obj2.element.offset().left  +2 - left;	  
  var fy = obj1.element.offset().top + 16 - top;
  var ty = obj2.element.offset().top + 16 - top;
  var fx1 = fx, fy1 = fy, tx1 = tx, ty1 = ty;

  var disx = (fx - tx - 22) > 0 ? 1 : (fx - tx - 22) == 0 ? 0 : -1;
  var disy = (fy - ty) > 0 ? 1 : (fy - ty) == 0 ? 0 : -1;
  
  var dx = Math.max(Math.abs(fx - tx) / 2, 35);
  var dy = Math.max(Math.abs(fy - ty) / 2, 35);
  if(fy - ty > -10 && fy - ty < 10 && (tx - fx < 36 || tx - fx > 38)){
      dx = Math.min(Math.abs(fx - tx), 20);
      dy = Math.min(Math.abs(fx - tx)/3, 50);
      tx += 22;
      ty += 15;
      fx1 = fx; 
      fy1 = fy + dy;
      tx1 = tx + dx;
      ty1 = ty + dy;
  }
  var edge = jsav.g.path(["M", fx, fy , "C", fx1, fy1, tx1 , ty1, tx, ty].join(","),{"arrow-end": "classic-wide-long", "opacity": 100,"stroke-width": 2,});
  
  if(obj1.odsa_next){
    obj1.odsa_edgeToNext.element.remove();	
  }else{
    obj1.odsa_tail.element.remove();
    obj1.odsa_tail = null;
  }
  
  obj1.odsa_edgeToNext = edge;
  obj1.odsa_next = obj2;
  
}

// Function for connecting to nodes when click them 
function Connect(obj1, obj2){
  if(obj1 == obj2){ return;}
  connection(obj1,obj2);
  obj1.odsa_next = obj2;
  obj1._next = obj2;
  for(var i=0; i<connections.length; i++)
  {
	  if(connections[i].from == obj1 && connections[i].to != obj2){
	    connections[i].to = obj2;
		return;
	  }
  }
    connections.push({from: obj1, to: obj2});  
}

var copyHandler = function(){
  if(status == 1){
    jsav.effects.copyValue(selected_node, jsavCopyArr, 0);
    selected_node.removeClass('bgColor');
    copyFrom = selected_node;
    status = 0;
  }
}

// Click event handler on the list
var clickHandler = function (e) {
  var x = parseInt(e.pageX - $('#' + this.id()).offset().left);
  var y = parseInt(e.pageY - $('#' + this.id()).offset().top);
  if(x > 31 && x < 42 && y > 0 && y < 31){	
    if(status == 1){
      selected_node.removeClass('bgColor');
      selected_node = null;
	}else if(status == 2){
      $('#' + fromNode.id() + " .jsavpointerarea:first").removeClass('bgColor');
	}

    if(status == 0 || status == 1){
      $('#' + this.id() + " .jsavpointerarea:first").addClass('bgColor');
      fromNode = this;
      status = 2;
    }else if(status == 2){		
      if(this.id() == fromNode.id()){
        $('#' + this.id() + " .jsavpointerarea:first").removeClass('bgColor');
        fromNode = null;
        status = 0;
      }else{
        $('#' + this.id() + " .jsavpointerarea:first").addClass('bgColor');
        fromNode = this;
        status = 2;
      }  
    }
  }else{
    if(status == 0){
      this.addClass('bgColor');
      selected_node = this;
      status = 1;
    }else if(status == 1){
      this.value(selected_node.value());
      selected_node.removeClass('bgColor');
      jsav.effects.copyValue(selected_node, this);
      selected_node = null;
      status = 0;
    }else if(status == 2){
      toNode = this;
      Connect(fromNode, toNode);
      $('#' + fromNode.id() + " .jsavpointerarea:first").removeClass('bgColor');
      $('#' + toNode.id()).removeClass('bgColor');
      fromNode = null;
      toNode = null;
      status = 0;
    }else if(status == 3){
      var oldPointer = selected_pointer;
      oldPointer.element.removeClass('highlight');
      if(oldPointer.target() !== this){
        selected_pointer = setPointer(selected_pointer.element.html(), this, oldPointer);
        if(selected_pointer.element.html() === "head"){
          headNode = selected_pointer.target();;
        }else if(selected_pointer.element.html() === "curr"){
          currNode = selected_pointer.target();;	
        }else if (selected_pointer.element.html() === "tail"){
          tailNode = selected_pointer.target();;
        }
      }
      status = 0;
    }
    userInput = true;
  }
};
function addTail(node){	  
  var left = node.element.offset().left -    jsav.container.find(".jsavcanvas:first").offset().left;
  var top = node.element.offset().top - jsav.container.find(".jsavcanvas:first").offset().top;
  var fx = left + 34;
  var tx = left + 44;
  var fy = top + 32;
  var ty = top + 1;

  if(node.odsa_tail){
    node.odsa_tail.element.remove();
    node.odsa_tail = jsav.g.line(fx,fy,tx,ty,{"opacity": 100,"stroke-width": 1});
  }else{
    node.odsa_tail = jsav.g.line(fx,fy,tx,ty,{"opacity": 100,"stroke-width": 1});
  }
  node.odsa_next = null;
}


var nullClickHandler = function (index,e) {
  if (status == 2) {
    $('#' + fromNode.id() + " .jsavpointerarea:first").removeClass('bgColor');
    addTail(fromNode);
    if(fromNode.odsa_edgeToNext){
      fromNode.odsa_edgeToNext.element.remove();
      fromNode.odsa_next = null;
    }
    status = 0;
  } 
  userInput = true;
};
// reset function definition
var f_reset = function () {
  var leftMargin = 20;
  var topMargin = 50;
  userInput = false;
  connections = [];
  selected_node = null;
  copyFrom = null;
  status = 0;
  if($("#jsav")){
    $("#jsav").empty();
  }
  jsav = new JSAV("jsav");	

  jsavList = jsav.ds.list({"nodegap": 30, "top": topMargin, left: leftMargin});
  jsavList.addFirst("null");
  for(var i = listSize - 2; i > 0; i--)
  {
	jsavList.addFirst(listArr[i]);
  }
  jsavList.addFirst("null");
  jsavList.layout(); 
  jsavCopyArr = jsav.ds.array(["null"],{left : leftMargin+ 10 + 73 * (currPosition + 1), top: topMargin + 70});
  odsa_head = jsavList.get(0);
  jsavList.get(0).odsa_tail = null;
  for(var i = 0; i < listSize; i ++)
  {
	orderArr[i] = jsavList.get(i).id();
    jsavList.get(i).odsa_next = jsavList.get(i).next();
	jsavList.get(i).odsa_edgeToNext = jsavList.get(i).edgeToNext();
	jsavList.get(i).odsa_tail = null;
  }
  if(currPosition !== listSize-2){
    for(var i = 0; i < listSize; i ++){
      if(i !== currPosition + 2){
        answerOrderArr.push(orderArr[i]);
	  }
    }
  }else{
    answerOrderArr = orderArr.slice(0);
  }
  setPointer("head", jsavList.get(0));
  headNode = jsavList.get(0);
  setPointer("curr", jsavList.get(currPosition + 1));
  currNode = jsavList.get(currPosition + 1);
  setPointer("tail", jsavList.get(listSize - 1));
  tailNode = jsavList.get(listSize - 1);
  jsavList.get(listSize - 1).odsa_tail = addTail(jsavList.get(listSize - 1));
  jsav.recorded();
  jsav.forward();
  answerCurr = jsavList.get(currPosition + 1);
  answerHead = jsavList.get(0);
  if(currPosition === listSize - 3){
    answerTail = jsavList.get(listSize - 2);
  }else{
    answerTail = jsavList.get(listSize - 1);
  }
  if(currPosition === listSize - 2){
    answerCopyFrom = null;
    answerCopyVal = "null";
  }else{
    answerCopyFrom = jsavList.get(currPosition + 1);
    answerCopyVal = jsavList.get(currPosition + 1).value();
  }
  jsavCopyArr.click(copyHandler);
  jsavList.click(clickHandler); // Rebind click handler after reset
  userInput = false;

};
// Initialise the exercise
var initJSAV = function (size, pos) {
  
  // Out with the old
  answerArr.length = 0;
  answerOrderArr.length = 0;
  // Give random numbers in range 0..999
  answerArr[0] = "null";
  for (i = 1; i < size-1; i++) {
    answerArr[i] = Math.floor(Math.random() * 1000);
  }
  answerArr[size-1] = "null";
  listArr = answerArr.slice(0);
  
  
  listSize = size;
  currPosition = pos;

  f_reset();

  // correct answer
  if(currPosition != listSize-2){
    answerArr.splice(currPosition + 1, 1);
  }
  console.log(answerArr);
  
  // Set up handler for newnode
  $("#makenull").click(function () { nullClickHandler(); });

  // Set up handler for reset button
  $("#reset").click(function () { f_reset(); });
};

// Check user's answer for correctness: User's array must match answer
var checkAnswer = function (arr_size, curr_pos) {
  var i = 1;
  var curr = odsa_head;
  if(copyFrom !== answerCopyFrom){return false;}
  if(answerCopyVal !== jsavCopyArr.value(0)){return false;}
  if(headNode!== answerHead || currNode!== answerCurr || tailNode!== answerTail){
    return false;
  }
  if(curr.value() != answerArr[0] || curr.id() != answerOrderArr[0]){
    return false;
  }
  while(curr.odsa_next){	
    curr = curr.odsa_next;
    if(curr.value() == answerArr[i] && curr.id() == answerOrderArr[i]){
      i++;
    }else{	alert(curr.value() + ", " + answerArr[i] + ", " + curr.id() + "," + answerOrderArr[i]);
      return false;
    }
  }
  if(curr_pos == arr_size - 2){ return true;}
  if(i == listSize-1)
  {
    return true;
  }
  return false;
};
</script>

<div class="exercise">
  <div class="vars">
    <var id="arr_size">randRange(4, 6)</var>
	<var id="curr_pos">randRange(0, arr_size-2)</var>
    <var id="JSAV">initJSAV(arr_size, curr_pos)</var>
  </div>

  <div class="problems">
    <div> <!-- Supresses answer box -->
      <p class="problem" id = "test">Your task in this exercise is to show the
        behavior for Linked list deletion.
        In the List displayed below, the "current" position is <b><var>curr_pos</var></b>.</p>
      <div class="question">
	    <p>Delete the element in current position, which is position <b><var>curr_pos</var></b>.</p>
        <p>To move an element, click on it (to highlight it), then click on where you
        want it to go. You can make a node poiting to "null" by firstly clicking the pointer area of the node and then clicking the "makenull" button.</p>
        <input id="reset" type="button" value="Reset" />
		<input id="makenull" type="button" value="makenull" />
        <div id="jsav" style = "{background-color : #333}"></div>
      </div>
      <div class="solution" data-type="custom">
        <div class="guess">
          [userInput]
        </div>
        <div class="validator-function">
          if (!checkAnswer(arr_size, curr_pos) && !guess[0])
            return ""; // User did not click, and correct answer is not
	               // initial array state
          else return checkAnswer(arr_size, curr_pos);
        </div>
      </div>
      <div class="hints">
        <p>To shift elements after "current" one position to the right, the first step could be swapping element <var>arr_size - 1</var> with position <var>arr_size</var></p> 
	<p>Then, keep swapping element i with i+1 until you make "current" empty for insertion </p>
        <p>Insert value to "current" position</p>
      </div>
    </div>
  </div>
</div>
</body>
</html>
