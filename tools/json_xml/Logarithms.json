{"document": {"@dupnames": "logarithms", "@ids": "logarithms", "@source": "<string>", "@title": "Logarithms", "title": "Logarithms", "subtitle": {"@dupnames": "logarithms", "@ids": "id1", "#text": "Logarithms"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "MathLogSumm", "@long_name": "MathLogSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "paragraph": [{"title_reference": ["logarithm", "b", "y", "b", "y", "log_b y = x", "log_b y = x", "b^x = y", "b^{log_b y} = y"], "#text": "The  of base  for value  is the\npower to which  is raised to get .\nNormally, this is written as .\nThus, if  then ,\nand ."}, "Logarithms are used frequently by programmers.\nHere are two typical uses.", {"title_reference": ["log n", "log_2 n"], "#text": "In OpenDSA, nearly all logarithms used have a base of two.\nThis is because data structures and algorithms most often divide\nthings in half, or store codes with binary bits.\nWhenever you see the notation  in OpenDSA,\neither  is meant or else the term is being used\nasymptotically and so the actual base does not matter.\nFor logarithms using any base other than two, we will show the base\nexplicitly."}, {"title_reference": ["m", "n", "r", "a", "b"], "#text": "Logarithms have the following properties, for any positive values of\n, , and , and any positive integers\n and ."}, {"title_reference": ["n", "a", "b", "log_a n", "log_b n", "log_b a", "n"], "#text": "The first two properties state that the logarithm\nof two numbers multiplied (or divided) can be found by adding\n(or subtracting) the logarithms of the two numbers.\nProperty (3) is simply an extension of property (1).\nProperty (4) tells us that, for variable  and any two integer\nconstants  and ,  and\n differ by the constant factor ,\nregardless of the value of .\nMost runtime analyses we use are of a type that ignores\nconstant factors in costs.\nProperty (4) says that such analyses need not be concerned with the\nbase of the logarithm, because this can change the total cost only by\na constant factor."}, "A useful identity to know is:", {"title_reference": ["n", "log_2 n = x", "x", "n", "2^{log n} = n"], "#text": "To give some intuition for why this is true:\nWhat does it mean to take the log (base 2) of ?\nIf , then  is the power to which you need\nto raise 2 to get back to .\nSo of course,  when the base of the log is 2."}, {"title_reference": ["log n^2 = 2 log n", "n^2", "(log n)^2", "log^2 n", "n", "log log n"], "#text": "When discussing logarithms, exponents often lead to confusion.\nProperty (3) tells us that .\nHow do we indicate the square of the logarithm (as opposed to the\nlogarithm of )?\nThis could be written as , but it is traditional to\nuse .\nOn the other hand, we might want to take the logarithm of the\nlogarithm of .\nThis is written ."}, {"title_reference": ["leq 1", "log^* n", "log^* 1024 = 4", "log 1024 = 10", "log 10 approx 3.33", "log 3.33 approx 1.74", "log 1.74 < 1"], "#text": "A special notation is used in the rare case when we need to know how\nmany times we must take the log of a number before we reach a\nvalue .\nThis quantity is written .\nFor example,  because\n, ,\n,\nand , which is a total of 4 log operations."}, "Here is some practice with manipulating logarithms."], "topic": [{"title": "Example", "paragraph": {"title_reference": ["n", "lceil log_2 n rceil", "lceil log_2 1000 rceil = 10"], "#text": "Many programs require an encoding for a collection of objects.\nWhat is the minimum number of bits needed to represent \ndistinct code values?\nThe answer is  bits.\nFor example, if you have 1000 codes to store, you will require at\nleast  bits to have 1000\ndifferent codes (10 bits provide 1024 distinct code values)."}}, {"title": "Example", "paragraph": {"title_reference": ["binary search <binary search> <AnalProgram>", "lceil log_2 n rceil"], "#text": "Consider the \nalgorithm for finding a given value within an array sorted by value\nfrom lowest to highest.\nBinary search first looks at the middle element\nand determines if the value being searched for is in the upper half\nor the lower half of the array.\nThe algorithm then continues splitting the appropriate\nsubarray in half until the desired value is found.\nHow many times can an array of size (n) be split in half until\nonly one element remains in the final subarray?\nThe answer is  times."}}], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ")", "list_item": [{"paragraph": {"title_reference": "log (nm) = log n + log m", "#text": "."}}, {"paragraph": {"title_reference": "log (n/m) = log n - log m", "#text": "."}}, {"paragraph": {"title_reference": "log (n^r) = r log n", "#text": "."}}, {"paragraph": {"title_reference": "log_a n = log_b n / log_b a", "#text": "."}}]}, "math_block": {"@xml:space": "preserve", "#text": "2^{\\log n} = n"}, "footnote": {"@auto": "1", "@ids": "id2", "@names": "1", "label": "1", "paragraph": "These properties are the idea behind the slide rule.\nAdding two numbers can be viewed as joining two lengths\ntogether and measuring their combined length.\nMultiplication is not so easily done.\nHowever, if the numbers are first converted to the lengths of\ntheir logarithms, then those lengths can be added and the\ninverse logarithm of the resulting length gives the answer for\nthe multiplication (this is simply logarithm property (1)).\nA slide rule measures the length of the logarithm for the\nnumbers, lets you slide bars representing these lengths to add\nup the total length, and finally converts this total length to\nthe correct numeric answer by taking the inverse of the\nlogarithm for the result."}}}