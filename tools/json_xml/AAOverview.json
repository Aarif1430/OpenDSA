{"document": {"@ids": "semester-overview", "@names": "semester\\ overview", "@source": "<string>", "@title": "Semester Overview", "title": "Semester Overview", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@ids": "introduction", "@names": "introduction", "title": "Introduction", "paragraph": [{"strong": "Given a problem, do we have (or can we devise) a good solution?", "#text": "The central question for this course is:\n\nEverything that we will do is connected to this central question in some\nway.\nHere \"good\" will usually be taken to mean \"as efficient as the problem\nwill allow\"."}, "If we have a problem and a proposed solution, then we need a mechanism\nthat will let us assess whether that solution is good or not.\nThis is where algorithm analysis comes in.\nThis module is not a review of basic algorithm analysis.\nIt is a reconstruction of the basic concept, from the ground up.\nYour prior study of algorithm analysis probably focussed on how to\nanalyze a given program or algorithm.\nWe will certainly do that during the course.\nBut in this module, we will focus on the question of how algorithm\nanalysis helps us to answer our central question.", {"title_reference": ["algorithm analysis", "problem", "algorithm", "program", "upper bounds <upper bound>", "lower bounds <lower bound>", "growth rate", "best case", "worst case", "average case", "big-oh notation", "Omega notation", "Theta notation"], "#text": "This discussion assumes that you are roughly familiar with basic\n terms and concepts.\nThese include definitions for the terms  versus\n versus .\nThese include the concepts of\n,\n,\n, , ,\n, ,\n, and .\nReview any of this material as necessary before continuing."}, "Our problems must be well-defined enough to be solved on computers.\n(Actually, to solve a problem we need more than just a clear\ndefinition. By the end of the semester, we will discuss problems that\nare not computable (i.e., cannot be solved) even though their\ndefinition is clear.)", {"title_reference": ["problem", "function", "problem instances <problem instance>"], "#text": "A  is a \n(i.e., a mapping of inputs to outputs).\nWe have different \n(inputs) for the problem, where each instance has a size.\nTo solve a problem, we must provide an algorithm, a coding\nof problem instances into inputs for the algorithm, and a coding for\noutputs into solutions."}, {"title_reference": "algorithm", "#text": "An  executes the mapping.\nA proposed algorithm must work for ALL instances\n(give the correct mapping to the output for that input instance).\n(Actually, we will relax this restriction later when we talk about\nApproximation and Probabilistic algorithms.)"}, "Our goal is to solve problems with as little computational effort per\ninstance as possible.\nWe are most often interested in solutions to \"large\" instances\nof the problem (asymptotic Analysis).\nOccasionally we are concerned with small instances.\nThen, constants matter.", {"title_reference": ["problem", "programs <program>", "algorithms <algorithm>", "algorithm analysis"], "#text": "Ultimately, we want to solve a  by using an efficient\n.\nBut it is not a good idea to start by writing programs and then\ncomparing them.\nWe don't want to spend a lot of time writing worthless programs.\nWe want a way to decide if the program is worth writing in\nthe first place.\nSo, we will really spend most of our time looking at\n instead of programs, and using\n to evaluate the algorithms."}, {"title_reference": "model", "#text": "Algorithm analysis is essentially an exercise in modeling.\nA  is a simplification of reality that preserves only the\nessential elements.\nWith a model, we can more easily focus on and reason about these\nessentials."}, {"title_reference": ["summations <summation>", "recurrence relations <recurrence relation>"], "#text": "Our primary tactical concern for the semester will be how to recognize\nif an algorithm is efficient or not.\nWe will need (and so will study) a lot of mathematical tools for this.\nYour primary tools will be  and\n.\nGiven the nature of many of our algorithms, we need to develop a lot\nof proficiency using logarithms."}]}, {"@ids": "modeling-algorithm-cost", "@names": "modeling\\ algorithm\\ cost", "title": "Modeling Algorithm Cost", "paragraph": ["We want to measure the cost of an algorithm.\nWe want this process to be as simple as possible.\nWe need a yardstick to define the \"cost\" of the algorithm.\nQualities for this yardstick are:", {"strong": "which", "#text": "The fundamental driver for algorithm analysis is the behavior (growth\nrate) of a the algorithm as the problem size grows.\nJust to complicate things: Algorithms can behave very different on\ndifferent inputs of a given size.\nThe concepts of best, average, and worst cases come in here.\nTo have a meaningful discussion about the behavior of an algorithm, we\nhave to agree in advance about  of the many behaviors that\nalgorithm might have in terms of its growth rate as the input size\ngrows."}, "To model the growth rate of an algorithm, we need:", {"title_reference": "cost model", "#text": "To get a measurement, either for the problem size or the solution\neffort, we have to have a .\nHere is a simple example.\nAssume that our problem is how to square a value.\nWe will accept as our input size the value that we want to square.\n(Later on, we will actually come to realize that this is actually a\nlousy way to model input size for a numeric problem, but it will do\nfor now.)"}, {"strong": "good", "#text": "Here is an example of a model for a cost measure.\nLike any model, it might or might not be a  model.\nLook back at the list of qualities for a good model, and think about\nwhether this example has those qualities or not as you read through\nit."}, "Our problem is to calculate the square of a number.", "We will model the input size as simply the value of the number.\n(Later we will come to realize that this is a lousy model for the\ninput size of a numeric problem. But its good enough for now.)", {"strong": "is", "#text": "To model the cost of the solution, we will assume that\nasigning to a variable takes fixed time.\nWe will also assume that all other operations take no time.\n(Is this a good model? Whether it is good or not, it  a model.)"}, "Algorithm 1:", "One assignment was made, so the cost is 1.\nIs this a good model for our intuitive notion of the cost for this\ncode fragment?\nMost people would consider this a reasonable estimate of the work done\nfor most purposes.\nSo it looks like a reasonable model.", "Algorithm 2:", "The number of assignments made is", {"title_reference": ["2n + 1", "n+1", "2n+1", "n+1", "2n+1"], "#text": "Now, there is a lot of room for quibbling here.\nDepending on how you want to deal with loop variables,\nyou might want to say that the number of assignments is\n.\nThis makes a difference of  vs .\nDoes it matter?\nNot so much.\nWe didn't know the exact amount of time for an operation\nto begin with, so the factor of 2 doesn't seem to mean much.\nWhat is important is that the growth rates of these two are the same.\nIn fact, this is the key consideration.\nPerhaps we are concerned about whether an assignment is the same in\nreal runtime cost as a multiplication, which might be different from\nan addition.\nMaybe incrementing a loop variable costs something different from\ndoing an ordinary assignment.\nBut really none of this matters when compared against the fundamental\nrecognition that the cost of this algorithm is proportional to the\ninput size (in this case, the value of the input variable).\n and  both have linear growth rate,\nso they are both equally predictive of the growth rate for the\nalgorithm.\nIf we all agree that this approch to squaring a number has a linear\ngrowth rate on the size of the number, then we can conclude that this\nis a reasonable model for the purpose of estimating the growth rate."}, "Algorithm 3:", "The number of assignments made is:", "Again, this is a reasonable model for the cost of this algorithm.", "Now, given three algorithms, and with a model in hand for measuring\ntheir costs, the next question is:\nWhich of these three algorithms is best (meaning, requires the\nleast amount of work to run)?\nObviously we consider the first to be best in this sense.", "In comparison to the above example, consider a problem that involves\nstring assignment (done by copying the characters in the string).\nIn this case, is our model that assignment has contant time cost still\ngood?\nThink about this.", {"title_reference": "imathrm{th}", "strong": "not", "#text": "As another example of modeling:\nConsider a problem that works on a list, and an important basic\noperation is accessing the  record on the list.\nWe can take as our model that such an access requires one unit of\nwork.\nIf the list is implemented using an array in memory, then we probably\nconsider this to be a \"reasonable\" model.\nIf the list is implemented using a singly linked list, then we\nprobably do  consider this to be a \"reasonable\" model.\n(Why?)"}], "block_quote": [{"bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "It should measure something that we care about.\nUsually we care about time, but not always."}, {"paragraph": "It should by quantitative, allowing comparisons."}, {"paragraph": "It should be easy to compute (the measure, not the algorithm)."}, {"paragraph": "It should be a good predictor of what a corresponding program\nwould actually cost."}]}}, {"bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "A measure for problem size."}, {"definition_list": {"definition_list_item": {"term": "A measure for solution effort.", "definition": {"bullet_list": {"@bullet": "*", "list_item": {"paragraph": {"title_reference": "basic operations <basic operation>", "#text": "We use a count of the \nas a measure of solution effort."}}}}}}}]}}], "literal_block": [{"@xml:space": "preserve", "#text": "sum = n*n;"}, {"@xml:space": "preserve", "#text": "sum = 0;\nfor (i=1; i<=n; i++)\n  sum = sum + n;"}, {"@xml:space": "preserve", "#text": "sum = 0;\nfor (i=1; i<=n; i++)\n  for (j=1; j<=n; j++)\n    sum = sum + 1;"}], "math_block": [{"@xml:space": "preserve", "#text": "1 + \\sum_{i=1}^{n} 1 = n + 1"}, {"@xml:space": "preserve", "#text": "1 + \\sum_{i=1}^{n} \\sum_{j=1}^n 1 = n^2 + 1"}]}, {"@ids": "big-issues", "@names": "big\\ issues", "title": "Big Issues", "paragraph": [{"strong": "How do we create an efficient algorithm?", "title_reference": "dynamic programming", "#text": "We use problem solving and algorithm design skills.\nThis semester, we will see some standard algorithm design techniques.\nOne good example of such a design technique that works for a lot of\nproblems is ."}, {"strong": "How do we recognize a \"good\" algorithm?", "#text": "This is a key issue, because we don't know whether to stop with trying\nto create a \"good\" algorithm unless we can recognize one.\nOur answer is: By the relationship of its performance to the intrinsic\ndifficulty of the problem.\nOf course, that requires a measure for the algorithm's performance and\na measure for the intrinsic difficulty of the problem."}, {"strong": "How \"hard\" is a problem?", "title_reference": "lower bound", "#text": "That is, what is its intrinsic difficulty?\nThis is where the concept of the  for a problem\ncomes in.\nFor now, we will restrict the term \"hard\" to mean \"How much does it\ncost to run?\"\nLater, we will talk about some different meanings for the term \"hard\"."}, "As we go through a series of problems this semester, we will use the\nfollowing general plan:", "If the two bounds that we compute do not match, then here are some\noptions:"], "block_quote": [{"bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "Define a PROBLEM."}, {"paragraph": "Build a MODEL to measure the size of the input, and the cost of a\nsolution to the problem."}, {"paragraph": "Design an ALGORITHM to solve the problem."}, {"definition_list": {"definition_list_item": {"term": "ANALYZE both problem and algorithm under the model.", "definition": {"bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "Analyze an algorithm to get an UPPER BOUND."}, {"paragraph": "Analyze a problem to get a LOWER BOUND."}]}}}}}, {"paragraph": "COMPARE the bounds to see if our solution is \"good enough\"."}]}}, {"bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "Redesign the algorithm, or invent a new one."}, {"paragraph": "Tighten the bounds (if they were not already tight)."}, {"paragraph": "Change the model."}, {"paragraph": "Change the problem."}]}}]}]}}