{"document": {"@dupnames": "topological\\ sort", "@ids": "topological-sort", "@source": "<string>", "@title": "Topological Sort", "title": "Topological Sort", "subtitle": {"@dupnames": "topological\\ sort", "@ids": "id1", "#text": "Topological Sort"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@ids": "topsort", "@names": "topsort", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "topsortCON", "@long_name": "topsortCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}], "paragraph": [{"title_reference": "topological sort", "#text": "Assume that we need to schedule a series of tasks, such as classes or\nconstruction jobs, where we cannot start one task until after its\nprerequisites are completed.\nWe wish to organize the tasks into a linear order that allows us to\ncomplete them one at a time without violating any prerequisites.\nWe can model the problem using a DAG.\nThe graph is directed because one task is a prerequisite of\nanother -- the vertices have a directed relationship.\nIt is acyclic because a cycle would indicate a conflicting series of\nprerequisites that could not be completed without violating at least\none prerequisite.\nThe process of laying out the vertices of a DAG in a linear order to\nmeet the prerequisite rules is called a ."}, {"title_reference": "Figure #TopSort", "#text": "Figure  illustrates the problem.\nAn acceptable topological sort for this example is J1,\nJ2, J3, J4, J5, J6, J7. However, other orders are also acceptable,\nsuch as J1, J3, J2, J6, J4, J5, J7."}], "target": {"@refid": "topsort"}, "section": [{"@ids": "depth-first-solution", "@names": "depth-first\\ solution", "title": "Depth-first solution", "paragraph": [{"literal": ["PreVisit", "PostVisit"], "#text": "A topological sort may be found by performing a DFS on the graph.\nWhen a vertex is visited, no action is taken (i.e., function\n does nothing).\nWhen the recursion pops back to that vertex, function\n prints the vertex.\nThis yields a topological sort in reverse order.\nIt does not matter where the sort starts, as long as all vertices\nare visited in the end.\nHere is implementation for the DFS-based algorithm."}, {"title_reference": "Figure #TopSort", "#text": "Using this algorithm starting at J1 and visiting adjacent\nneighbors in alphabetic order, vertices of the graph in\nFigure  are printed out in the order J7,\nJ5, J4, J6, J2, J3, J1.\nReversing this yields the topological sort\nJ1, J3, J2, J6, J4, J5, J7."}, "Here is another example."], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "topSort", "@long_name": "topSort", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}]}, {"@ids": "queue-based-solution", "@names": "queue-based\\ solution", "title": "Queue-based Solution", "paragraph": ["We can implement topological sort using a queue\ninstead of recursion, as follows.", {"title_reference": ["v", "v", "v", "Figure #TopSort"], "#text": "First visit all edges, counting the number of\nedges that lead to each vertex (i.e., count the number of\nprerequisites for each vertex).\nAll vertices with no prerequisites are placed on the queue.\nWe then begin processing the queue.\nWhen Vertex  is taken off of the queue, it is printed, and all\nneighbors of  (that is, all vertices that have  as a\nprerequisite) have their counts decremented by one.\nPlace on the queue any neighbor whose count becomes zero.\nIf the queue becomes empty without printing all of the vertices, then\nthe graph contains a cycle (i.e., there is no possible ordering\nfor the tasks that does not violate some prerequisite).\nThe printed order for the vertices of the graph in\nApplying the queue version of topological sort to the graph of\nFigure  produces J1, J2, J3, J6, J4, J5, J7.\nHere is an implementation for the algorithm."}, "Here is the code to implement the queue-based topological sort:"], "raw": [{"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "qTopSort", "@long_name": "qTopSort", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Graph/topsortCON.js"}]}]}}