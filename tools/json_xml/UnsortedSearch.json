{"document": {"@ids": "analyzing-search-in-unsorted-lists", "@names": "analyzing\\ search\\ in\\ unsorted\\ lists", "@source": "<string>", "@title": "Analyzing Search in Unsorted Lists", "title": "Analyzing Search in Unsorted Lists", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@ids": "analysis", "@names": "analysis", "title": "Analysis", "paragraph": [{"title_reference": "Theta(n)", "#text": "You already know the simplest form of search:\nthe sequential search algorithm.\nSequential search on an unsorted list requires  time\nin the worst case."}, {"title_reference": ["K", "K", "n+1", "K", "n-1", "L", "K"], "strong": ["L", "L", "L", "L"], "#text": "How many comparisons does linear search do on average?\nA major consideration is whether  is in list  at\nall.\nWe can simplify our analysis by ignoring everything about the input\nexcept the position of  if it is found in .\nThus, we have  distinct possible events:\nThat  is in one of positions 0 to  in \n(each position having its own probability), or that it is not in\n at all.\nWe can express the probability that  is not in  as"}, {"title_reference": ["mathbf{P}(x)", "x"], "#text": "where  is the probability of event\n."}, {"title_reference": ["p_i", "K", "i", "n-1", "i", "i+1", "K", "i", "i+1", "K", "n", "p_n", "K", "mathbf{T}(n)"], "strong": ["L", "L", "L"], "#text": "Let  be the probability that  is in position\n of  (indexed from 0 to .\nFor any position  in the list, we must look at \nrecords to reach it.\nSo we say that the cost when  is in position  is\n.\nWhen  is not in , sequential search will require\n comparisons.\nLet  be the probability that  is not in .\nThen the average cost  will be"}, {"title_reference": ["p_i", "p_n"], "#text": "What happens to the equation if we assume all the  's\nare equal (except )?"}, {"title_reference": ["p_n", "frac{n+1}{2} leq mathbf{T}(n) leq n"], "#text": "Depending on the value of ,\n."}], "math_block": [{"@xml:space": "preserve", "#text": "\\mathbf{P}(K \\notin \\mathbf{L}) =\n1 - \\sum_{i=1}^n \\mathbf{P}(K = \\mathbf{L}[i])"}, {"@xml:space": "preserve", "#text": "\\mathbf{T}(n) = n p_n + \\sum_{i=0}^{n-1} (i+1) p_i."}, {"@xml:space": "preserve", "#text": "\\mathbf{T}(n) &=& p_n n + \\sum_{i=0}^{n-1} (i+1) p\\\\\n&=& p_n n + p\\sum_{i=1}^n i\\\\\n&=& p_n n + p\\frac{n(n+1)}{2}\\\\\n&=& p_n n + \\frac{1 - p_n}{n}\\frac{n(n+1)}{2}\\\\\n&=& \\frac{n + 1 + p_n(n-1)}{2}"}]}, {"@ids": "lower-bounds-proofs", "@names": "lower\\ bounds\\ proofs", "title": "Lower Bounds Proofs", "paragraph": [{"strong": ["L", "L", "L"], "title_reference": ["n", "K", "k", "<", "=", ">"], "#text": "Given an (unsorted) list  of  elements and\na search key , we seek to identify one element in \nwhich has key value , if any exists.\nFor the rest of this discussion, we will assume that the key values\nfor the elements in  are unique, that the set of all possible\nkeys is totally ordered (that is, the operations\n, , and  are defined for all pairs of key\nvalues),\nand that comparison is our only way to find the relative ordering of\ntwo keys.\nOur goal is to solve the problem using the minimum number of\ncomparisons."}, {"title_reference": ["n", "K"], "#text": "Given this definition for searching, we can easily come up with the\nstandard sequential search algorithm, and we can also see that the\nlower bound for this problem is \"obviously\"  comparisons.\n(Keep in mind that the key  might not actually appear in the\nlist.)\nHowever, lower bounds proofs are a bit slippery, and it is instructive\nto see how they can go wrong."}, "Here is our first attempt at proving the theorem.", {"strong": "L", "title_reference": "n", "#text": "Is this proof correct? Hopefully it is reasonably obvious to you that\nnot all algorithms must search through the list in a specific order,\nso not all algorithms have to look at position  [] last."}, "OK, so we can try to dress up the proof by making the process a bit more\nflexible.", {"title_reference": ["i", "n-1", "n-1"], "#text": "Is this proof correct? Still, no.\nFirst of all, any given algorithm need not necessarily consistently\nskip any given position  in its  searches.\nFor example, it is not necessary that all algorithms search the list\nfrom left to right.\nIt is not even necessary that all algorithms search the same\n positions first each time through the list.\nPerhaps it picks them at random."}, "Again, we can try to dress up the proof as follows.", {"strong": ["L", "L", "L"], "title_reference": ["K", "K", "K", "K"], "#text": "Unfortunately, there is another error that needs to be fixed.\nIt is not true that all algorithms for solving the problem must work\nby comparing elements of  against .\nAn algorithm might make useful progress by comparing elements of\n against each other.\nFor example, if we compare two elements of , then compare the\ngreater against  and find that this element is less than\n, we know that the other element is also less than\n.\nIt seems intuitively obvious that such comparisons won't actually lead\nto a faster algorithm, but how do we know for sure?\nWe somehow need to generalize the proof to account for this approach."}, {"title_reference": ["total order", "partially ordered set", "poset", "Figure #Poset"], "#text": "We will now present a useful abstraction for expressing the state of\nknowledge for the value relationships among a set of objects.\nA  defines relationships within a\ncollection of objects such that for every pair of objects, one is\ngreater than the other.\nA  or  is a set on which\nonly a partial order is defined.\nThat is, there can be pairs of elements for which we cannot decide\nwhich is \"greater\".\nFor our purpose here, the partial order is the state of our current\nknowledge about the objects,\nsuch that zero or more of the order relations between pairs of\nelements are known.\nWe can represent this knowledge by drawing directed acyclic graphs\n(DAGs) showing the known relationships, as illustrated by\nFigure ."}], "topic": [{"title": "Theorem", "paragraph": {"title_reference": "n", "#text": "The lower bound for the problem of searching in an unsorted list is\n comparisons."}}, {"title": "Proof 1", "paragraph": {"title_reference": ["A", "n-1", "K", "n", "A", "K", "n", "K", "n"], "strong": ["L", "L", "L"], "#text": "We will try a proof by contradiction.\nAssume an algorithm  exists that requires only \n(or less) comparisons of  with elements of .\nBecause there are  elements of ,  must have\navoided comparing  with  [].\nWe can feed the algorithm an input with  in position\n.\nSuch an input is legal in our model, so the algorithm is\nincorrect."}}, {"title": "Proof 2", "paragraph": {"title_reference": ["A", "n-1", "K", "n", "A", "K", "i", "i", "K", "i"], "strong": ["L", "L", "L"], "#text": "We will try a proof by contradiction.\nAssume an algorithm  exists that requires only \n(or less) comparisons of  with elements of .\nBecause there are  elements of ,  must have\navoided comparing  with  [] for some value\n.\nWe can feed the algorithm an input with  in position\n.\nSuch an input is legal in our model, so the algorithm is\nincorrect."}}, {"title": "Proof 3", "paragraph": {"title_reference": ["n-1", "K", "i", "K", "i", "n"], "emphasis": "some", "#text": "On any given run of the algorithm,\nif  elements are compared against , then\n element position (call it position ) gets skipped.\nIt is possible that  is in position  at that\ntime, and will not be found.\nTherefore,  comparisons are required."}}, {"title": "Proof 4", "paragraph": [{"strong": ["L", "L", "L"], "title_reference": ["K", "n", "n"], "#text": "Initially, we know nothing about the relative order of the\nelements in , or their relationship to .\nSo initially, we can view the  elements in  as being\nin  separate partial orders.\nAny comparison between two elements in  can affect the\nstructure of the partial orders."}, {"strong": ["L", "L", "L"], "title_reference": ["K", "A", "A", "m", "n-m", "K", "K", "n"], "#text": "Now, every comparison between elements in  can at best combine\ntwo of the partial orders together.\nAny comparison between  and an element, say , in\n can at best eliminate the partial order that contains\n.\nThus, if we spend  comparisons comparing elements in \nwe have at least  partial orders.\nEvery such partial order needs at least one comparison against\n to make sure that  is not somewhere in that\npartial order.\nThus, any algorithm must make at least  comparisons in the\nworst case."}]}], "target": {"@refid": "poset"}, "raw": {"@format": "xml", "@ids": "poset", "@names": "poset", "@xml:space": "preserve", "odsafig": "null"}}]}}