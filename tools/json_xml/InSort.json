{"document": {"@ids": "chapter-introduction-sorting", "@names": "chapter\\ introduction:\\ sorting", "@source": "<string>", "@title": "Chapter Introduction: Sorting", "title": "Chapter Introduction: Sorting", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "paragraph": [{"title_reference": ["Kruskal's algorithm", "minimal-cost spanning tree <minimal-cost spanning tree> <MCST>"], "#text": "We sort many things in our everyday lives:\nA handful of cards when playing Bridge;\nbills and other piles of paper; jars of spices; and so on.\nAnd we have many intuitive strategies that we can use to do the\nsorting, depending on how many objects we have to sort and how hard\nthey are to move around.\nSorting is also one of the most frequently performed computing tasks.\nWe might sort the records in a database so that we can search the\ncollection efficiently.\nWe might sort customer records by zip code so that when we print an\nadvertisement we can then mail them more cheaply.\nWe might use sorting to help an algorithm to solve some other\nproblem.\nFor example,  to find a\n\nmust sort the edges of a graph by their lengths before it can process\nthem."}, {"title_reference": ["Insertion Sort <insertion sort> <InsertionSort>", "Quicksort <Quicksort> <Quicksort>"], "#text": "Because sorting is so important, naturally it has been studied\nintensively and many algorithms have been devised.\nSome of these algorithms are straightforward adaptations of schemes we\nuse in everyday life.\nFor example, a natural way to sort your cards in a bridge hand is to\ngo from left to right, and place each card in turn in its correct\nposition relative to the other cards that you have already sorted.\nThis is the idea behind\n.\nOther sorting algorithms are totally alien to how humans do things,\nhaving been invented to sort thousands or even millions of records\nstored on the computer.\nFor example, no normal person would use\n\nto order a pile of bills by date, even though Quicksort is the\nstandard sorting algorithm of choice for most software libraries.\nAfter years of study, there are still unsolved problems related to\nsorting.\nNew algorithms are still being developed and refined for\nspecial-purpose applications."}, {"title_reference": ["divide and conquer", "Mergesort <Mergesort> <Mergesort>", "Quicksort <Quicksort> <Quicksort>", "Radix Sort <radix sort> <RadixSort>", "average case", "worst case", "Shellsort <Shellsort> <Shellsort>", "best case", "Heapsort <Heapsort> <Heapsort>", "External Sorting <external sort> <ExternalSort>"], "#text": "Along with introducing this central problem in computer science,\nstudying sorting algorithms helps us to understand\nissues in algorithm design and analysis.\nFor example, the sorting algorithms in this chapter show multiple\napproaches to using .\nIn particular, there are multiple ways to do the dividing.\n divides a list in half.\n divides a list into big\nvalues and small values.\n divides the problem by\nworking on one digit of the key at a time.\nSorting algorithms can also illustrate a wide variety of\nalgorithm analysis techniques.\nQuicksort illustrates that it is possible for an algorithm to have an\n whose growth rate is significantly smaller than\nits .\nIt is possible to speed up one sorting algorithm\n(such as  or Quicksort)\nby taking advantage of the  behavior of another\nalgorithm (Insertion Sort).\nSpecial case behavior by some sorting algorithms makes them a\ngood solution for special niche applications\n().\nSorting provides an example of an important technique for\nanalyzing the lower bound for a problem.\n refers to the\nprocess of sorting large files stored on disk."}, {"title_reference": ["Theta(n^2)", "n", "Theta(n log n)", "Theta(n)", "Omega(n log n)"], "#text": "This chapter covers several standard algorithms appropriate\nfor sorting a collection of records that fit into the computer's\nmain memory.\nIt begins with a discussion of three simple, but relatively slow,\nalgorithms that require \ntime in the average and worst cases to sort  records.\nSeveral algorithms with considerably better performance are then\npresented, some with  worst-case running\ntime.\nThe final sorting method presented requires only\n worst-case time under special conditions\n(but it cannot run that fast in the general case).\nThe chapter concludes with a proof that sorting in general\nrequires  time in the worst case."}]}}