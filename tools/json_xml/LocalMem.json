{"document": {"@dupnames": "local\\ memory", "@ids": "local-memory", "@source": "<string>", "@title": "Local Memory", "title": "Local Memory", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@ids": "thanks-for-the-memory-allocation-and-deallocation", "@names": "thanks\\ for\\ the\\ memory:\\ allocation\\ and\\ deallocation", "title": "Thanks For The Memory: Allocation and Deallocation", "paragraph": [{"title_reference": "Local variables <local variable>", "#text": "are the programming structure\neveryone uses but no one thinks about.\nYou think about them a little when first mastering the syntax.\nBut after a few weeks, the variables are so automatic that you soon\nforget to think about how they work.\nThis situation is a credit to modern programming languages  most\nof the time variables appear automatically when you need them, and\nthey disappear automatically when you are finished.\nFor basic programming, this is a fine situation.\nHowever, for advanced programming, it's going to be useful to have an\nidea of how variables work..."}, {"title_reference": ["allocated", "deallocated", "lifetime"], "#text": "Variables represent storage space in the computer's memory.\nEach variable presents a convenient names like length or sum in the\nsource code.\nBehind the scenes at runtime, each variable uses an area of the\ncomputer's memory to store its value.\nIt is not the case that every variable in a program has a permanently\nassigned area of memory.\nInstead, modern languages are smart about giving memory to a variable\nonly when necessary.\nThe terminology is that a variable is allocated when it is given an\narea of memory to store its value.\nWhile the variable is , it can operate as a variable\nin the usual way to hold a value.\nA variable is  when the system reclaims the memory\nfrom the variable, so it no longer has an area to store its value.\nFor a variable, the period of time from its allocation until its\ndeallocation is called its ."}, "The most common memory related error is using a deallocated variable.\nFor local variables, modern languages automatically protect against\nthis error.\nWith pointers, as we will see however, the programmer must make sure\nthat allocation is handled correctly."]}, {"@dupnames": "local\\ memory", "@ids": "id1", "title": "Local Memory", "paragraph": [{"title_reference": ["local variables", "local storage"], "literal": ["num", "result", "num", "result"], "#text": "The most common variables you use are  within\nfunctions such as the variables  and  in the\nfollowing function.\nAll of the local variables and parameters taken together are called\nits  or just its \"locals\", such as\n and  in the following code..."}, {"literal": ["Square()", "num", "result", "result = num * num"], "#text": "The variables are called \"local\" to capture the idea that their lifetime is tied to the\nfunction where they are declared. Whenever the function runs, its local variables are\nallocated. When the function exits, its locals are deallocated. For the above example, that\nmeans that when the  function is called, local storage is allocated for\n and . Statements like ; in the function use the local\nstorage. When the function finally exits, its local storage is deallocated."}, "Here is a more detailed version of the rules of local storage:"], "literal_block": {"@xml:space": "preserve", "#text": "// Local storage example\nint Square(int num) {\n  int result;\n  result = num * num;\n  return result;\n}"}, "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"literal": ["{", "int"], "#text": "When a function is called, memory is allocated for all of its\nlocals. In other words, when the flow of control hits the starting\n for the function, all of its locals are allocated\nmemory. Parameters such as num and local variables such as result\nin the above example both count as locals. The only difference\nbetween parameters and local variables is that parameters start\nout with a value copied from the caller while local variables\nstart with random initial values. This article mostly uses simple\n variables for its examples, however local allocation works\nfor any type: structs, arrays... these can all be allocated\nlocally."}}, {"paragraph": "The memory for the locals continues to be allocated so long as the\nthread of control is within the owning function. Locals continue to\nexist even if the function temporarily passes off the thread of\ncontrol by calling another function. The locals exist undisturbed\nthrough all of this."}, {"paragraph": {"literal": ["num", "result``only make sense within\nthe body of ``Square()"], "title_reference": "lexical scoping", "#text": "Finally, when the function finishes and exits, its locals are\ndeallocated. This makes sense in a way  suppose the locals were\nsomehow to continue to exist  how could the code even refer to\nthem? The names like  and  anyway. Once the flow of control leaves\nthat body, there is no way to refer to the locals even if they were\nallocated. That locals are available (\"scoped\") only within their\nowning function is known as  and pretty much\nall    languages do it that way now."}}]}}, {"@ids": "examples", "@names": "examples", "title": "Examples", "paragraph": ["Here is a simple example of the lifetime of local storage.", "Here is a larger example which shows how the simple rule \"the locals\nare allocated when their function begins running and are deallocated\nwhen it exits\" can build more complex behavior.\nYou will need a firm grasp of how local allocation works to understand the\nmaterial in later modules.\nThe drawing shows the sequence of allocations and deallocations which\nresult when the function X() calls the function Y() twice.\nThe points in time T1, T2, etc. are marked in\nthe code and the state of memory at that time is shown in the drawing.", "(optional extra...) The drawing shows the sequence of the locals being allocated and\ndeallocated  in effect the drawing shows the operation over time of\nthe ` runtime stack` which is the data structure which the\nsystem uses to implement local storage."], "literal_block": [{"@xml:space": "preserve", "#text": "void Foo(int a) {\n      // (1) Locals (a, b, i, scores) allocated when Foo runs\n      int i;\n      float scores[100];\n      // This array of 100 floats is allocated locally.\n      a = a + 1;\n      // (2) Local storage is used by the computation\n      for (i=0; i<a; i++) {\n        Bar(i + a); // (3) Locals continue to exist undisturbed,\n      }  // even during calls to other functions.\n} // (4) The locals are all deallocated when the function exits."}, {"@xml:space": "preserve", "#text": "void X() {\n  int a = 1;\n  int b = 2;\n  //T1\n\n  Y(a);\n  //T3\n  Y(b);\n\n //T5\n}\n\nvoid Y(int p) {\n  int q;\n  q = p + 2;\n  //T2 (first time through), T4 (second time through)\n}"}], "raw": {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}}, {"@ids": "local-parameters", "@names": "local\\ parameters", "title": "Local Parameters", "paragraph": {"literal": ["X()", "a", "b", "Y()", "p", "q"], "#text": "Local variables are tightly associated with their function  they\nare used there and nowhere else.\nOnly the  code can refer to its  and .\nOnly the  code can refer to its  and .\nThis independence of local storage is the root cause of both its\nadvantages and disadvantages."}, "section": [{"@dupnames": "disadvantages\\ of\\ locals", "@ids": "disadvantages-of-locals", "title": "Disadvantages Of Locals", "paragraph": "Locals are great for 90% of a program's memory needs:", "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "Convenient. Locals satisfy a convenient need  functions often need\nsome temporary memory which exists only during the function's\ncomputation. Local variables conveniently provide this sort of\ntemporary, independent memory."}, {"paragraph": "Efficient. Relative to other memory use techniques, locals are very\nefficient. Allocating and deallocating them is time efficient (fast)\nand they are space efficient in the way they use and recycle memory"}, {"paragraph": {"title_reference": "pass by value", "literal": ["=", "p"], "#text": "Local Copies. Local parameters are basically local copies of the\ninformation from the caller. This is also known as\n.\nParameters are local variables which are initialized with an\nassignment () operation from the caller. The caller is not\n\"sharing\" the parameter value with the callee in the pointer sense\nthe callee is getting its own copy. This has the advantage that the\ncallee can change its local copy without affecting the caller. (Such\nas with the  parameter in the above example.) This independence\nis good since it keeps the operation of the caller and callee\nfunctions separate which follows the rules of good software\nengineering  keep separate components as independent as possible"}}]}}, {"@dupnames": "disadvantages\\ of\\ locals", "@ids": "id2", "title": "Disadvantages Of Locals", "paragraph": "There are two disadvantages of Locals:", "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"title_reference": "heap", "#text": "Short Lifetime. Their allocation and deallocation schedule (their\n\"lifetime\") is very strict. Sometimes a program needs memory which\ncontinues to be allocated even after the function which originally\nallocated it has exited. Local variables will not work since they\nare deallocated automatically when their owning function\nexits. This problem will be solved in a later section with\n memory."}}, {"paragraph": "Restricted Communication. Since locals are copies of the caller\nparameters, they do not provide a means of communication from the\ncallee back to the caller. This is the downside of the\n\"independence\" advantage. Also, sometimes making copies of a value\nis undesirable for other reasons. We will see the solution to this\nproblem below in the next module."}]}}, {"@ids": "synonyms-for-local", "@names": "synonyms\\ for\\ \"local\"", "title": "Synonyms For \"Local\"", "paragraph": {"title_reference": "automatic variables", "#text": "Local variables are also known as  since\ntheir allocation and deallocation is done automatically as part of the\nfunction call mechanism.\nLocal variables are also sometimes known as :term`stack variables`\nbecause, at a low level, languages almost always implement local\nvariables using a stack structure in memory."}}, {"@ids": "the-ampersand-bug-tab", "@names": "the\\ ampersand\\ (&)\\ bug\\ tab", "title": "The Ampersand (&) Bug  TAB", "paragraph": [{"literal": ["Victim()", "TAB()"], "#text": "Now that you understand the allocation schedule of locals, you can\nappreciate one of the more ugly bugs possible in C and C++.\nWhat is wrong with the following code where the\nfunction  calls the function ?\nTo see the problem, it may be useful to make\na drawing to trace the local storage of the two functions."}, {"literal": ["TAB()", "TAB()", "TAB()", "int", "int``allocated? The problem is that the local ``int", "temp", "TAB()", "TAB()", "TAB()", "Y()"], "title_reference": ["TAB()", "&"], "#text": "is actually fine while it is running. The problem happens to its caller after  exits.  returns a pointer to an\n, but where is that , , is allocated only while  is running. When  exits,\nall of its locals are deallocated. So the caller is left with a pointer to a deallocated variable. 's locals are deallocated when it exits, just as happened to the locals for\n in the previous example. It is incorrect (and useless) for  to return a pointer to memory which is about to be\ndeallocated. We are essentially running into the \"lifetime\" constraint of local variables.\nWe want the int to exist, but it gets deallocated automatically. Not all uses of & between\nfunctions are incorrect  only when used to pass a pointer back to the caller. The correct\nuses of  are discussed in section 3, and the way to pass a pointer back to the caller is\nshown in section 4."}], "literal_block": {"@xml:space": "preserve", "#text": "// TAB -- The Ampersand Bug function\n// Returns a pointer to an int\nint* TAB() {\nint temp;\nreturn(&temp);\n// return a pointer to the local int\n}\nvoid Victim() {\nint* ptr;\nptr = TAB();\n*ptr = 42;\n// Runtime error! The pointee was local to TAB"}}, {"@ids": "local-memory-summary", "@names": "local\\ memory\\ summary", "title": "Local Memory Summary", "paragraph": "Locals are very convenient for what they do  providing convenient and efficient\nmemory for a function which exists only so long as the function is executing. Locals have\ntwo deficiencies which we will address in the following sections  how a function can\ncommunicate back to its caller (Section 3), and how a function can allocate separate\nmemory with a less constrained lifetime (section 4)."}]}, {"@ids": "how-does-the-function-call-stack-work", "@names": "how\\ does\\ the\\ function\\ call\\ stack\\ work?", "title": "How Does The Function Call Stack Work?", "paragraph": [{"literal": "foo(6, x+1)", "#text": "You do not need to know how local variables are implemented during a function call, but\nhere is a rough outline of the steps if you are curious. The exact details of the\nimplementation are language and compiler specific. However, the basic structure below is\napproximates the method used by many different systems and languages...\nTo call a function such as :"}, "For the extremely curious, here are other miscellaneous notes on the\nfunction call process:"], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Evaluate the actual parameter expressions, such as the x+1, in the\ncaller's context."}, {"paragraph": {"literal": ["foo()", "foo()"], "title_reference": "call stack", "#text": "Allocate memory for 's locals by pushing a suitable \"local\nblock\" of memory onto a runtime  dedicated to this\npurpose. For parameters but not local variables, store the values\nfrom step (1) into the appropriate slot in 's local\nblock."}}, {"paragraph": {"literal": "foo()", "#text": "Store the caller's current address of execution (its \"return\naddress\") and switch execution to ."}}, {"paragraph": {"literal": "foo()", "#text": "executes with its local block conveniently available at\nthe end of the call stack."}}, {"paragraph": {"literal": "foo()", "#text": "When  is finished, it exits by popping its locals off the\nstack and \"returns\" to the caller using the previously stored\nreturn address. Now the caller's locals are on the end of the stack\nand it can resume executing."}}]}, "bullet_list": {"@bullet": "*", "list_item": [{"definition_list": {"definition_list_item": {"term": "This is why infinite recursion results in a \"Stack Overflow Error\"", "definition": {"paragraph": "the code keeps calling and calling resulting in steps (1) (2)"}}}, "paragraph": "(3), (1) (2) (3), but never a step (4)....eventually the call stack\nruns out of memory."}, {"paragraph": "This is why local variables have random initial values  step (2)\njust pshes the whole local block in one operation. Each local gets\nits own area of memory, but the memory will contain whatever the\nmost recent tenant left there. To clear all of the local block for\neach function call would be too time expensive."}, {"paragraph": {"title_reference": ["activation record", "stack frame"], "#text": "The \"local block\" is also known as the function's\n or .\nThe entire block can be pushed onto the\nstack (step 2), in a single CPU operation  it is a very fast\noperation."}}, {"paragraph": "For a multithreaded environment, each thread gets its own call stack\ninstead of just having single, global call stack."}, {"paragraph": "For performance reasons, some languages pass some parameters through\nregisters and others through the stack, so the overall process is\ncomplex. However, the apparent the lifetime of the variables will\nalways follow the \"stack\" model presented here."}]}}]}}