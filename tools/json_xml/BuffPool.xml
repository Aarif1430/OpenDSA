<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="buffer\ pools" ids="buffer-pools" source="&lt;string&gt;" title="Buffer Pools"><title>Buffer Pools</title><subtitle dupnames="buffer\ pools" ids="id1">Buffer Pools</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Files/buffpoolCON.css</odsalink></raw><paragraph>Given a <title_reference>disk drive &lt;DiskExamp&gt;</title_reference>
rotating at 5400 rpm, <title_reference>average seek time</title_reference> of 9.5ms,
and <title_reference>track-to-track seek time</title_reference> of 2.2ms,
we can calculate that it takes about
<title_reference>9.5 + 11.1 times 1.5 = 26.2</title_reference> ms
to read one <title_reference>track</title_reference> of data on average.
It takes about
<title_reference>9.5 + 11.1/2 + (1/256)times11.1 = 15.1</title_reference> ms on average
to read a single <title_reference>sector</title_reference> of data.
This is a good savings (slightly over half the time), but
less than 1% of the data on the track are read.
If we want to read only a single byte, it would save us effectively no
time over that required to read an entire sector.
For this reason, nearly all disk drives automatically read or write
an entire sector's worth of information whenever the disk is
accessed, even when only one byte of information is requested.</paragraph><paragraph>Once a sector is read, its information is stored in main memory.
This is known as <title_reference>buffering</title_reference> or <title_reference>caching</title_reference> the information.
If the next disk request is to that same sector, then
it is not necessary to read from disk again because the information is
already stored in main memory.
Buffering is an example of a standard method for minimizing disk
accesses:
Bring off additional information from disk to satisfy future
requests.
If information from files were accessed at random, then the
chance that two consecutive disk requests are to the same sector
would be low.
However, in practice most disk requests are close to the location
(in the logical file at least) of the previous request,
a concept referred to as <title_reference>locality of reference</title_reference>.
This means that the probability of the next request
"hitting the cache" is much higher than chance would indicate.</paragraph><paragraph>This principle explains one reason why average access times for new
<title_reference>disk drives &lt;disk drive&gt;</title_reference> are lower than in the past.
Not only is the hardware faster, but information is also now stored
using better algorithms and larger caches that minimize the number
of times information needs to be fetched from disk.
This same concept is also used to store parts of programs in faster
memory within the CPU, using the CPU cache that is
prevalent in modern microprocessors.</paragraph><paragraph>Sector-level buffering is normally provided by the operating system
and is often built directly into the disk drive controller hardware.
Most operating systems maintain at least two buffers,
one for input and one for output.
Consider what would happen if there were only one buffer during a
byte-by-byte copy operation.
The sector containing the first byte would be read into the I/O
buffer.
The output operation would need to destroy the contents of the single
I/O buffer to write this byte.
Then the buffer would need to be filled again from disk for the
second byte, only to be destroyed during output.
The simple solution to this problem is to keep one buffer for input,
and a second for output.</paragraph><paragraph>Most disk drive controllers operate independently
from the CPU once an I/O request is received.
This is useful because the CPU can typically execute millions of
instructions during the time required for a single I/O operation.
A technique that takes maximum advantage of this micro-parallelism is
<title_reference>double buffering</title_reference>.
Imagine that a file is being processed sequentially.
While the first sector is being read, the CPU cannot process that
information and so must wait or find something else to do in the
meantime.
Once the first sector is read, the CPU can start processing
while the disk drive (in parallel) begins reading
the second sector.
If the time required for the CPU to process a sector is approximately
the same as the time required by the disk controller to read a sector,
it might be possible to keep the CPU continuously fed with data from
the file.
The same concept can also be applied to output, writing one sector to
disk while the CPU is writing to a second output buffer in memory.
Thus, in an operationg system that support double buffering, it pays
to have at least two input buffers and two output buffers available.</paragraph><paragraph>Caching information in memory is such a good idea that
it is usually extended to multiple buffers.
The operating system
or an application program might store many buffers of information
taken from some <title_reference>backing storage</title_reference> such as a disk file.
This process of using buffers as an intermediary between a user and a
disk file is called <title_reference>buffering</title_reference> the file.
The information stored in a buffer is often called a <title_reference>page</title_reference>, and
the collection of buffers is called a <title_reference>buffer pool</title_reference>.
The goal of the buffer pool is to increase the amount of information
stored in memory in hopes of increasing the likelihood that new
information requests can be satisfied from the buffer pool rather
than requiring new information to be read from disk.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="buffintroCON"
    long_name="buffintroCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><section ids="replacement-strategies" names="replacement\ strategies"><title>Replacement Strategies</title><paragraph>As long as there is an unused buffer available in the buffer pool,
new information can be read in from disk on demand.
When an application continues to read new information from
disk, eventually all of the buffers in the buffer pool will become
full.
Once this happens, some decision must be made about what information
in the buffer pool will be sacrificed to make room for newly
requested information.</paragraph><paragraph>When replacing information contained in the buffer pool,
the goal is to select a buffer that has "unnecessary"
information, that is, the information least likely to be requested
again.
Because the buffer pool cannot know for certain what the pattern of
future requests will look like, a decision based on some
<title_reference>heuristic</title_reference>, or best guess, must be used.
There are several approaches to making this decision.</paragraph><paragraph>One heuristic is <title_reference>first-in, first-out &lt;FIFO&gt;</title_reference>.
This scheme simply orders the buffers in a queue.
The buffer at the front of the queue is used next to store new
information and then placed at the end of the queue.
In this way, the buffer to be replaced is the one that has held its
information the longest, in hopes that this information is no longer
needed.
This is a reasonable assumption when processing moves along the file
at some steady pace in roughly sequential order.
However, many programs work with certain key pieces of
information over and over again, and the importance of information has
little to do with how long ago the information was first accessed.
Typically it is more important to know how many times the information
has been accessed, or how recently the information was last accessed.</paragraph><paragraph>Another approach is called <title_reference>least frequently used</title_reference> (<title_reference>LFU</title_reference>).
LFU tracks the number of accesses to each buffer in the
buffer pool.
When a buffer must be reused, the buffer that
has been accessed the fewest number of times is considered to contain
the "least important" information, and so it is used next.
LFU, while it seems intuitively reasonable, has many drawbacks.
First, it is necessary to store and update access counts for each buffer.
Second, what was referenced many times in the past might now be
irrelevant.
Thus, some time mechanism where counts "expire" is often desirable.
This also avoids the problem of buffers that slowly build up big
counts because they get used just often enough to avoid being
replaced.
An alternative is to maintain counts for all sectors ever read, not
just the sectors currently in the buffer pool.
This avoids immediately replacing the buffer just read, which has not
yet had time to build a high access count.</paragraph><paragraph>The third approach is called <title_reference>least recently used</title_reference>
(<title_reference>LRU</title_reference>).
LRU simply keeps the buffers in a list.
Whenever information in a buffer is accessed, this buffer is brought
to the front of the list.
When new information must be read, the buffer at the back of the
list (the one least recently used) is taken and its "old"
information is either discarded or written to disk, as appropriate.
This is an easily implemented approximation to LFU and is often the
method of choice for managing buffer pools unless
special knowledge about information access patterns for an application
suggests a special-purpose buffer management scheme.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="LRUCON"
    long_name="LRUCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></section><section ids="the-dirty-bit" names="the\ dirty\ bit"><title>The Dirty Bit</title><paragraph>The main purpose of a buffer pool is to minimize disk I/O.
When the contents of a block are modified, we could write the updated
information to disk immediately.
But what if the block is changed again?
If we write the block's contents after every change, that might be a
lot of disk write operations that can be avoided.
It is more efficient to wait until either the file is to be closed,
or the contents of the buffer containing that block is to be flushed
from the buffer pool.</paragraph><paragraph>When a buffer's contents are to be replaced in the buffer pool,
we only want to write the contents to disk if it is necessary.
That would be necessary only if the contents have changed since the
block was read in originally from the file.
The way to insure that the block is written when necessary, but only
when necessary, is to maintain a Boolean variable with the buffer
(often referred to as the <title_reference>dirty bit</title_reference>) that is turned on when
the buffer's contents are modified by the client.
At the time when the block is flushed from the buffer pool, it is
written to disk if and only if the dirty bit has been turned on.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="LRUwriteCON"
    long_name="LRUwriteCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Modern operating systems support <title_reference>virtual memory</title_reference>.
Virtual memory is a technique that allows the programmer to write
programs as though there is more of the faster main memory (such as
RAM) than actually exists.
Virtual memory makes use of a buffer pool to store data read from
blocks on slower, secondary memory (such as on the disk drive).
The disk stores the complete contents of the virtual memory.
Blocks are read into main memory as demanded by memory accesses.
Naturally, programs using virtual memory techniques are slower than
programs whose data are stored completely in main memory.
The advantage is reduced programmer effort because a good virtual memory
system provides the appearance of larger main memory without
modifying the program.</paragraph><paragraph>Here is a visualization to let you experiment with the various buffer
pool replacement strategies.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="BufferPoolAV"
    long_name="BufferPoolAV"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><comment xml:space="preserve">The following exercise needs to be completed, so that this can be</comment><comment xml:space="preserve">added back in.</comment><comment xml:space="preserve">Here is an exercise to help you practice.</comment><comment xml:space="preserve">.. avembed:: AV/Files/bufferpoolPRO.html pe</comment></section><section ids="implementing-buffer-pools" names="implementing\ buffer\ pools"><title>Implementing Buffer Pools</title><paragraph>When implementing buffer pools, there are two basic approaches that can
be taken regarding the transfer of information between the user of the
buffer pool and the buffer pool class itself.
The first approach is to pass "messages" between the two.
This approach is illustrated by the following abstract class:</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>This simple class provides an interface with two member functions,
<literal>insert</literal> and <literal>getbytes</literal>.
The information is passed between the buffer pool user and the
buffer pool through the <literal>space</literal> parameter.
This is storage space, provided by the bufferpool client and at least
<literal>sz</literal> bytes long, which the
buffer pool can take information from (the <literal>insert</literal> function) or
put information into (the <literal>getbytes</literal> function).
Parameter <literal>pos</literal> indicates where the information will be placed
in the buffer pool's logical storage space.
Physically, it will actually be copied to the appropriate byte
position in some buffer in the buffer pool.
This ADT is similar to the <literal>read</literal> and <literal>write</literal> methods of the
<title_reference>RandomAccessFile &lt;FileProg&gt;</title_reference> class of Java.</paragraph><target refid="examplebuffer"></target><topic ids="examplebuffer" names="examplebuffer"><title>Example</title><paragraph>Assume each sector of the disk file (and thus each block in the
buffer pool) stores 1024 bytes.
If the next request is to copy 40 bytes beginning at position 6000 of
the file, these bytes should be placed into Sector 5 (whose bytes go
from position 5120 to position 6143).</paragraph></topic><paragraph>An alternative interface is to have the buffer pool provide to the
user a direct pointer to a buffer that contains the requested
information.
Such an interface might look as follows:</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>In this approach, the buffer pool user is made aware that the
storage space is divided into blocks of a given size, where each block
is the size of a buffer.
The user requests specific blocks from the buffer pool, with a pointer
to the buffer holding the requested block being returned to the user.
The user might then read from or write to this space.
If the user writes to the space, the buffer pool must be informed of
this fact.
The reason is that, when a given block is to be removed from the
buffer pool, the contents of that block must be written to the backing
storage if it has been modified.
If the block has not been modified, then it is unnecessary to write it
out.</paragraph><topic><title>Example</title><paragraph>We wish to write 40 bytes beginning at logical position 6000 in
the file.
Using the second ADT, the client would need to know that blocks
(buffers) are of size 1024, and therefore would request access to
Sector 5.
A pointer to the buffer containing Sector 5 would be returned by
the call to <literal>getblock</literal>.
The client would then copy 40 bytes to positions 880-919 of the
buffer, and call <literal>dirtyblock</literal> to warn the buffer pool that the
contents of this block have been modified.</paragraph></topic><paragraph>A variation on this approach is to have the <literal>getblock</literal> function
take another parameter to indicate the "mode" of use for the
information.
If the mode is READ then the buffer pool assumes that no changes will
be made to the buffer's contents (and so no write operation need be
done when the buffer is reused to store another block).
If the mode is WRITE then the buffer pool assumes that the client will
not look at the contents of the buffer and so no read from the file is
necessary.
If the mode is READ AND WRITE then the buffer pool would read the
existing contents of the block in from disk, and write the contents of
the buffer to disk when the buffer is to be reused.
Using the "mode" approach, the <literal>dirtyblock</literal> method is avoided.</paragraph><paragraph>One problem with the buffer-passing ADT is the risk of
<title_reference>stale pointers &lt;stale pointer&gt;</title_reference>.
When the buffer pool user is given a pointer to some buffer
space at time <strong>T1</strong>, that pointer does indeed refer to the desired
data at that time.
As further requests are made to the buffer pool, it is possible that
the data in any given buffer will be removed and replaced with new
data.
If the buffer pool user at a later time <strong>T2</strong> then refers to the
data referred to by the pointer given at time <strong>T1</strong>, it is possible
that the data are no longer valid because the buffer contents have
been replaced in the meantime.
Thus the pointer into the buffer pool's memory has become "stale".
To guarantee that a pointer is not stale, it should not be used if
intervening requests to the buffer pool have taken place.</paragraph><paragraph>We can solve this problem by introducing the concept of a user (or
possibly multiple users) gaining access to a buffer, and then
releasing the buffer when done.
We will add method <literal>acquireBuffer</literal> and <literal>releaseBuffer</literal> for
this purpose.
Method <literal>acquireBuffer</literal> takes a block ID as input and returns a
pointer to the buffer that will be used to store this block.
The buffer pool will keep a count of the number of requests currently
active for this block.
Method <literal>releaseBuffer</literal> will reduce the count of active users for
the associated block.
Buffers associated with active blocks will not be eligible for
flushing from the buffer pool.
This will lead to a problem if the client neglects to release active
blocks when they are no longer needed.
There would also be a problem if there were more total active blocks
than buffers in the buffer pool.
So, the buffer pool should be initialized to include more
buffers than will ever need to be active at one time.</paragraph><paragraph>An additional problem with both ADTs presented so far comes when the
user intends to completely overwrite the contents of a block, and does
not need to read in the old contents already on disk.
However, the buffer pool cannot in general know whether the user
wishes to use the old contents or not.
This is especially true with the message-passing approach where a
given message might overwrite only part of the block.
In this case, the block will be read into memory even when not needed,
and then its contents will be overwritten.</paragraph><paragraph>This inefficiency can be avoided (at least in the buffer-passing
version) by separating the assignment of
blocks to buffers from actually reading in data for the block.
In particular, the following revised buffer-passing ADT does not
actually read data in the <literal>acquireBuffer</literal> method.
Users who wish to see the old contents must then issue a
<literal>readBlock</literal> request to read the data from disk into the buffer.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>Again, a mode parameter could be added to the <literal>acquireBuffer</literal>
method, eliminating the need for the <literal>readBlock</literal> and
<literal>markDirty</literal> methods.</paragraph><paragraph>Clearly, the buffer-passing approach places more obligations on the
user of the buffer pool.
These obligations include knowing the size of a block, not corrupting
the buffer pool's storage space, and informing the buffer pool both
when a block has been modified and when it is no longer needed.
So many obligations make this approach prone to error.
An advantage is that there is no need to do an extra copy step when
getting information from the user to the buffer.
If the size of the records stored is small, this is not an important
consideration.
If the size of the records is large (especially if the record size and
the buffer size are the same, as typically is the case when
implementing <title_reference>B-trees &lt;B-tree&gt; &lt;BTree&gt;</title_reference>, then this efficiency
issue might become important.
Note however that the in-memory copy time will always be far less than
the time required to write the contents of a buffer to disk.
For applications where disk I/O is the bottleneck for the program,
even the time to copy lots of information between the buffer pool user
and the buffer might be inconsequential.
Another advantage to buffer passing is the reduction in unnecessary
read operations for data that will be overwritten anyway.</paragraph><paragraph>Note that using Java generics would not be appropriate for use in the
buffer pool implementation.
In our ADTs, the <literal>space</literal> parameter and the buffer pointer are declared
to be <literal>byte[]</literal>
When a class uses a Java generic, that means that the record type is
arbitrary, but that the class knows what the record type is.
In contrast, using <literal>byte[]</literal> for the space means that not
only is the record type arbitrary, but also the buffer pool does not
even know what the user's record type is.
In fact, a given buffer pool might have many users who store many types
of records.</paragraph><paragraph>In a buffer pool, the user decides where a given record will be stored
but has no control over the precise mechanism by which data are
transferred to the backing storage.
This is in contrast to the <title_reference>memory manager &lt;MemmanIntro&gt;</title_reference>, in
which the user passes a record to the manager and has no control at
all over where the record is stored.</paragraph><raw format="xml" xml:space="preserve"><odsascript>AV/Files/buffintroCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Files/LRUCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Files/LRUwriteCON.js</odsascript></raw></section></document>