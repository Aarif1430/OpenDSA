{"document": {"@dupnames": "sample\\ hash\\ functions", "@ids": "sample-hash-functions", "@source": "<string>", "@title": "Sample Hash Functions", "title": "Sample Hash Functions", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@dupnames": "sample\\ hash\\ functions", "@ids": "id1", "title": "Sample Hash Functions", "section": [{"@ids": "simple-mod-function", "@names": "simple\\ mod\\ function", "title": "Simple Mod Function", "paragraph": ["Consider the following hash function used to hash integers to a table\nof sixteen slots:", "Here \"%\" is the symbol for the mod function.", {"title_reference": ["M", "M-1"], "#text": "Recall that the values 0 to 15 can be represented with four bits\n(i.e., 0000 to 1111).\nThe value returned by this hash function depends solely on\nthe least significant four bits of the key.\nBecause these bits are likely to be poorly distributed\n(as an example, a high percentage of the keys might be even numbers,\nwhich means that the low order bit is zero),\nthe result will also be poorly distributed.\nThis example shows that the size of the table \ncan have a big effect on the performance of a hash system because the table size\nis typically used as the modulus to ensure that the hash\nfunction produces a number in the range 0 to ."}], "literal_block": {"@xml:space": "preserve", "#text": "int h(int x) {\n  return x % 16;\n}"}, "raw": {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "hashFuncExCON1", "@long_name": "hashFuncExCON1", "@points": "0", "@required": "True", "@threshold": "1.0"}}}, {"@ids": "binning", "@names": "binning", "title": "Binning", "paragraph": ["Say we are given keys in the range 0 to 999, and have a hash table of\nsize 10.\nIn this case, a possible hash function might simply divide the key\nvalue by 100.\nThus, all keys in the range 0 to 99 would hash to slot 0, keys 100 to\n199 would hash to slot 1, and so on.\nIn other words, this hash function \"bins\" the first 100 keys to the\nfirst slot, the next 100 keys to the second slot, and so on.", {"title_reference": "Binning", "#text": "in this way has the problem that it will cluster\ntogether keys if the distribution does not divide evenly on the\nhigh-order bits.\nIn the above example, if more records have keys in the range 900-999\n(first digit 9) than have keys in the range 100-199\n(first digit 1),  more records will hash to slot 9 than to slot 1.\nLikewise, if we pick too big a value for the key range and the actual\nkey values are all relatively small, then most records will hash to\nslot 0.\nA similar, analogous problem arises if we were instead hashing strings based\non the first letter in the string."}, {"title_reference": ["i", "i/X", "X", "X"], "#text": "In general with binning we store the record with key value \nat array position  for some value \n(using integer division).\nA problem with Binning is that we have to know the key range so that\nwe can figure out what value to use for .\nLet's assume that the keys are all in the range 0 to 999.\nThen we want to divide key values by 100 so that the result is in the\nrange 0 to 9.\nThere is no particular limit on the key range that binning could\nhandle, so long as we know the maximum possible value in advance so\nthat we can figure out what to divide the key value by.\nAlternatively, we could also take the result of any binning\ncomputation and then mod by the table size to be safe.\nSo if we have keys that are bigger than 999 when dividing by 100, we\ncan still make sure that the result is in the range 0 to 9 with a mod\nby 10 step at the end."}, "Binning looks at the opposite part of the key value from the mod\nfunction.\nThe mod function, for a power of two, looks at the low-order bits,\nwhile binning looks at the high-order bits.\nOr if you want to think in base 10 instead of base 2, modding by 10 or\n100 looks at the low-order digits, while binning into an array of size\n10 or 100 looks at the high-order digits.", {"title_reference": "Figure #HashNormal", "#text": "As another example, consider hashing a collection of keys whose values\nfollow a normal distribution, as illustrated by\nFigure .\nKeys near the mean of the normal distribution are far more likely\nto occur than keys near the tails of the distribution.\nFor a given slot, think of where the keys come from within the distribution.\nBinning would be taking thick slices out of the distribution and assign\nthose slices to hash table slots.\nIf we use a hash table of size 8, we would divide the key range into 8\nequal-width slices and assign each slice to a slot in the table.\nSince a normal distribution is more likely to generate keys from\nthe middle slice, the middle slot of the table is most likely to be used.\nIn contrast, if we use the mod function, then we are assigning to any given\nslot in the table a series of thin slices in steps of 8.\nIn the normal distribution, some of these slices associated with any given\nslot are near the tails, and some are near the center.\nThus, each table slot is equally likely (roughly) to get a key value."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "hashFuncExCON2", "@long_name": "hashFuncExCON2", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@ids": "hashnormal", "@names": "hashnormal", "@xml:space": "preserve", "odsafig": "null"}], "target": {"@refid": "hashnormal"}}, {"@ids": "the-mid-square-method", "@names": "the\\ mid-square\\ method", "title": "The Mid-Square Method", "paragraph": [{"title_reference": ["mid-square method", "r", "2^{r}-1", "Figure #MidSquareFig", "r = 2"], "#text": "A good hash function to use with integer key values is the\n.\nThe mid-square method squares the key value, and then takes out the middle\n bits of the result, giving a value in the range\n0 to .\nThis works well because most or all bits of the key value contribute to\nthe result.\nFor example, consider records whose keys are 4-digit numbers in base\n10, as shown in Figure .\nThe goal is to hash these key values to a table of size 100\n(i.e., a range of 0 to 99).\nThis range is equivalent to two digits in base 10.\nThat is, .\nIf the input is the number 4567, squaring yields an 8-digit number,\n20857489.\nThe middle two digits of this result are 57.\nAll digits of the original key value\n(equivalently, all bits when the number is viewed in binary)\ncontribute to the middle two digits of the squared value.\nThus, the result is not dominated by the distribution of the bottom\ndigit or the top digit of the original key value.\nOf course, if the key values all tend to be small numbers,\nthen their squares will only affect the low-order digits of the hash value."}, "Here is a little calculator for you to see how this works.\nStart with '4567' as an example."], "target": {"@refid": "midsquarefig"}, "raw": [{"@format": "xml", "@ids": "midsquarefig", "@names": "midsquarefig", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "MidSquare", "@long_name": "MidSquare", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}]}]}, {"@ids": "a-simple-hash-function-for-strings", "@names": "a\\ simple\\ hash\\ function\\ for\\ strings", "title": "A Simple Hash Function for Strings", "paragraph": ["Now we will examine some hash functions suitable for storing strings\nof characters.\nWe start with a simple summation function:", {"title_reference": ["M", "folding method"], "#text": "This function sums the ASCII values of the letters in a string.\nIf the hash table size  is small compared to the\nresulting summations, then this hash function should do a\ngood job of distributing strings evenly among the hash table slots,\nbecause it gives equal weight to all characters in the string.\nThis is an example of the  to designing a hash\nfunction.\nNote that the order of the characters in the string has no effect on\nthe result.\nA similar method for integers would add the digits of the key\nvalue, assuming that there are enough digits to"}, {"title_reference": "M", "literal": "sum", "#text": "As with many other hash functions, the final step is to apply the\nmodulus operator to the result, using table size  to generate\na value within the table range.\nIf the sum is not sufficiently large, then the modulus operator will\nyield a poor distribution.\nFor example, because the ASCII value for 'A' is 65 and 'Z' is 90,\n will always be in the range 650 to 900 for a string of ten\nupper case letters.\nFor a hash table of size 100 or less, a reasonable  distribution\nresults.\nFor a hash table of size 1000, the distribution is terrible because\nonly slots 650 to 900 can possibly be the home slot for some key\nvalue, and the values are not evenly distributed even within those\nslots."}, "Now you can try it out with this calculator."], "literal_block": {"@xml:space": "preserve", "#text": "int sascii(String x, int M) {\n  char ch[];\n  ch = x.toCharArray();\n  int xlength = x.length();\n\n  int i, sum;\n  for (sum=0, i=0; i < x.length(); i++)\n    sum += ch[i];\n  return sum % M;\n}"}, "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "keep any one or two digits with bad distribution from skewing the\nresults of the process and"}, {"paragraph": {"title_reference": "M", "#text": "generate a sum much larger than ."}}]}, "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "StringSimple", "@long_name": "StringSimple", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}}, {"@ids": "string-folding", "@names": "string\\ folding", "title": "String Folding", "paragraph": ["Here is a much better hash function for strings:", {"title_reference": "M-1", "#text": "This function takes a string as input.\nIt processes the string four bytes at a time, and interprets each of\nthe four-byte chunks as a single long integer value.\nThe integer values for the four-byte chunks are added together.\nIn the end, the resulting sum is converted to the range 0 to\n using the modulus operator."}, {"literal": "sfold", "#text": "For example, if the string \"aaaabbbb\" is passed to ,\nthen the first four bytes (\"aaaa\") will be interpreted as the\ninteger value 1,633,771,873,\nand the next four bytes (\"bbbb\") will be\ninterpreted as the integer value 1,650,614,882.\nTheir sum is 3,284,386,755 (when treated as an unsigned integer).\nIf the table size is 101 then the modulus function will cause this key\nto hash to slot 75 in the table."}, "Now you can try it out with this calculator.", "For any sufficiently long string, the sum for the integer\nquantities will typically cause a 32-bit integer to overflow\n(thus losing some of the high-order bits) because the resulting\nvalues are so large.\nBut this causes no problems when the goal is to compute a hash function.", "The reason that hashing by summing the integer representation of four\nletters at a time is superior to summing one letter at a time is because\nthe resulting values being summed have a bigger range.\nThis still only works well for strings long enough\n(say at least 7-12 letters), but the original method would not work\nwell for short strings either.\nThere is nothing special about using four characters at a time.\nOther choices could be made.\nAnother alternative would be to fold two characters at a time."], "literal_block": {"@xml:space": "preserve", "#text": "// Use folding on a string, summed 4 bytes at a time\nlong sfold(String s, int M) {\n  int intLength = s.length() / 4;\n  long sum = 0;\n  for (int j = 0; j < intLength; j++) {\n    char c[] = s.substring(j * 4, (j * 4) + 4).toCharArray();\n    long mult = 1;\n    for (int k = 0; k < c.length; k++) {\n      sum += c[k] * mult;\n      mult *= 256;\n    }\n  }\n\n  char c[] = s.substring(intLength * 4).toCharArray();\n  long mult = 1;\n  for (int k = 0; k < c.length; k++) {\n    sum += c[k] * mult;\n    mult *= 256;\n  }\n\n  return(Math.abs(sum) % M);\n}"}, "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "StringSfold", "@long_name": "StringSfold", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}}, {"@ids": "hash-function-practice", "@names": "hash\\ function\\ practice", "title": "Hash Function Practice", "paragraph": "Now here is an exercise to let you practice these various hash\nfunctions.\nYou should use the calculators above for the more complicated hash\nfunctions.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "HashFuncFIBSumm", "@long_name": "HashFuncFIBSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "hash-function-review-questions", "@names": "hash\\ function\\ review\\ questions", "title": "Hash Function Review Questions", "paragraph": "Here are some review questions.", "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "HashFuncSumm", "@long_name": "HashFuncSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/hashFuncExCON1.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/hashFuncExCON2.js"}]}]}}