{"document": {"@dupnames": "edit\\ distance", "@ids": "edit-distance", "@source": "<string>", "@title": "Edit Distance", "title": "Edit Distance", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@dupnames": "edit\\ distance", "@ids": "id1", "title": "Edit Distance", "paragraph": [{"title_reference": "Edit Distance", "#text": "is an algorithm for computing the minimum number\nof changes from one string to another.  The two non-interesting cases\nare: if both strings are of length zero (or identical), then zero\noperations are needed; and if one string is of zero length, then the\nnumber of operations needed is the length of the non-zero length\nstring."}, "Following the dynamic programming approach, the first step is solve\nthe problem recursively.  Like most recursive solutions, this\nalgorithm is easy to follow.  First, some symbols and their defintions\nto make the description easier to understand.", "The recursive algorithm is as follows:", "* Since each of these recursive calls refer to a specific operation, the op count, or value returned by each recursive call is incremented by 1.", {"emphasis": "ED(S,T,m,n)", "strong": ["1", "0"], "#text": "The initial function call appears as .  Note that for the purposes of this algorithm, standard 0-base array enumeration isn't used; the strings start at character position , not ."}, "Operation Description:", "The following is the Edit Distance algorithm handled recursively in Java.", {"math": "O(3^{max(m,n)})", "#text": "This recursive algorithm handles Edit Distance, but as the string length increases, the call stack increases exponentially.  Why it increases exponentially is due to the fact that at any given character comparision, there might be as many as three recursive calls, so .  The recursive call tree can be seen by the following animation."}, {"emphasis": ["\"cat\"", "\"kate\""], "#text": "Note that for these animations, the starting string is  and the ending string is .  The numbers in each node refer to the recursive function call parameters, in this case the character positions for comparison of the starting and ending strings, respectively.  For simplicity's sake, assume the starting and ending string are globally defined."}, "Obviously, to compare any sizeable strings together, a recursive solution is not optimal.  As was seen by the previous demonstrations of dynamic programming, a dynamic approach to this problem will make things run more efficiently (i.e., in linear time).", "The following animation demonstrates, just as the previous demonstrations of N-Choose-K and 0/1 Knapsack, the process of plucking the recursive call tree to fill in the dynamic grid.", "Note that due to the similarity in approach, the majority of the code that operates this next animation is of an abstracted form that actually runs the second animations of all three dynamic programming problem visualizations.  You've already seen this animation if you've viewed N-Choose-K and the 0/1 Knapsack problems, just with a different algorithm being visualized.  If you don't see the similarity, don't worry.  The point of these three algorithm demonstrations, N-Choose-K, 0/1 Knapsack, and Edit Distance, is to reveal the same abstracted approach to creating dynamic solutions for problems.  Since the second step is virtually identical for all three of these demonstrations, we've created one animation to handle them all.", {"math": ["O(m*n)", "O(3^{max(m,n)})"], "strong": "small", "#text": "As you can see, the efficiency of this dynamic approach is , which is obviously better than the recursive's efficiency of .  In fact, for this particular example, of the original 19 function calls, the dynamic approach eliminated 10 of those calls, a 52.6% saving on efficiency, and this was for a  example!"}, "Once the grid is filled, the last part of the dynamic solution approach is to identify the optimal path to the solution.  The following animation does just that.  Pay attention to the transitional text, as it describes which operation is done at each comparison.  Understanding which positions of the next cells relates to which operation is key.  For simplicity's sake, top-left means substitution, left means insertion, and top means deletion.", "Note that for this animation, there are no deletions.  If the starting string was of greater length than the ending string, then there would be no insertions, but one or more deletions.", "The following is the same Edit Distance algorithm as above, but implemented dynamically.  As you can see, memoization is used to provide the means for a look-up table, storing the repeated function calls.  The initial setup of the grid might be the hardest part to understand.  This code will generate a two-dimensional array of the same type as seen in previous animations' grids, sans the initial row and column used for displaying the strings to be compared.", "One major difference between the recursive Edit Distance and this\nparticular dynamic Edit Distance is the minimum filling of the grid.\nAs was seen above in the second animation, not every cell received a\nvalue.  These missing values were entirely unnecessary for determining\nthe actual Edit Distance between the two strings, and were therefore\nbypassed.  This dynamic implementation, as was seen by the third\nanimation, will actually fill in every cell with its appropriate\nvalue.  Perhaps you can think of a way to only fill in the necessary\ncells using the dynamic method."], "table": {"tgroup": {"@cols": "2", "colspec": [{"@colwidth": "14"}, {"@colwidth": "42"}], "thead": {"row": {"entry": [{"paragraph": "Symbol"}, {"paragraph": "Definition"}]}}, "tbody": {"row": [{"entry": [{"paragraph": "S"}, {"paragraph": "is the starting string"}]}, {"entry": [{"paragraph": "T"}, {"paragraph": "is the ending string"}]}, {"entry": [{"paragraph": "m"}, {"paragraph": "the length of the starting string"}]}, {"entry": [{"paragraph": "n"}, {"paragraph": "the length of the ending string"}]}, {"entry": [{"paragraph": "S(i)"}, {"paragraph": "is the character in S at the ith position"}]}, {"entry": [{"paragraph": "T(j)"}, {"paragraph": "is the character in T at the jth position"}]}, {"entry": [{"paragraph": "ED(S,T,i,j)"}, {"paragraph": "i:[1..m], j:[1..n], the minimum number of\nchanges when comparing S(i) with T(j)"}]}]}}}, "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"emphasis": ["S", "T"], "#text": "Base case check.  The base case for this algorithm is simply when you run out of characters to compare in either  or .  If you run out of characters for both, the number that is returned will be zero.  However if you run out of characters of one but not the other, the value returned is the remaining number of characters in the non-zero length string."}}, {"definition_list": {"definition_list_item": {"term": {"emphasis": "S(i) == T(j)", "#text": "Check to see if ."}, "definition": {"enumerated_list": {"@enumtype": "loweralpha", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"emphasis": "ED(S,T,i-1,j-1)", "#text": "1)  If they match, recurse to .  Since they match, nothing needs to be done at this position, so no operation count is added to this value."}}, {"paragraph": "2)  If they don't match, three recursive calls are necessary.  In order:", "block_quote": {"bullet_list": {"@bullet": "-", "list_item": [{"paragraph": {"emphasis": "ED(S,T,i-1,j-1)", "#text": "A) Substitution: recurse to  and add one*."}}, {"paragraph": {"emphasis": "ED(S,T,i,j-1)", "#text": "B) Insertion:        recurse to  and add one*."}}, {"paragraph": {"emphasis": "ED(S,T,i-1,j)", "#text": "C) Deletion:         recurse to  and add one*."}}, {"paragraph": "D) Choose which operation to take.  Since Edit Distance is a minimum-returning function, simply find the operation that yields the minimum number of changes (operation counts).  If there is a tie, follow the order of precedence established by the ordering of recursive calls:  Substition, Insertion, Deletion."}]}}}]}}}}}]}, "block_quote": {"definition_list": [{"definition_list_item": {"term": "Substitution", "definition": {"paragraph": {"emphasis": "S(i) = T(j)", "#text": "The current character in the starting string becomes the current character in the ending string."}}}}, {"definition_list_item": {"term": "Insertion", "definition": {"paragraph": {"emphasis": "S.insert(i,T(j))", "#text": "The ending string is longer than the starting string, so the current character of the ending string is inserted at the current character of the starting string's position."}}}}, {"definition_list_item": {"term": "Deletion", "definition": {"paragraph": {"emphasis": "S.remove(i)", "#text": "The starting string is longer than the ending string, so the current character of the starting string is removed."}}}}], "paragraph": ["Example:", "Example:", "Example:"], "line_block": [{"line": ["Starting string: sit", "Ending string: sat", "For the second character comparison on both strings, the \"i\" becomes an \"a\", a substitution."]}, {"line": ["Starting string: red", "Ending string: read", "At the second to last character comparison for both strings, an \"a\" is inserted to make the strings match."]}, {"line": ["Starting string: 123456", "Ending string: 13456", "The second character of the starting string \"2\" needs to be deleted for the strings to match."]}]}, "literal_block": [{"@xml:space": "preserve", "#text": "int editDistance(String S, String T, int i, int j)\n{\n        //base cases\n        if (i === 0)\n                return j;\n        if (j === 0)\n                return i;\n\n        //recursive call, start with match check\n        if (S.charAt(i) == T.charAt(j))\n                return editDistance(S, T, i-1, j-1);\n        else\n        {       //no match, recurse three times\n\n                int sub = editDistance(S, T, i-1, j-1) + 1;\n                int ins = editDistance(S, T, i, j-1) + 1;\n                int del = editDistance(S, T, i-1, j) + 1;\n\n                return Math.min(Math.min(sub, ins), del);\n        }\n}"}, {"@xml:space": "preserve", "#text": "int editDistance(String start, String end)\n{\n        int startMax = start.length;\n        int endMax = end.length;\n        int array[][] = new int[startMax + 1][endMax + 1]\n\n        //initialize all array values to zero\n        for (int i = 0; i <= startMax; i++)\n        {\n                for (int j = 0; j <= endMax; j++)\n                {\n                        array[i][j] = 0;\n                }\n        }\n\n        //initialize the base cases\n        for (int i = 1; i <= startMax; i++)\n        {\n                array[i][0] = i;\n        }\n\n        for (int j = 1; j <= endMax; j++)\n        {\n                array[0][j] = j;\n        }\n\n        //fill in the grid\n        for (int i = 1; i <= startMax; i++)\n        {\n                for(int j = 1; j <= endMax; j++)\n                {\n                        //match check\n                        if (start.charAt(i-1) == end.charAt(j-1))\n                                array[i][j] = array[i-1][j-1];\n                        else\n                        {\n                                int sub = array[i-1][j-1] + 1;\n                                int ins = array[i][j-1] + 1;\n                                int del = array[i-1][j] + 1;\n\n                                array[i][j] = Math.min(Math.min(sub, ins), del);\n                        }\n                }\n        }\n\n        return array[startMax][endMax];\n}"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "editRCT", "@long_name": "editRCT", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "editPrune", "@long_name": "editPrune", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "editOptimal", "@long_name": "editOptimal", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}]}, {"@ids": "exercise-1", "@names": "exercise\\ 1", "title": "Exercise 1", "paragraph": "Now that you've seen the algorithms in action, you should hopefully\nunderstand where the grid gets its values.  More than this, you should\nunderstand how the algorithm chooses which operation to do next.  For\nthe following quiz, the key to completing it is understanding\nultimately which operation will be done at any point.  For any given\ncell, identify which operation will yield the lowest total operation\ncount.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "edit-KA1", "@long_name": "edit-KA1", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "exercise-2", "@names": "exercise\\ 2", "title": "Exercise 2", "paragraph": "On this next quiz, identify the correct value that would go in the\nhighlighted cell.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "edit-KA2", "@long_name": "edit-KA2", "@points": "1.0", "@required": "True", "@threshold": "5"}}}]}}