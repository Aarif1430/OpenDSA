{"document": {"@dupnames": "semantics\\ of\\ the\\ lambda\\ calculus", "@ids": "id1 semantics-of-the-lambda-calculus", "@names": "semantics-of-the-lambda-calculus", "@source": "<string>", "@title": "Semantics of the Lambda Calculus", "title": "Semantics of the Lambda Calculus", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "target": {"@refid": "semantics-of-the-lambda-calculus"}, "section": [{"@dupnames": "semantics\\ of\\ the\\ lambda\\ calculus", "@ids": "id2", "title": "Semantics of the Lambda Calculus", "paragraph": ["In the previous section, we covered the entirety of the syntax of the\nlambda calculus. The rest of this chapter, including this section,\ndeals with the semantics of the lambda calculus, that is, the meaning\nof lambda expressions, or in other words, how they are interpreted and what\ntheir value is. Clearly, the expressive power of the lambda calculus\nis outstanding: its tiny syntax will allow us to express a rich set of\ncomputations, in fact, all possible computations (for more on this,\nlook up the Church-Turing thesis).", "Note that all programs in the lambda calculus are expressions, that\nis, programs that get evaluated for their value. The lambda calculus\ndoes not contain any statements, that is, commands that get executed\nfor their side effects, for example, modifying the contents of memory\nvia assignment statements or sending a string to the standard output\nstream via print statements. Therefore, the lambda calculus is a\npurely functional language.", "Now, we will explain the meaning of the three types of lambda\nexpressions whose syntax is given in the lambda calculus grammar.\nFor each type of lambda expressions, we will\ndescribe its meaning using both an English statement and a JavaScript\ncode fragment."], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": [{"emphasis": "variable", "math": ["x", "p_1"], "literal": [{"@classes": "code", "#text": "x"}, {"@classes": "code", "#text": "p1"}], "#text": "A  in the lambda calculus (the first production in the\nLambda Calculus grammar) is a placeholder for another lambda\nexpression. In other words, like in all programming languages, a\nvariable can be used to refer to some value that may or may not be\nknown yet. So variables  and  in the lambda\ncalculus can be represented by the variables  and\n, respectively, in JavaScript."}, "The main difference between lambda calculus and JavaScript is\nthat, in the lambda calculus, each variable can only get bound to\none value during the execution of the whole program, whereas, in\nJavaScript, the value of a variable can be changed multiple times\nduring execution using assignment statements. In conclusion,\nvariables in the lambda calculus are more like named constants\nthan variables in imperative programming languages. Furthermore,\nin the lambda calculus, since the only values are functions, all\nvariables are placeholders for function values."], "table": {"@classes": "colwidths-given", "tgroup": {"@cols": "4", "colspec": [{"@colwidth": "1"}, {"@colwidth": "2"}, {"@colwidth": "10"}, {"@colwidth": "7"}], "thead": {"row": {"entry": [{"paragraph": "Example"}, {"paragraph": {"math": "\\lambda", "#text": "Expression"}}, {"paragraph": "English Statement of the Semantics"}, {"paragraph": "JavaScript Implementation"}]}}, "tbody": {"row": {"entry": [{"paragraph": "1"}, {"paragraph": {"math": "x"}}, {"paragraph": {"math": "x", "#text": "the variable named"}}, {"literal_block": {"@classes": "code javascript", "@xml:space": "preserve", "inline": {"@classes": "name other", "#text": "x"}}}]}}}}}, {"paragraph": [{"title_reference": "lambda abstraction", "emphasis": "not", "math": "\\lambda", "#text": "A  in the lambda calculus (the second\nproduction in the grammar) is a function definition, that is, an\nexpression that defines a function,  a function call. Since\nall functions of the lambda calculus are anonymous and only take\none parameter, all we need to define a function is the name of its\nparameter (that is, the variable following the  in\nthe second production in the grammar) and its body (a lambda\nexpression)."}, {"emphasis": "curried", "math": ["x", "y"], "#text": "Note that example 7 above is the  function of two\narguments, namely  and , that returns its second\nargument."}], "table": {"@classes": "colwidths-given", "tgroup": {"@cols": "4", "colspec": [{"@colwidth": "1"}, {"@colwidth": "2"}, {"@colwidth": "10"}, {"@colwidth": "7"}], "thead": {"row": {"entry": [{"paragraph": "Example"}, {"paragraph": {"math": "\\lambda", "#text": "Expression"}}, {"paragraph": "English Statement of the Semantics"}, {"paragraph": "JavaScript Implementation"}]}}, "tbody": {"row": [{"entry": [{"paragraph": "2"}, {"paragraph": {"math": "\\lambda x.x"}}, {"paragraph": {"math": ["x", "x"], "#text": "the function of  that returns  (i.e., the identity function)"}}, {"literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "function (x) { return x; }"}}]}, {"entry": [{"paragraph": "3"}, {"paragraph": {"math": "\\lambda y.y"}}, {"paragraph": {"math": ["y", "y"], "#text": "the function of  that returns  (i.e., the identity function)"}}, {"literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "function (y) { return y; }"}}]}, {"entry": [{"paragraph": "4"}, {"paragraph": {"math": "\\lambda x.y"}}, {"paragraph": {"math": ["x", "y"], "#text": "the constant function (of ) that returns"}}, {"literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "function (x) { return y; }"}}]}, {"entry": [{"paragraph": "5"}, {"paragraph": {"math": "\\lambda z.y"}}, {"paragraph": "the same function as above"}, {"literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "function (z) { return y; }"}}]}, {"entry": [{"paragraph": "6"}, {"paragraph": {"math": "\\lambda y.x"}}, {"paragraph": {"math": ["y", "x"], "#text": "the constant function (of ) that returns"}}, {"literal_block": {"@classes": "code javascript", "@xml:space": "preserve", "inline": [{"@classes": "keyword declaration", "#text": "function"}, {"@classes": "punctuation", "#text": "("}, {"@classes": "name other", "#text": "y"}, {"@classes": "punctuation", "#text": ")"}, {"@classes": "punctuation", "#text": "{"}, {"@classes": "keyword", "#text": "return"}, {"@classes": "name other", "#text": "x"}, {"@classes": "punctuation", "#text": ";"}, {"@classes": "punctuation", "#text": "}"}]}}]}, {"entry": [{"paragraph": "7"}, {"paragraph": {"math": "\\lambda x.\\lambda y.y"}}, {"paragraph": {"math": ["x", "y", "y", "x"], "#text": "the function of  that returns the function of  that\nreturns  (in other words, the function of  that\nreturns the identity function)"}}, {"literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "function (x) {\n       return function (y) { return y; };\n}"}}]}]}}}}, {"paragraph": {"emphasis": "function application", "title_reference": "IIFE (Immediately\ninviked Function Expression)", "#text": "A  in the lambda calculus (the third\nproduction in the grammar) is a function call, that is, an\nexpression that invokes a function on a single argument. The first\ncomponent in a function application is either a variable (see\nexample 8 below) or a more complex lambda expression that will\neventually evaluate to a function. In examples 9 and 10 below, the\nfirst component of the function application is a lambda\nabstraction, that is, a function that is being defined and called\nright away. In JavaScript, this type of function application is a\ncommon idiom sometimes referred to as an ."}, "table": {"@classes": "colwidths-given", "tgroup": {"@cols": "4", "colspec": [{"@colwidth": "1"}, {"@colwidth": "2"}, {"@colwidth": "10"}, {"@colwidth": "7"}], "thead": {"row": {"entry": [{"paragraph": "Example"}, {"paragraph": {"math": "\\lambda", "#text": "Expression"}}, {"paragraph": "English Statement of the Semantics"}, {"paragraph": "JavaScript Implementation"}]}}, "tbody": {"row": [{"entry": [{"paragraph": "8"}, {"paragraph": {"math": "(x\\ y)"}}, {"paragraph": {"math": ["x", "y"], "#text": "the invocation of function  on argument"}}, {"literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "x(y)"}}]}, {"entry": [{"paragraph": "9"}, {"paragraph": {"math": "(\\lambda x.x\\ y)"}}, {"paragraph": {"math": "y", "#text": "the identity function applied to"}}, {"literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "(function (x) { return x; })(y)"}}]}, {"entry": [{"paragraph": "10"}, {"paragraph": {"math": "(\\lambda z.x\\ y)"}}, {"paragraph": {"math": ["x", "y"], "#text": "the constant function  applied to"}}, {"literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "(function (z) { return x; })(y)"}}]}, {"entry": [{"paragraph": "11"}, {"paragraph": {"math": "\\lambda x.(x\\ y)"}}, {"paragraph": {"math": ["x", "x", "y"], "#text": "the function of  that returns the value returned when \nis called on"}}, {"literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "function (x) { return x(y); }"}}]}, {"entry": [{"paragraph": "12"}, {"paragraph": {"math": "(\\lambda x.\\lambda y.y\\ z)"}}, {"paragraph": {"math": "z", "#text": "the function from example 7 above applied to\n. Since the curried function of two parameters is\nbeing called with a single argument, the evaluation of this\napplication will return the identity function."}}, {"literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "(function (x) {\n    return function (y) { return y; };\n })(z)"}}]}, {"entry": [{"paragraph": "13"}, {"paragraph": {"math": "( (\\lambda x.\\lambda y.y\\ u)\\ v)"}}, {"paragraph": {"math": ["u", "v", "v"], "#text": "the function from example 7 above applied to  and\n. Since the curried function of two parameters is\nbeing called with two arguments, the evaluation of this\napplication will return the value of the second argument,\nnamely ."}}, {"literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "(function (x) {\n    return function (y) { return y; };\n })(u)(v)"}}]}]}}}}]}, "block_quote": {"paragraph": "Note that, in example 11 above, the top-level expression is a\nlambda abstraction whose body is a function application."}}, {"@ids": "rp-14-part-3", "@names": "rp\\ 14\\ part\\ 3", "title": "RP 14 part 3", "paragraph": "This problem is about the semantic equivalence between lambda\nexpressions and JavaScript expressions.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP14part3", "@long_name": "RP14part3", "@points": "1.0", "@required": "True", "@threshold": "5"}}}]}}