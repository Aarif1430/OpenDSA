<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="sequential-fit\ methods" ids="sequential-fit-methods" source="&lt;string&gt;" title="Sequential-Fit Methods"><title>Sequential-Fit Methods</title><subtitle dupnames="sequential-fit\ methods" ids="id1">Sequential-Fit Methods</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/MemManage/seqFitCON.css</odsalink></raw><paragraph>Sequential-fit methods attempt to find a "good" block to service
a storage request.
The three sequential-fit methods described here assume that the free
blocks are organized into a doubly linked list, as illustrated by
this figure.</paragraph><target refid="freeblck"></target><raw format="xml" ids="freeblck" names="freeblck" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="seqFitCON"
    long_name="seqFitCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>There are two basic approaches to implementing the freelist.
The simpler approach is to store the freelist separately from the
memory pool.
In other words, a simple linked-list implementation
can be used, where each node of the linked list
contains a pointer to a single free block in the memory pool.
This is fine if there is space available for the linked list itself,
separate from the memory pool.</paragraph><paragraph>The second approach to storing the freelist is more complicated but
saves space.
Because the free space is free, it can be used by the memory manager to
help it do its job; that is, the memory manager temporarily
"borrows" space within the free blocks to maintain its doubly
linked list.
To do so, each unallocated block must be large enough to hold these
pointers.
In addition, it is usually worthwhile to let the memory manager add a
few bytes of space to each reserved block for its own purposes.
In other words, a request for <title_reference>m</title_reference> bytes of space might result in
slightly more than <title_reference>m</title_reference> bytes being allocated by the memory
manager, with the extra bytes used by the memory manager itself rather
than the requester.
We will assume that all memory blocks are organized as shown in
the figure below, with space for tags and linked list pointers.
Here, free and reserved blocks are distinguished by a tag bit at both
the beginning and the end of the block, for reasons that will be
explained.
In addition, both free and reserved blocks have a size indicator
immediately after the tag bit at the beginning of the block to
indicate how large the block is.
Free blocks have a second size indicator immediately preceding the tag
bit at the end of the block.
Finally, free blocks have left and right pointers to their neighbors
in the free block list.</paragraph><target refid="memtags"></target><raw format="xml" ids="memtags" names="memtags" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>The information fields associated with each block permit the memory
manager to allocate and deallocate blocks as needed.
When a request comes in for <title_reference>m</title_reference> words of storage, the memory
manager searches the linked list of free blocks until it finds a
"suitable" block for allocation.
How it determines which block is suitable will be discussed below.
If the block contains exactly <title_reference>m</title_reference> words (plus space for the tag
and size fields), then it is removed from the freelist.
If the block (of size <title_reference>k</title_reference>) is large enough,
then the remaining <title_reference>k - m</title_reference> words are reserved as a block on the
freelist, in the current location.</paragraph><paragraph>When a block <title_reference>F</title_reference> is freed, it must be merged into the freelist.
If we do not care about merging adjacent free blocks, then this
is a simple insertion into the doubly linked list of free blocks.
However, we would like to merge adjacent blocks, because
this allows the memory manager to serve requests of the largest
possible size.
Merging is easily done due to the tag and size fields stored at the
ends of each block, as illustrated by the figure below.
Here, the memory manager first checks the unit of memory immediately
preceding block <title_reference>F</title_reference> to see if the preceding block (call
it <title_reference>P</title_reference>) is also free.
If it is, then the memory unit before <title_reference>P</title_reference> 's tag bit stores
the size of <title_reference>P</title_reference>, thus indicating the position for the beginning
of the block in memory.
<title_reference>P</title_reference> can then simply have its size extended to include
block <title_reference>F</title_reference>.
If block <title_reference>P</title_reference> is not free, then we just add block <title_reference>F</title_reference> to
the freelist.
Finally, we also check the bit following the end of block <title_reference>F</title_reference>.
If this bit indicates that the following block (call it <title_reference>S</title_reference>) is
free, then <title_reference>S</title_reference> is removed from the freelist and the size
of <title_reference>F</title_reference> is extended appropriately.</paragraph><target refid="memex"></target><raw format="xml" ids="memex" names="memex" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>We now consider how a "suitable" free block is selected to service a
memory request.
To illustrate the process, assume that we have a memory pool with 200
units of storage. After some series of allocation requests and releases,
we have reached a point where there are four free blocks
on the freelist of sizes 25, 35, 32, and 45 (in that order).
Assume that a request is made for 30 units of storage.
For our examples, we ignore the overhead imposed for the tag, link,
and size fields discussed above.</paragraph><raw format="xml" xml:space="preserve"><odsascript>AV/MemManage/seqFitCON.js</odsascript></raw></document>