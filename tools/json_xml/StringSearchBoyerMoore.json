{"document": {"@ids": "boyer-moore-string-search-algorithm", "@names": "boyer-moore\\ string\\ search\\ algorithm", "@source": "<string>", "@title": "Boyer-Moore String Search Algorithm", "title": "Boyer-Moore String Search Algorithm", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}, {"@xml:space": "preserve", "#text": "could then be used in a"}, {"@xml:space": "preserve", "#text": "fashion similar to the :math:`align` array in the KMP algorithm. (The"}, {"@xml:space": "preserve", "#text": "full\u2011blown version of the Boyer\u2011Moore algorithm actually takes into"}, {"@xml:space": "preserve", "#text": "account possible realignments when the mismatched character does not"}, {"@xml:space": "preserve", "#text": "occur at the rightmost position of :math:`sub`. We omit the details of such a"}, {"@xml:space": "preserve", "#text": "refinement here.  The interested reader should consult \u201cA fast"}, {"@xml:space": "preserve", "#text": "string-searching algorithm\u201d by Robert S. Boyer and J. Strother Moore"}, {"@xml:space": "preserve", "#text": "in Communications of the ACM, 20(10):762-772, 1977.)"}, {"@xml:space": "preserve", "#text": "Slideshow for Boyer-Moore search algorithm"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "Boyer_Moore_Algorithm_Slideshow", "@long_name": "Boyer_Moore_Algorithm_Slideshow", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "Boyer_Moore_MMC_Slideshow", "@long_name": "Boyer_Moore_MMC_Slideshow", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "Boyer_Moore_Align_Table_Slideshow", "@long_name": "Boyer_Moore_Align_Table_Slideshow", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "Boyer_Moore_Next_Step_Exercise", "@long_name": "Boyer_Moore_Next_Step_Exercise", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "Boyer_Moore_MMC_Exercise", "@long_name": "Boyer_Moore_MMC_Exercise", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "Boyer_Moore_Alignment_Exercise", "@long_name": "Boyer_Moore_Alignment_Exercise", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "Boyer_Moore_EX_PRO", "@long_name": "Boyer_Moore_EX_PRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}], "paragraph": [{"math": ["sub", "sub", "master", "sub", "master", "sub", "master", "master", "sub", "sub", "sub", "sub", "master", "sub", "i", "sub", "sub", "i", "sub", "master", "sub", "master", "sub", "sub", "master", "MMC"], "#text": "Like the KMP algorithm, a string search algorithm developed by Boyer\nand Moore in 1977 initially examines the structure of the string \nto see if it can be realigned a considerable distance to the right,\nwhen a mismatch occurs.  Unlike the KMP algorithm, the Boyer\u2011Moore\nalgorithm compares the characters of the string  to that of the\n string in a right\u2011to\u2011left fashion.  The hope is that\nthis will allow realignments of considerable magnitude when a mismatch\noccurs early in the comparison of  against a portion of\n.  For instance, suppose that, at the beginning of a\nright\u2011to\u2011left scan of  aligned against a portion of\n, we find the character \"L\" in  and some\nother non-matching character in the rightmost index of\n. Then, if \"L\" does not occur anywhere else in ,\n may be realigned so that the character in index 0 of\n aligns with the character immediately to the right of \u201cL\u201d\nin . (Why?)  Analogously, if the first \"L\" to the left\nof the final position in  occurs at index  of\n, then  may be realigned so that index \nin  is aligned with the \u201cL\u201d in . (Why?) Thus,\nwhen a mismatch occurs at the rightmost (that is, the first examined)\nposition of , the character in  that caused\nthe mismatch can be used to tell us how much  can be\nrealigned to the right. A pre-processing pass through  could\nbe used to determine the amount of realignment for any possible\ncharacter that could occur in . This information is\ncalled the \"mismatched character heuristic\" and is stored in an array\nthat we will identify by the name ."}, {"math": "align", "#text": "To supplement this mismatched character heuristic, the Boyer-Moore\nalgorithm uses another  array that contains re-alignment\ninformation defined as follows."}, {"math": ["suffix\\_length", "p + 1", "offset", "sub", "p", "align", "align", "align", "align"], "#text": "where  is the length of the suffix of the string\nbeginning at position  and  is the least\namount this suffix must be moved to the left to match another\noccurrence of itself in  without matching the character in\nposition in .  This motion to the left may involve the\nleftmost characters \"sliding off the end of the master string\".  When\nthis occurs, those characters that have slid off the end of the master\nstring are viewed as matching the non-existent characters to which\nthey would be compared.  The computation of the  array\ncan be tricky.  It somewhat resembles the computation of the KMP\n array but is done \"in reverse\" because of the\nright-to-left scan done by Boyer-Moore.  We will further study the\ncomputation of the  array later in this module.  However,\nlet us first watch a slideshow of the entire Boyer-Moore algorithm,\nunder the assumption that both the mismatched character heuristic and\nthis \"reverse KMP\"  array have been computed."}, "Now that you've seen how the Boyer-Moore algorithm works once the\nmismatched character and reverse KMP alignments have been\npre-computed, use the next two slideshows to study in more detail how\nthe pre-computation of these two alignment tables would be done.", "Slideshow for Boyer-Moore Mismatched Character Table Construction", "Slideshow for Boyer-Moore \"Reverse KMP\" Alignment Table Construction", "We've seen from the above slideshows that there are really three algorithms at play in Boyer-Moore:", "The main algorithm using two pre-computed re-alignment tables::", "The algorithm to compute the mismatched character table::", "And the algorithm to compute the reverse-KMP alignment table::", "Keeping in mind the pseudocode for these algorithms, test yourself on\nBoyer-Moore by completing the following four exercises."], "math_block": {"@xml:space": "preserve", "#text": "align[p] = \\left\\{ \\begin{array}{ll} 1 \\; \\mbox{if} \\; p = length(sub) - 1 \\mbox{ ,that is, if the last character} \\\\ suffix\\_length + offset \\mbox{  otherwise} \\end{array} \\right."}, "literal_block": [{"@xml:space": "preserve", "#text": "m = Sub.length - 1\nwhile m < Master.length:\n  s = Sub.length - 1\n  while s >= 0 and Master[m] = Sub[s]: m = m-1, s = s-1\n  if s < 0: return m+1\n  else: m = m + larger_of(MMC[master[m]], Align[s])\nreturn -1"}, {"@xml:space": "preserve", "#text": "p = current character in alphabet\nif alphabet[p] doesn't exist in string then: MMC[p] = string.length\nelse: MMC[p] = distance from right end of string to furthest right occurrence of alphabet[p] in string."}, {"@xml:space": "preserve", "#text": "p = current_index\nsuffix_length = length of the suffix of string beginning at p+1\noffset = least amount that the suffix must be moved left to match another occurrence of itself\n                    that isn't preceded by the same character that is at string[p]\nif p = string.length()-1 then:\n  align[p] = 1\nelse\n  align[p] = suffix_length + offset"}], "enumerated_list": [{"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": {"paragraph": "Exercise in tracing one step of the Boyer-Moore algorithm"}}, {"@enumtype": "arabic", "@prefix": "", "@start": "2", "@suffix": ".", "list_item": {"paragraph": "Exercise in tracing one step of the Boyer-Moore Mismatched Character Table Construction"}}, {"@enumtype": "arabic", "@prefix": "", "@start": "3", "@suffix": ".", "list_item": {"paragraph": "Exercise in tracing one step of the Boyer-Moore Alignment Table Construction"}}, {"@enumtype": "arabic", "@prefix": "", "@start": "4", "@suffix": ".", "list_item": {"paragraph": "Proficiency Exercise in tracing entire Boyer-Moore algorithm"}}]}}