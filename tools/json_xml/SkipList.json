{"document": {"@ids": "skip-lists", "@names": "skip\\ lists", "@source": "<string>", "@title": "Skip Lists", "title": "Skip Lists", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "DataStructures/SkipList.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/SearchStruct/SkipListIntroCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/SearchStruct/SkipListInsertCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/SearchStruct/SkipListRmvCON.css"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "SkipListIntroCON", "@long_name": "SkipListIntroCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "SkipListInsertCON", "@long_name": "SkipListInsertCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "SkipListRmvCON", "@long_name": "SkipListRmvCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "DataStructures/SkipList.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/SearchStruct/SkipListIntroCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/SearchStruct/SkipListInsertCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/SearchStruct/SkipListRmvCON.js"}], "paragraph": [{"title_reference": ["Skip List", "BST", "probabilistic data structure"], "#text": "This section presents a probabilistic search structure called the\n.\nLike the , Skip Lists are designed to overcome a basic\nlimitation of array-based and linked lists:\nEither search or update operations require linear\ntime.\nThe Skip List is an example of a\n, because it makes some of its\ndecisions at random."}, {"title_reference": ["2-3 Tree", "AVL tree", "splay tree"], "math": "\\Theta(\\log n)", "#text": "Skip Lists provide an alternative to the BST and related tree\nstructures.\nThe primary problem with the BST is that it may easily become\nunbalanced.\nThe  is guaranteed to remain balanced regardless of\nthe order in which data values are inserted, but it is rather\ncomplicated to implement.\nThe  and the  are also guaranteed to\nprovide good performance, but at the cost of added complexity as\ncompared to the BST.\nThe Skip List is easier to implement than known balanced tree\nstructures.\nThe Skip List is not guaranteed to provide good performance\n(where good performance is defined as\n search, insertion, and deletion time), but it\nwill provide good performance with extremely high probability\n(unlike the BST which has a good chance of performing poorly).\nAs such it represents a good compromise between difficulty of\nimplementation and performance."}, {"math": ["\\log n", "n", "\\Theta(\\log n)"], "#text": "We can continue adding pointers to selected nodes in this waygive\na third pointer to every fourth node, give a fourth pointer to every\neighth node, and so on   until we reach the\nultimate of  pointers in the first and middle nodes for\na list of  nodes.\nTo search, start with the bottom row of pointers, going as far as\npossible and skipping many nodes at a time.\nThen, shift up to shorter and shorter steps as required.\nWith this arrangement, the worst-case number of accesses is\n."}, {"literal": ["forward", "forward[0]", "forward[1]", "level", "head", "level", "find"], "#text": "We will store with each Skip List node an array\nnamed  that stores the pointers.\nPosition  stores a level 0 pointer,\n stores a level 1 pointer, and so on.\nThe Skip List object includes data member  that\nstores the highest level for any node currently in the Skip List.\nThe Skip List stores a header node named  with\n pointers.\nThe  function is shown next along a visualization."}, "The ideal Skip List is organized so that (if the first and last nodes\nare not counted) half of the nodes have only one pointer, one quarter\nhave two, one eighth have three, and so on.\nThe distances are equally spaced; in effect this is a\n\"perfectly balanced\" Skip List.\nMaintaining such balance would be expensive during the normal process\nof insertions and deletions.\nThe key to Skip Lists is that we do not worry about any of this.\nWhenever inserting a node, we assign it a level\n(i.e., some number of pointers).\nThe assignment is random, using a geometric distribution yielding\na 50% probability that the node will have one pointer, a 25%\nprobability that it will have two, and so on.\nThe following function determines the level based on such a\ndistribution:", {"literal": "update", "#text": "Once the proper level for the node has been determined, the next\nstep is to find where the node should be inserted and link it in as\nappropriate at all of its levels.\nHere is an implementation for inserting a new\nvalue into the Skip List.\nNote that we build an  array as we progress through the Skip\nList, so that we can update the pointers for the nodes that will\npreceed the one being inserted."}, {"literal": ["remove", "update"], "#text": "The  function is similar to insertion in that the \narray is built as part of searching for the record to be deleted.\nThen those nodes specified by the update array have their forward\npointers adjusted to point around the node being deleted."}, {"literal": ["randomLevel", "randomLevel"], "math": ["\\Theta(n)", "\\Theta(n)", "\\Theta(\\log n)"], "#text": "A newly inserted node could have a high level generated by\n, or a low level.\nIt is possible that many nodes in the Skip List could have many\npointers, leading to unnecessary insert cost and yielding poor\n(i.e.,  performance during search, because not many\nnodes will be skipped.\nConversely, too many nodes could have a low level.\nIn the worst case, all nodes could be at level 0, equivalent to a\nregular linked list.\nIf so, search will again require  time.\nHowever, the probability that performance will be poor is quite low.\nThere is only one chance in 1024 that ten nodes in a row will be at\nlevel 0.\nThe motto of probabilistic data structures such as the Skip List is\n\"Don't worry, be happy\".\nWe simply accept the results of  and expect that\nprobability will eventually work in our favor.\nThe advantage of this approach is that the algorithms are simple,\nwhile requiring only  time for all operations in\nthe average case."}, {"math": ["n", "n-1"], "#text": "In practice, the Skip List will probably have better\nperformance than a BST.\nThe BST can have bad performance caused by the order in which data are\ninserted.\nFor example, if  nodes are inserted into a BST in ascending\norder of their key values, then the BST will look like a linked list\nwith the deepest node at depth .\nIf the data inserted over the life of the BST could be randomly\nordered, then the probability distribution for the cost of the insert\nand search operations would be similar to that of the Skip List.\nThe problem for the BST is that this randomization does not happen in\nfact, but rather the BST is constrained by the actual order of inputs\nand searches."}, {"math": ["\\Theta(n)", "\\Theta(\\log n)"], "#text": "In contrast, the Skip List's performance does not depend on the order\nin which values are inserted into the list.\nIn a sense, the data are \"randomization\" automatically as part of the\nSkip List probabilistic behavior as the depths of the nodes are being\nselected.\nAs the number of nodes in the Skip List increases, the probability of\nencountering the worst case decreases geometrically.\nThus, the Skip List illustrates a tension between the theoretical\nworst case (in this case,  for a Skip List\noperation), and a rapidly increasing probability of average-case\nperformance of , that characterizes\nprobabilistic data structures."}]}}