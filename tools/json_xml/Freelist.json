{"document": {"@dupnames": "freelists", "@ids": "freelists", "@source": "<string>", "@title": "Freelists", "title": "Freelists", "subtitle": {"@dupnames": "freelists", "@ids": "id1", "#text": "Freelists"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/List/listFreeCON.css"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "listFreeCON", "@long_name": "listFreeCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/List/llist.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/List/listFreeCON.js"}], "paragraph": [{"literal": "new", "title_reference": ["memory manager <memory manager> <Memory Management>", "free store"], "#text": "The  operator is relatively expensive to use.\nGarbage collection is also expensive.\nA \nhandles general-purpose memory requests.\nThe expense comes from the fact that  routines must\nbe capable of handling requests to and from free store with no\nparticular pattern, as well as memory requests of vastly different\nsizes.\nThis, combined with unpredictable freeing of space by the garbage\ncollector, makes them inefficient compared to what might be\nimplemented for more controlled patterns of memory access."}, {"title_reference": ["linked list", "freelist", "linked stack <linked stack> <StackLinked>"], "literal": ["Link", "new", "Link", "new"], "#text": "List nodes are created and deleted in a \nimplementation in a way that allows the  class programmer\nto provide simple but efficient memory management routines.\nInstead of making repeated calls to ,\nthe  class can handle its own .\nA freelist holds those list nodes that are not currently being used.\nWhen a node is deleted from a linked list, it is placed at the\nhead of the freelist.\nWhen a new element is to be added to a linked list, the freelist\nis checked to see if a list node is available.\nIf so, the node is taken from the freelist.\nIf the freelist is empty, the standard  operator must then\nbe called.\nSo we see that the freelist is simply\nan application of a ."}, "Freelists are particularly useful for linked lists that periodically\ngrow and then shrink.\nThe freelist will never grow larger than the largest size yet reached\nby the linked list.\nRequests for new nodes (after the list has shrunk) can be handled by\nthe freelist.\nAnother good opportunity to use a freelist occurs when a program uses\nmultiple lists.\nSo long as they do not all grow and shrink together, the free list can\nlet link nodes move between the lists.", {"literal": ["Link", "get", "release"], "#text": "In the implementation shown here, the  class is augmented with\nmethods  and ."}, {"literal": ["freelist", "static", "Link", "Link"], "#text": "The  variable declaration uses the keyword .\nThis creates a single variable shared among all instances of the\n nodes.\nIn this way, a single freelist is shared by all  nodes."}, {"literal": ["get", "release", "new"], "title_reference": "Theta(1)", "#text": "Note how simple they are, because they need only remove and add an\nelement to the front of the freelist, respectively.\nThe freelist methods  and  both run in\n time, except in the case where the freelist is\nexhausted and the  operation must be called.\nHere are the necessary modifications to members of the linked list\nclass to make use of the freelist version of the link class."}, {"literal": ["new", "delete", "new", "new"], "#text": "How much time is saved by using freelists depends on the language that\nyou are programming in.\nIn a language like C++ where the programmer must call  and\n to manage memory, getting a node from your own freelist\nrequires less than one tenth of the time required by the \noperator.\nIn a language like Java that uses garbage collection, it might at\nfirst appear that using your own freelist saves no time, because\nJava's  operator can quickly return space from the current\nstart of its memory pool.\nHowever, when you do not use a freelist, dropping access to nodes\ncreates garbage which leads to expensive processing at garbage\ncollection time."}], "footnote": {"@auto": "1", "@ids": "id2", "@names": "1", "label": "1", "paragraph": {"literal": ["new", "delete"], "#text": "A language like C++ could use operator overloading to redefine\nthe  and  operators."}}}}