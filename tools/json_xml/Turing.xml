<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="turing-machines" names="turing\ machines" source="&lt;string&gt;" title="Turing Machines"><title>Turing Machines</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/SeniorAlgAnal/Turing1CON.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/SeniorAlgAnal/Turing2CON.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/SeniorAlgAnal/Turing3CON.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/SeniorAlgAnal/TuringCopyCON.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/SeniorAlgAnal/TuringShiftCON.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/SeniorAlgAnal/TuringExt1CON.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/SeniorAlgAnal/TuringExt2CON.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/SeniorAlgAnal/TuringExt3CON.css</odsalink></raw><section ids="a-general-model-of-computation" names="a\ general\ model\ of\ computation"><title>A General Model of Computation</title><paragraph>We would like to define a general model of computation that is as
simple as possible.
The reason is that we want to be able to understand the limits of what
is possible in computing, but that is rather hard to do with a
complicated definition for a "computer" is.
But then, we need to be confident that whatever model we do pick, that
it actually represents all of the fundamental capabilities of a
"computer".</paragraph><paragraph>"State machines" are simple to understand.
There are a number of different state machines, with a range of
capabilities.
We will discuss a particular one, called a <title_reference>Turing machine</title_reference>.
As we define "capability", the key is <emphasis>ability</emphasis>, not <emphasis>efficiency</emphasis>.</paragraph><paragraph>The necessary capabilites for any such "machine" are these:</paragraph><bullet_list bullet="*"><list_item><paragraph>Read</paragraph></list_item><list_item><paragraph>Write</paragraph></list_item><list_item><paragraph>Compute</paragraph></list_item></bullet_list><paragraph>A Turing machine is defined as follows.
It has a tape, divided into squares, with a fixed left end and
extending infinitely to the right.
Each square can store one character.
The machine has a single I/O head that at any instant in time is "on"
one of the squares.
The control unit of the machine is defined by a set of abstract
<title_reference>states</title_reference>.
At any given instant, the machine is said to be
"in" one of the states, and has a set of actions that can be performed
when in that state.
From the current state, the machine will read the symbol on the
current state, and can then do one of the following:</paragraph><bullet_list bullet="*"><list_item><paragraph>Change the current symbol.</paragraph></list_item><list_item><paragraph>Move the I/O head one square to either the left or the right.</paragraph></list_item></bullet_list><paragraph>By convention, the machine ceases to perate if the head moves off the
left end of the tape, or if the control unit sends the machine into a
specially designated <title_reference>halt state</title_reference>.</paragraph><paragraph>The input to the machine is the intial contents of the tape, which is
described by listing all of the tape squares from the left to the
rightmost non-blank tape.
Naturally, there must be a finite number of non-blank symbols on the
tape.
The <title_reference>alphabet</title_reference> of the machine consists of some letters,
including the special symbol <math>\#</math> which means a blank symbol on the
given square.</paragraph><paragraph>A Turing machine is formally defined as a quadruple
(<math>K</math>, <math>\Sigma</math>, $delta$, $s$) where</paragraph><bullet_list bullet="*"><list_item><paragraph><math>K</math> is a finite set of states (not including <math>h</math>, the
halt state).</paragraph></list_item><list_item><paragraph><math>\Sigma</math> is an alphabet (containing <math>\#</math>, not <math>L</math>
or <math>R</math>).</paragraph></list_item><list_item><paragraph><math>s \in K</math> is the :term`initial state`.</paragraph></list_item><list_item><paragraph><math>\delta</math> is a function from <math>K \times \Sigma</math> to
<math>(K \cup \{h\}) \times (\Sigma \cup \{L, R\})</math>.</paragraph></list_item></bullet_list><paragraph>Note that including <math>\#</math> in the language is for convenience
only.
We want to be able to read our specifications without being confused.</paragraph><paragraph>If <math>q \in K</math>, <math>a \in \Sigma</math> and
<math>\delta(q, a) = (p, b)</math>,
then when in state <math>q</math> and scanning <math>a</math>,
enter state <math>p</math> and</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>If <math>b \in \Sigma</math> then replace <math>a</math> with <math>b</math>.</paragraph></list_item><list_item><paragraph>Else (<math>b</math> is <math>L</math> or <math>R</math>): move head.</paragraph></list_item></enumerated_list><topic><title>Example</title><paragraph><math>M = (K, \Sigma, \delta, s)</math> where</paragraph><bullet_list bullet="*"><list_item><paragraph><math>K = \{q_0, q_1\}</math>,</paragraph></list_item><list_item><paragraph><math>\Sigma = \{a, \#\}</math>,</paragraph></list_item><list_item><paragraph><math>s = q_0</math></paragraph></list_item><list_item><paragraph><math>\delta =</math></paragraph><math_block xml:space="preserve">\begin{array}{lll}
\hline
q&amp;\sigma&amp;\delta(q, \sigma)\\
\hline
q_0&amp;a&amp;(q_1, \#)\\
q_0&amp;\#&amp;(h, \#)\\
q_1&amp;a&amp;(q_0, a)\\
q_1&amp;\#&amp;(q_0, R)\\
\end{array}</math_block></list_item></bullet_list><paragraph>Note that state <math>(q_1, a)</math> cannot happen if the start state
is <math>q_0</math>.
This is included only for completness (to make <math>\delta</math> a
total function.</paragraph><paragraph>This machine will scan right, changing any <math>a</math> that it sees
to a <math>\#</math>.
When it first hits a <math>\#</math>, it will halt.</paragraph></topic><topic><title>Example</title><paragraph><math>M = (K, \Sigma, \delta, s)</math> where</paragraph><bullet_list bullet="*"><list_item><paragraph><math>K = \{q_0\}</math>,</paragraph></list_item><list_item><paragraph><math>\Sigma = \{a, \#\}</math>,</paragraph></list_item><list_item><paragraph><math>s = q_0</math>,</paragraph></list_item><list_item><paragraph><math>\delta =</math></paragraph><math_block xml:space="preserve">\begin{array}{lll}
\hline
q&amp;\sigma&amp;\delta(q, \sigma)\\
\hline
q_0&amp;a&amp;(q_0, L)\\
q_0&amp;\#&amp;(h, \#)\\
\end{array}</math_block></list_item></bullet_list><paragraph>This machine will scan left until it encounters <math>\#</math>, and
then halt.</paragraph></topic></section><section ids="interpreting-turing-machines" names="interpreting\ turing\ machines"><title>Interpreting Turing Machines</title><paragraph>A <title_reference>configuration</title_reference> for a Turing machine looks like this:</paragraph><math_block xml:space="preserve">(q, aaba\#\underline{\#}a)</math_block><paragraph>A <title_reference>halted configuration</title_reference> occurs when <math>q</math> is <math>h</math>, the
halt state.</paragraph><paragraph>A <title_reference>hanging configuration</title_reference> occurs when the I/O head moves to the
left from the left-most square of the tape.</paragraph><paragraph>A <title_reference>computation</title_reference> is a sequence of configurations for some
length <math>n \geq 0</math>.
Execution on the first machine example from the starting configuration
show would appear as follows:</paragraph><math_block xml:space="preserve">\begin{eqnarray*}
(q_0, \underline{a}aaa) &amp;\vdash_M&amp;(q_1, \underline{\#}aaa)\\
&amp;\vdash_M&amp;(q_0, \#\underline{a}aa)\\
&amp;\vdash_M&amp;(q_1, \#\underline{\#}aa)\\
&amp;\vdash_M&amp;(q_0, \#\#\underline{a}a)\\
&amp;\vdash_M&amp;(q_1, \#\#\underline{\#}a)\\
&amp;\vdash_M&amp;(q_0, \#\#\#\underline{a})\\
&amp;\vdash_M&amp;(q_1, \#\#\#\underline{\#})\\
&amp;\vdash_M&amp;(q_0, \#\#\#\#\underline{\#})\\
&amp;\vdash_M&amp;(h, \#\#\#\#\underline{\#})\\
\end{eqnarray*}</math_block><paragraph><math>M</math> is said to <strong>halt on input :math:`w`</strong> iff
<math>(s, \#w\underline{\#})</math> yields some halted configuration.</paragraph><paragraph><math>M</math> is said to <strong>hang on input :math:`w`</strong> if
<math>(s, \#w\underline{\#})</math> yields some hanging configuration.
That means <emphasis>either</emphasis> move left from left end <emphasis>or</emphasis> go into an infinite loop.</paragraph><paragraph>Turing machines compute functions from strings to strings.
Formally: Let <math>f</math> be a function from <math>\Sigma^*_0</math> to
<math>\Sigma^*_1</math>.
Turing machine <math>M</math> is said to <strong>compute</strong> <math>f</math> when,
for any <math>w \in \Sigma^*_0</math>, if <math>f(w) = u</math> then</paragraph><math_block xml:space="preserve">(s, \#w\underline{\#}) \vdash^*_M (h, \#u\underline{\#}).</math_block><paragraph>Such a function <math>f</math> is said to be a <title_reference>Turing-computable function</title_reference>.</paragraph><paragraph>Here is how we express multiple parameters:
For <math>f(w_1, ..., w_k) = u</math>,</paragraph><math_block xml:space="preserve">(s, \#w_1\#w_2\#...\#w_k\underline{\#}) \vdash^*_M (h, \#u\underline{\#}).</math_block><paragraph>One way to express functions on natural numbers is to represent a
number using <title_reference>unary notation</title_reference>.
(Remember, we are not concerned about is efficient, we are concerned
about what is possible.)
In this case, we represent the value 0 as an empty string.
We say that <math>f: \mathbb{N} \rightarrow \mathbb{N}</math>
is computed by <math>M</math> if <math>M</math>
computes <math>f': \{I\}^* \rightarrow \{I\}^*</math> where
<math>f'(I^n) = I^{f(n)}</math> for each <math>n \in \mathbb{N}</math>.</paragraph><topic><title>Example</title><paragraph>Compute <math>f(n) = n + 1</math> for each <math>n \in \mathbb{N}</math>.</paragraph><math_block xml:space="preserve">\begin{array}{lll}
\hline
q&amp;\sigma&amp;\delta(q, \sigma)\\
\hline
q_0&amp;I&amp;(h, R)\\
q_0&amp;\#&amp;(q_0, I)\\
\end{array}</math_block><paragraph>An example computation:</paragraph><math_block xml:space="preserve">(q_0, \#II\underline{\#}) \vdash_M (q_0, \#II\underline{I}) \vdash_M
(h, \#III\underline{\#}).</math_block><paragraph>In general,
<math>(q_0, \#I^n\underline{\#}) \vdash^*_M (h, \#I^{n+1}\underline{\#})</math>.
What about <math>n = 0</math>?
The input is no marks in unary, and it works OK.</paragraph></topic></section><section ids="turing-decideable-vs-turing-acceptable-languages" names="turing-decideable\ vs.\ turing-acceptable\ languages"><title>Turing-Decideable vs. Turing-Acceptable Languages</title><paragraph>A language <math>L \subset \Sigma_0^*</math> is <title_reference>Turing-decidable</title_reference>
iff function <math>\chi_L: \Sigma^*_0 \rightarrow \{\fbox{Y}, \fbox{N}\}</math>
is Turing-computable, where for each <math>w \in \Sigma^*_0</math>,</paragraph><math_block xml:space="preserve">\chi_L(w) = \left\{
\begin{array}{ll}
\fbox{Y} &amp; \mbox{if $w \in L$}\\
\fbox{N}  &amp; \mbox{otherwise}
\end{array}
\right.</math_block><paragraph>Example: Let <math>\Sigma_0 = \{a\}</math>, and let
<math>L = \{w \in \Sigma^*_0: |w|\ \mbox{is even}\}</math>.</paragraph><paragraph><math>M</math> erases the marks from right to left, with current parity
encode by state.
Once blank at left is reached, mark <math>\fbox{Y}</math> or
<math>\fbox{N}</math> as appropriate.</paragraph><paragraph>There are many views of computation.
One is functions mapping input to output
(<math>N \rightarrow N</math>, or
strings to strings, for examples).
Another is deciding if a string is in a language.</paragraph><paragraph><math>M</math> <title_reference>accepts</title_reference> a string <math>w</math> if <math>M</math> halts on
input <math>w</math>.</paragraph><bullet_list bullet="*"><list_item><paragraph><math>M</math> accepts a language iff :math:M` halts on <math>w</math> iff
<math>w \in L</math>.</paragraph></list_item><list_item><paragraph>A language is <math>Turing-acceptable</math> if there is some Turing
machine that accepts it.</paragraph></list_item></bullet_list><paragraph>Example: <math>\Sigma_0 = \{a, b\}</math>,
<math>L = \{w \in \Sigma^*_0: w\ \mbox{contains at least one}\ a\}</math>.</paragraph><math_block xml:space="preserve">\begin{array}{lll}
\hline
q&amp;\sigma&amp;\delta(q, \sigma)\\
\hline
q_0&amp;a&amp;(h, a)\\
q_0&amp;b&amp;(q_0, L)\\
q_0&amp;\#&amp;(q_0, L)\\
\hline
\end{array}</math_block><paragraph>Is this language Turing decidable?
Of course. Instead of just running left, invoke another state that
means "seen an <math>a</math>", and print <math>\fbox{Y}</math> if we reach
<math>\#</math> in that state, <math>\fbox{N}</math> otherwise.</paragraph><paragraph>Every Turing-decidable language is Turing-acceptable,
because if the machine would have printed <math>\fbox{Y}</math>,
then the machine can halt instead,
or if the machine would have printed <math>\fbox{N}</math>,
then it can hang left.</paragraph><paragraph>Is every Turing-acceptible language Turing decidable?
This is the Halting Problem.</paragraph><paragraph>Of course, if the Turing-acceptible language would halt,
we write <math>\fbox{Y}</math>.
But if the Turing-acceptible language would hang,
can we <emphasis>always</emphasis> replace it with logic to write <math>\fbox{N}</math>
instead?
Example: Collatz function.</paragraph></section><section ids="making-more-complicated-machines" names="making\ more\ complicated\ machines"><title>Making More Complicated Machines</title><paragraph><strong>Lemma</strong>: If</paragraph><math_block xml:space="preserve">(q_1, w_1\underline{a_1}u_1) \vdash_M^* (q_2, ww_2\underline{a_2}u_2)</math_block><paragraph>for string <math>w</math> and</paragraph><math_block xml:space="preserve">(q_2, w_2\underline{a_2}u_2) \vdash^*_M (q_3, w_3\underline{a_3}u_3),</math_block><paragraph>then</paragraph><math_block xml:space="preserve">(q_1, w_1\underline{a_1}u_1) \vdash^*_M (q_3, ww_3\underline{a_3}u_3).</math_block><paragraph>Insight: Since
<math>(q_2, w_2\underline{a_2}u_2) \vdash^*_M (q_3, w_3\underline{a_3}u_3)</math>,
this computation must take place without moving the head left of <math>w_2</math>
The machine cannot "sense" the left end of the tape.
(And if it had moved left, it would have hung.)
Thus, the head won't move left of <math>w_2</math> even if it is not at the
left end of the tape.</paragraph><paragraph>This means that Turing machine computations can be combined into
larger machines:</paragraph><bullet_list bullet="*"><list_item><paragraph><math>M_2</math> prepares string as input to <math>M_1</math>.</paragraph></list_item><list_item><paragraph><math>M_2</math> passes control to <math>M_1</math> with I/O head at end of input.</paragraph></list_item><list_item><paragraph><math>M_2</math> retrieves control when <math>M_1</math> has completed.</paragraph></list_item></bullet_list><paragraph>Here are some basic machines and notation</paragraph><bullet_list bullet="*"><list_item><paragraph><math>|\Sigma|</math> symbol-writing machines (one for each symbol):
Any give letter <math>\sigma</math> has a symbol-writing machine named
<math>\sigma</math>.</paragraph></list_item><list_item><paragraph>Head-moving machines, named <math>R</math> and <math>L</math>, move the head
appropriately.</paragraph></list_item><list_item><paragraph>Start state indicated with <math>&gt;</math>.</paragraph></list_item><list_item><paragraph>Transitions on anything other than (for example) <math>\#</math> are
labeled <math>\overline{\#}</math></paragraph></list_item><list_item><paragraph>Multiple copies of a machine get a superscript: <math>R^2</math> means
move right twice.</paragraph></list_item></bullet_list><raw format="xml" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="Turing1CON"
    long_name="Turing1CON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="Turing2CON"
    long_name="Turing2CON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="Turing3CON"
    long_name="Turing3CON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="TuringCopyCON"
    long_name="TuringCopyCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="TuringShiftCON"
    long_name="TuringShiftCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></section><section ids="turing-machine-extensions" names="turing\ machine\ extensions"><title>Turing Machine Extensions</title><paragraph>When we give extentions or new functionality to a computing system,
sometimes they change something fundamental about the capabilies of
the system.
For example, when we add non-determinism to an algorithm, we <strong>might</strong>
change the cost of the underlying problem from exponential to
polynomial time.
But, other changes do nothing fundamental.
In terms of Turing machines, our concern is what the machine can do,
rather than how long it takes to do it.
Does non-determinism help us to solve the Halting problem?
No.
Likewise, the following extensions do not increase the power of Turing
Machines.</paragraph><bullet_list bullet="*"><list_item><paragraph>Provide a two-way infinite tape</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="TuringExt1CON"
    long_name="TuringExt1CON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>This does not give Turing machines new capability.
To make this clear, we can simulate the behavior of a two-way
infinite tape using a standard one-way infinite tape.
Just bend infinite tape in the middle, and store both directions of
the tape into a single cell.
This requires a greatly expanded alphabet, because we now need to be
able to represent any combination of two characters.
This will need more states, and probably more time.
But it does not allow anything new in terms of capability.</paragraph></list_item><list_item><paragraph>Multiple tapes (each with its own head)</paragraph><paragraph>Again, we can simulate this with encoding multiple symbols into a
single table cell.
For example, to simulate two tapes (each with a head), we encode in
each cell the corresponding two symbols, and a two binary markers to
indicate if the tape head is currently in the corresponding cell of
the two tapes.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="TuringExt2CON"
    long_name="TuringExt2CON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></list_item><list_item><paragraph>Multiple heads on one tape</paragraph><paragraph>This is easier than encoding multiple tapes.
We merely encode the heads onto the tape, and simulate moving them
around.</paragraph></list_item><list_item><paragraph>A two-dimensional <literal>tape</literal></paragraph><paragraph>All that we need to do is find a mapping from 2D to 1D, which is
fairly easy.
One approach is to work in diagonals, in the order (0, 0), (0, 1),
(1, 0), (0, 2), (1, 1), (2, 0), and so on.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="TuringExt3CON"
    long_name="TuringExt3CON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></list_item><list_item><paragraph>Non-determinism</paragraph><paragraph>We can simulate nondeterministic behavior in sequence, doing all
length 1 computations, then length 2, etc., until we reach a halt
state for one of the non-deteriministic choices.
So we see that while non-determinism can save a lot of time, it does
not change what can (eventually) be done.</paragraph></list_item></bullet_list><raw format="xml" xml:space="preserve"><odsascript>AV/SeniorAlgAnal/Turing1CON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/SeniorAlgAnal/Turing2CON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/SeniorAlgAnal/Turing3CON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/SeniorAlgAnal/TuringCopyCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/SeniorAlgAnal/TuringShiftCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/SeniorAlgAnal/TuringExt1CON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/SeniorAlgAnal/TuringExt2CON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/SeniorAlgAnal/TuringExt3CON.js</odsascript></raw></section></document>