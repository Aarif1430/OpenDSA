<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="semester-overview" names="semester\ overview" source="&lt;string&gt;" title="Semester Overview"><title>Semester Overview</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><section ids="introduction" names="introduction"><title>Introduction</title><paragraph>The central question for this course is:
<strong>Given a problem, do we have (or can we devise) a good solution?</strong>
Everything that we will do is connected to this central question in some
way.
Here "good" will usually be taken to mean "as efficient as the problem
will allow".</paragraph><paragraph>If we have a problem and a proposed solution, then we need a mechanism
that will let us assess whether that solution is good or not.
This is where algorithm analysis comes in.
This module is not a review of basic algorithm analysis.
It is a reconstruction of the basic concept, from the ground up.
Your prior study of algorithm analysis probably focussed on how to
analyze a given program or algorithm.
We will certainly do that during the course.
But in this module, we will focus on the question of how algorithm
analysis helps us to answer our central question.</paragraph><paragraph>This discussion assumes that you are roughly familiar with basic
<title_reference>algorithm analysis</title_reference> terms and concepts.
These include definitions for the terms <title_reference>problem</title_reference> versus
<title_reference>algorithm</title_reference> versus <title_reference>program</title_reference>.
These include the concepts of
<title_reference>upper bounds &lt;upper bound&gt;</title_reference>,
<title_reference>lower bounds &lt;lower bound&gt;</title_reference>,
<title_reference>growth rate</title_reference>, <title_reference>best case</title_reference>, <title_reference>worst case</title_reference>,
<title_reference>average case</title_reference>, <title_reference>big-oh notation</title_reference>,
<title_reference>Omega notation</title_reference>, and <title_reference>Theta notation</title_reference>.
Review any of this material as necessary before continuing.</paragraph><paragraph>Our problems must be well-defined enough to be solved on computers.
(Actually, to solve a problem we need more than just a clear
definition. By the end of the semester, we will discuss problems that
are not computable (i.e., cannot be solved) even though their
definition is clear.)</paragraph><paragraph>A <title_reference>problem</title_reference> is a <title_reference>function</title_reference>
(i.e., a mapping of inputs to outputs).
We have different <title_reference>problem instances &lt;problem instance&gt;</title_reference>
(inputs) for the problem, where each instance has a size.
To solve a problem, we must provide an algorithm, a coding
of problem instances into inputs for the algorithm, and a coding for
outputs into solutions.</paragraph><paragraph>An <title_reference>algorithm</title_reference> executes the mapping.
A proposed algorithm must work for ALL instances
(give the correct mapping to the output for that input instance).
(Actually, we will relax this restriction later when we talk about
Approximation and Probabilistic algorithms.)</paragraph><paragraph>Our goal is to solve problems with as little computational effort per
instance as possible.
We are most often interested in solutions to "large" instances
of the problem (asymptotic Analysis).
Occasionally we are concerned with small instances.
Then, constants matter.</paragraph><paragraph>Ultimately, we want to solve a <title_reference>problem</title_reference> by using an efficient
<title_reference>programs &lt;program&gt;</title_reference>.
But it is not a good idea to start by writing programs and then
comparing them.
We don't want to spend a lot of time writing worthless programs.
We want a way to decide if the program is worth writing in
the first place.
So, we will really spend most of our time looking at
<title_reference>algorithms &lt;algorithm&gt;</title_reference> instead of programs, and using
<title_reference>algorithm analysis</title_reference> to evaluate the algorithms.</paragraph><paragraph>Algorithm analysis is essentially an exercise in modeling.
A <title_reference>model</title_reference> is a simplification of reality that preserves only the
essential elements.
With a model, we can more easily focus on and reason about these
essentials.</paragraph><paragraph>Our primary tactical concern for the semester will be how to recognize
if an algorithm is efficient or not.
We will need (and so will study) a lot of mathematical tools for this.
Your primary tools will be <title_reference>summations &lt;summation&gt;</title_reference> and
<title_reference>recurrence relations &lt;recurrence relation&gt;</title_reference>.
Given the nature of many of our algorithms, we need to develop a lot
of proficiency using logarithms.</paragraph></section><section ids="modeling-algorithm-cost" names="modeling\ algorithm\ cost"><title>Modeling Algorithm Cost</title><paragraph>We want to measure the cost of an algorithm.
We want this process to be as simple as possible.
We need a yardstick to define the "cost" of the algorithm.
Qualities for this yardstick are:</paragraph><block_quote><bullet_list bullet="*"><list_item><paragraph>It should measure something that we care about.
Usually we care about time, but not always.</paragraph></list_item><list_item><paragraph>It should by quantitative, allowing comparisons.</paragraph></list_item><list_item><paragraph>It should be easy to compute (the measure, not the algorithm).</paragraph></list_item><list_item><paragraph>It should be a good predictor of what a corresponding program
would actually cost.</paragraph></list_item></bullet_list></block_quote><paragraph>The fundamental driver for algorithm analysis is the behavior (growth
rate) of a the algorithm as the problem size grows.
Just to complicate things: Algorithms can behave very different on
different inputs of a given size.
The concepts of best, average, and worst cases come in here.
To have a meaningful discussion about the behavior of an algorithm, we
have to agree in advance about <strong>which</strong> of the many behaviors that
algorithm might have in terms of its growth rate as the input size
grows.</paragraph><paragraph>To model the growth rate of an algorithm, we need:</paragraph><block_quote><bullet_list bullet="*"><list_item><paragraph>A measure for problem size.</paragraph></list_item><list_item><definition_list><definition_list_item><term>A measure for solution effort.</term><definition><bullet_list bullet="*"><list_item><paragraph>We use a count of the <title_reference>basic operations &lt;basic operation&gt;</title_reference>
as a measure of solution effort.</paragraph></list_item></bullet_list></definition></definition_list_item></definition_list></list_item></bullet_list></block_quote><paragraph>To get a measurement, either for the problem size or the solution
effort, we have to have a <title_reference>cost model</title_reference>.
Here is a simple example.
Assume that our problem is how to square a value.
We will accept as our input size the value that we want to square.
(Later on, we will actually come to realize that this is actually a
lousy way to model input size for a numeric problem, but it will do
for now.)</paragraph><paragraph>Here is an example of a model for a cost measure.
Like any model, it might or might not be a <strong>good</strong> model.
Look back at the list of qualities for a good model, and think about
whether this example has those qualities or not as you read through
it.</paragraph><paragraph>Our problem is to calculate the square of a number.</paragraph><paragraph>We will model the input size as simply the value of the number.
(Later we will come to realize that this is a lousy model for the
input size of a numeric problem. But its good enough for now.)</paragraph><paragraph>To model the cost of the solution, we will assume that
asigning to a variable takes fixed time.
We will also assume that all other operations take no time.
(Is this a good model? Whether it is good or not, it <strong>is</strong> a model.)</paragraph><paragraph>Algorithm 1:</paragraph><literal_block xml:space="preserve">sum = n*n;</literal_block><paragraph>One assignment was made, so the cost is 1.
Is this a good model for our intuitive notion of the cost for this
code fragment?
Most people would consider this a reasonable estimate of the work done
for most purposes.
So it looks like a reasonable model.</paragraph><paragraph>Algorithm 2:</paragraph><literal_block xml:space="preserve">sum = 0;
for (i=1; i&lt;=n; i++)
  sum = sum + n;</literal_block><paragraph>The number of assignments made is</paragraph><math_block xml:space="preserve">1 + \sum_{i=1}^{n} 1 = n + 1</math_block><paragraph>Now, there is a lot of room for quibbling here.
Depending on how you want to deal with loop variables,
you might want to say that the number of assignments is
<math>2n + 1</math>.
This makes a difference of <math>n+1</math> vs <math>2n+1</math>.
Does it matter?
Not so much.
We didn't know the exact amount of time for an operation
to begin with, so the factor of 2 doesn't seem to mean much.
What is important is that the growth rates of these two are the same.
In fact, this is the key consideration.
Perhaps we are concerned about whether an assignment is the same in
real runtime cost as a multiplication, which might be different from
an addition.
Maybe incrementing a loop variable costs something different from
doing an ordinary assignment.
But really none of this matters when compared against the fundamental
recognition that the cost of this algorithm is proportional to the
input size (in this case, the value of the input variable).
<math>n+1</math> and <math>2n+1</math> both have linear growth rate,
so they are both equally predictive of the growth rate for the
algorithm.
If we all agree that this approch to squaring a number has a linear
growth rate on the size of the number, then we can conclude that this
is a reasonable model for the purpose of estimating the growth rate.</paragraph><paragraph>Algorithm 3:</paragraph><literal_block xml:space="preserve">sum = 0;
for (i=1; i&lt;=n; i++)
  for (j=1; j&lt;=n; j++)
    sum = sum + 1;</literal_block><paragraph>The number of assignments made is:</paragraph><math_block xml:space="preserve">1 + \sum_{i=1}^{n} \sum_{j=1}^n 1 = n^2 + 1</math_block><paragraph>Again, this is a reasonable model for the cost of this algorithm.</paragraph><paragraph>Now, given three algorithms, and with a model in hand for measuring
their costs, the next question is:
Which of these three algorithms is best (meaning, requires the
least amount of work to run)?
Obviously we consider the first to be best in this sense.</paragraph><paragraph>In comparison to the above example, consider a problem that involves
string assignment (done by copying the characters in the string).
In this case, is our model that assignment has contant time cost still
good?
Think about this.</paragraph><paragraph>As another example of modeling:
Consider a problem that works on a list, and an important basic
operation is accessing the <math>i\mathrm{th}</math> record on the list.
We can take as our model that such an access requires one unit of
work.
If the list is implemented using an array in memory, then we probably
consider this to be a "reasonable" model.
If the list is implemented using a singly linked list, then we
probably do <strong>not</strong> consider this to be a "reasonable" model.
(Why?)</paragraph></section><section ids="big-issues" names="big\ issues"><title>Big Issues</title><paragraph><strong>How do we create an efficient algorithm?</strong>
We use problem solving and algorithm design skills.
This semester, we will see some standard algorithm design techniques.
One good example of such a design technique that works for a lot of
problems is <title_reference>dynamic programming</title_reference>.</paragraph><paragraph><strong>How do we recognize a "good" algorithm?</strong>
This is a key issue, because we don't know whether to stop with trying
to create a "good" algorithm unless we can recognize one.
Our answer is: By the relationship of its performance to the intrinsic
difficulty of the problem.
Of course, that requires a measure for the algorithm's performance and
a measure for the intrinsic difficulty of the problem.</paragraph><paragraph><strong>How "hard" is a problem?</strong>
That is, what is its intrinsic difficulty?
This is where the concept of the <title_reference>lower bound</title_reference> for a problem
comes in.
For now, we will restrict the term "hard" to mean "How much does it
cost to run?"
Later, we will talk about some different meanings for the term "hard".</paragraph><paragraph>As we go through a series of problems this semester, we will use the
following general plan:</paragraph><block_quote><bullet_list bullet="*"><list_item><paragraph>Define a PROBLEM.</paragraph></list_item><list_item><paragraph>Build a MODEL to measure the size of the input, and the cost of a
solution to the problem.</paragraph></list_item><list_item><paragraph>Design an ALGORITHM to solve the problem.</paragraph></list_item><list_item><definition_list><definition_list_item><term>ANALYZE both problem and algorithm under the model.</term><definition><bullet_list bullet="*"><list_item><paragraph>Analyze an algorithm to get an UPPER BOUND.</paragraph></list_item><list_item><paragraph>Analyze a problem to get a LOWER BOUND.</paragraph></list_item></bullet_list></definition></definition_list_item></definition_list></list_item><list_item><paragraph>COMPARE the bounds to see if our solution is "good enough".</paragraph></list_item></bullet_list></block_quote><paragraph>If the two bounds that we compute do not match, then here are some
options:</paragraph><block_quote><bullet_list bullet="*"><list_item><paragraph>Redesign the algorithm, or invent a new one.</paragraph></list_item><list_item><paragraph>Tighten the bounds (if they were not already tight).</paragraph></list_item><list_item><paragraph>Change the model.</paragraph></list_item><list_item><paragraph>Change the problem.</paragraph></list_item></bullet_list></block_quote></section></document>