{"document": {"@dupnames": "implementing\\ tree\\ traversals", "@ids": "implementing-tree-traversals", "@source": "<string>", "@title": "Implementing Tree Traversals", "title": "Implementing Tree Traversals", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@dupnames": "implementing\\ tree\\ traversals", "@ids": "id1", "title": "Implementing Tree Traversals", "paragraph": ["Recall that any recursive function requires the following:", "In this module, we will talk about some details related to correctly\nand clearly implementing recursive tree traversals."], "block_quote": {"enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "The base case and its action."}, {"paragraph": "The recursive case and its action."}]}}, "section": [{"@ids": "base-case", "@names": "base\\ case", "title": "Base Case", "paragraph": ["In binary tree traversals, most often the base case is to check if we\nhave an empty tree.\nA common mistake is to check the child pointers of the current node,\nand only make the recursive call for a non-null child.", "Recall the basic preorder traversal function.", "Here is an alternate design for the preorder traversal, in which the\nleft and right pointers of the current node are checked so that the\nrecursive call is made only on non-empty children.", {"literal": ["preorder2", "preorder", "preorder2"], "#text": "At first it might appear that  is more efficient\nthan , because it makes only half as many recursive\ncalls (since it won't try to call on a null pointer).\nOn the other hand,  must access the left and right\nchild pointers twice as often.\nThe net result is that there is no performance improvement."}, {"literal": ["preorder2", "null", "preorder2", "preorder2", "null", "preorder2"], "#text": "Perhaps the writer of  wants to protect against the case\nwhere the root is .\nBut  has an error.\nWhile  insures that no recursive\ncalls will be made on empty subtrees, it will fail if the orignal call\nfrom outside passes in a null pointer.\nThis would occur if the original tree is empty.\nSince an empty tree is a legitimate input to the initial call on the\nfunction, there is no safe way to avoid this case.\nSo it is necessary that the first thing you do on a binary tree\ntraversal is to check that the root is not .\nIf we try to fix  by adding this test, then making the\ntests on the children is completely redundant because the pointer will\nbe checked again in the recursive call."}, {"literal": ["preorder2", "preorder", "null", "preorder2", "null", "preorder", "null"], "strong": "not", "#text": "The design of  is inferior to\nthat of  for a deeper reason as well.\nLooking at the children to see if they are  means that we are\nworrying too much about something that can be dealt with just as well\nby the children.\nThis makes the function more complex, which can become a real problem\nfor more complex tree structures.\nEven in the relatively simple  function, we had to write\ntwo tests for  rather than the one needed by .\nThis makes it more complicated than the original version.\nThe key issue is that it is much easier to write a recursive function\non a tree when we only think about the needs of the current node.\nWhenever we can, we want to let the children take care of themselves.\nIn this case, we care that the current node is not , and we care\nabout how to invoke the recursion on the children, but we do \nhave to care about how or when that is done."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}]}, {"@ids": "the-recursive-call", "@names": "the\\ recursive\\ call", "title": "The Recursive Call", "paragraph": ["The secret to success when writing a recursive function is to not\nworry about how the recursive call works.\nJust accept that it will work correctly.\nOne aspect of this principle is not to worry about checking your\nchildren when you don't need to.\nYou should only look at the values of your children if you need to\nknow those values in order to compute some property of the current\nnode.\nChild values should not be used to decide whether to call them\nrecursviely.\nMake the call, and let their own base case handle it.", {"strong": "not", "#text": "In rare problems, you might need to explicitly check if the children\nare null or access the children values for each node.\nFor example, you might need to check if all nodes in a tree satisfy\nthe property that each node stores the sum of its left and right\nchildren.\nIn this situation you must look at the values of the children to\ndecide something about the current node.\nYou do  look at the children to decide whether to make a recursive\ncall."}], "topic": {"title": "Example", "paragraph": ["Consider the problem of incrementing the value for each node in a\nbinary tree.\nThe following solution has an error, since it does redundant\nmanipulation to left and the right children of each node.", "The efficient solution should not explicitly set the children\nvalues that way.\nChanging the value of a node does not depend on the child values.\nSo the function should simply increment the root value, and make\nrecursive calls on the children."], "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}}}]}, {"@ids": "binary-tree-increment-by-one-exercise", "@names": "binary\\ tree\\ increment\\ by\\ one\\ exercise", "title": "Binary Tree Increment By One Exercise", "raw": {"@format": "xml", "@xml:space": "preserve", "extertool": {"@resource_name": "Binary Tree Increment By One Exercise", "@resource_type": "external_assignment", "@learning_tool": "code-workout", "@points": "2.0"}}}]}}