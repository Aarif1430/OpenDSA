<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="binary-search-trees" names="binary\ search\ trees" source="&lt;string&gt;" title="Binary Search Trees"><title>Binary Search Trees</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Binary/BSTCON.css</odsalink></raw><section ids="binary-search-tree-definition" names="binary\ search\ tree\ definition"><title>Binary Search Tree Definition</title><paragraph>A <title_reference>binary search tree</title_reference> (<title_reference>BST</title_reference>)
is a <title_reference>binary tree</title_reference> that conforms to the
following condition, known
as the <title_reference>binary search tree property</title_reference>.
All <title_reference>nodes &lt;node&gt;</title_reference> stored in the left subtree of a node whose
<title_reference>key</title_reference> value is <math>K</math> have key values
less than or equal to <math>K</math>.
All nodes stored in the right subtree of a node whose key value
is <math>K</math> have key values greater than <math>K</math>.
Figure <title_reference>Figure #BSTShape</title_reference> shows two BSTs for a collection of
values.
One consequence of the binary search tree property is that if the BST
nodes are printed using an
<title_reference>inorder traversal &lt;inorder traversal&gt; &lt;BinaryTreeTraversal&gt;</title_reference>,
then the resulting enumeration will be in
sorted order from lowest to highest.</paragraph><target refid="bstshape"></target><raw format="xml" ids="bstshape" names="bstshape" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>Here is a class declaration for the BST.
Recall that there are various ways to deal with
<title_reference>keys &lt;key&gt;</title_reference> and
<title_reference>comparing records &lt;comparable&gt; &lt;Comparison&gt;</title_reference>
Three typical approaches are <title_reference>key-value pairs &lt;key-value pair&gt;</title_reference>,
a special comparison method such as using the <literal>Comparator</literal> class,
and passing in a <title_reference>comparator function &lt;comparator&gt;</title_reference>.
Our BST implementation will require that records implement the
<literal>Comparable</literal> interface.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><section ids="bst-search" names="bst\ search"><title>BST Search</title><paragraph>The first operation that we will look at in detail will find the
record that matches a given key.
Notice that in the BST class, public member function
<literal>find</literal> calls private member function <literal>findhelp</literal>.
Method <literal>find</literal> takes the search key as an explicit parameter
and its BST as an implicit parameter, and returns the record that
matches the key.
However, the find operation is most easily implemented as a
recursive function whose parameters are the root of a
subtree and the search key.
Member <literal>findhelp</literal> has the desired form for this recursive
subroutine and is implemented as follows.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="BSTsearchCON"
    long_name="BSTsearchCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="BSTsearchPRO"
    long_name="BSTsearchPRO"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw></section></section><section ids="bst-insert" names="bst\ insert"><title>BST Insert</title><paragraph>Now we look at how to insert a new node into the BST.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="BSTinsertCON"
    long_name="BSTinsertCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Note that, except for the last node in the path, <literal>inserthelp</literal>
will not actually change the child pointer for any of the nodes that
are visited.
In that sense, many of the assignments seem redundant.
However, the cost of these additional assignments is worth paying to
keep the insertion process simple.
The alternative is to check if a given assignment is necessary, which
is probably more expensive than the assignment!</paragraph><paragraph>We have to decide what to do when the node that we want to
insert has a key value equal to the key of some node already in
the tree.
If during insert we find a node that duplicates the key value to be
inserted, then we have two options.
If the application does not allow nodes with equal keys, then this
insertion should be treated as an error (or ignored).
If duplicate keys are allowed, our convention will be to insert the
duplicate in the left subtree.</paragraph><paragraph>The shape of a BST depends on the order in which elements are inserted.
A new element is added to the BST as a new leaf node,
potentially increasing the depth of the tree.
Figure <title_reference>Figure #BSTShape</title_reference> illustrates two BSTs for a collection
of values.
It is possible for the BST containing <math>n</math> nodes to be a chain of
nodes with height <math>n</math>.
This would happen if, for example, all elements were inserted in
sorted order.
In general, it is preferable for a BST to be as shallow as
possible.
This keeps the average cost of a BST operation low.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="BSTinsertPRO"
    long_name="BSTinsertPRO"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw></section><section ids="bst-remove" names="bst\ remove"><title>BST Remove</title><paragraph>Removing a node from a BST is a bit trickier than inserting a node,
but it is not complicated if all of the possible cases are considered
individually.
Before tackling the general node removal process, we will first see
how to remove from a given subtree the node with the largest key
value.
This routine will be used later by the general node removal function.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="BSTdeletemaxCON"
    long_name="BSTdeletemaxCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>The return value of the <literal>deletemax</literal> method is the subtree of
the current node with the maximum-valued node in the subtree removed.
Similar to the <literal>inserthelp</literal> method, each node on the path back to
the root has its right child pointer reassigned to the subtree
resulting from its call to the <literal>deletemax</literal> method.</paragraph><paragraph>A useful companion method is <literal>getmax</literal> which returns a
pointer to the node containing the maximum value in the subtree.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>Now we are ready for the <literal>removehelp</literal> method.
Removing a node with given key value <math>R</math> from the BST
requires that we first find <math>R</math> and then remove it from the
tree.
So, the first part of the remove operation is a search to find
<math>R</math>.
Once <math>R</math> is found, there are several possibilities.
If <math>R</math> has no children, then <math>R</math>'s parent has its
pointer set to NULL.
If <math>R</math> has one child, then <math>R</math>'s parent has
its pointer set to <math>R</math>'s child (similar to <literal>deletemax</literal>).
The problem comes if <math>R</math> has two children.
One simple approach, though expensive, is to set <math>R</math>'s parent to
point to one of <math>R</math>'s subtrees, and then reinsert the remaining
subtree's nodes one at a time.
A better alternative is to find a value in one of the
subtrees that can replace the value in <math>R</math>.</paragraph><paragraph>Thus, the question becomes:
Which value can substitute for the one being removed?
It cannot be any arbitrary value, because we must preserve the BST
property without making major changes to the structure of the tree.
Which value is most like the one being removed?
The answer is the least key value greater than the one
being removed, or else the greatest key value less than (or equal to)
the one being removed.
If either of these values replace the one being removed,
then the BST property is maintained.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="BSTremoveCON"
    long_name="BSTremoveCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>When duplicate node values do not appear in the tree, it makes no
difference whether the replacement is the greatest value from the
left subtree or the least value from the right subtree.
If duplicates are stored in the left subtree, then we must select
the replacement from the <emphasis>left</emphasis> subtree. <footnote_reference auto="1" ids="id1" refid="id2">1</footnote_reference>
To see why, call the least value in the right subtree <math>L</math>.
If multiple nodes in the right subtree have value <math>L</math>,
selecting <math>L</math> as the replacement value for the root of the
subtree will result in a tree with equal values to the right of the
node now containing <math>L</math>.
Selecting the greatest value from the left subtree does not
have a similar problem, because it does not violate the Binary Search
Tree Property if equal values appear in the left subtree.</paragraph><footnote auto="1" backrefs="id1" ids="id2" names="1"><label>1</label><paragraph>Alternatively, if we prefer to store duplicate values in the
right subtree, then we must replace a deleted node with the
least value from its right subtree.</paragraph></footnote><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="BSTremovePRO"
    long_name="BSTremovePRO"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw></section><section ids="bst-analysis" names="bst\ analysis"><title>BST Analysis</title><paragraph>The cost for <literal>findhelp</literal> and <literal>inserthelp</literal> is the depth of
the node found or inserted.
The cost for <literal>removehelp</literal> is the depth of the node being
removed, or in the case when this node has two children,
the depth of the node with smallest value in its right subtree.
Thus, in the worst case, the cost for any one of these operations is
the depth of the deepest node in the tree.
This is why it is desirable to keep BSTs
<title_reference>balanced &lt;balanced tree&gt;</title_reference>, that is, with least possible
height.
If a binary tree is balanced, then the height for a tree of <math>n</math>
nodes is approximately <math>\log n</math>.
However, if the tree is completely unbalanced, for example in the
shape of a linked list, then the height for a tree with <math>n</math>
nodes can be as great as <math>n</math>.
Thus, a balanced BST will in the average case have operations costing
<math>\Theta(\log n)</math>, while a badly unbalanced BST can have
operations in the worst case costing <math>\Theta(n)</math>.
Consider the situation where we construct a BST of <math>n</math> nodes
by inserting records one at a time.
If we are fortunate to have them arrive in an order that results in a
balanced tree (a "random" order is likely to be good
enough for this purpose), then each insertion will cost on average
<math>\Theta(\log n)</math>, for a total cost of
<math>\Theta(n \log n)</math>.
However, if the records are inserted in order of increasing value,
then the resulting tree will be a chain of height <math>n</math>.
The cost of insertion in this case will be
<math>\sum_{i=1}^{n} i = \Theta(n^2)</math>.</paragraph><paragraph>Traversing a BST costs <math>\Theta(n)</math> regardless of the shape of
the tree.
Each node is visited exactly once, and each child pointer
is followed exactly once.</paragraph><paragraph>Below is an example traversal, named <literal>printhelp</literal>.
It performs an inorder traversal on the BST to print the node values
in ascending order.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>While the BST is simple to implement and efficient when the tree is
balanced, the possibility of its being unbalanced is a serious
liability.
There are techniques for organizing a BST to guarantee good performance.
Two examples are the
<title_reference>AVL tree &lt;AVL tree&gt; &lt;AVL&gt;</title_reference> and the
<title_reference>splay tree &lt;splay tree&gt; &lt;Splay&gt;</title_reference>.
There also exist other types of search trees that are guaranteed to
remain balanced, such as the <title_reference>2-3 Tree &lt;2-3 tree&gt; &lt;TwoThreeTree&gt;</title_reference>.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="BSTSumm"
    long_name="BSTSumm"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/BSTsearchCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/BSTinsertCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/BSTdeletemaxCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/BSTremoveCON.js</odsascript></raw></section></document>