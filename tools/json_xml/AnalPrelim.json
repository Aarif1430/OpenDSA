{"document": {"@dupnames": "problems,\\ algorithms,\\ and\\ programs", "@ids": "problems-algorithms-and-programs", "@source": "<string>", "@title": "Problems, Algorithms, and Programs", "title": "Problems, Algorithms, and Programs", "subtitle": {"@dupnames": "problems,\\ algorithms,\\ and\\ programs", "@ids": "id1", "#text": "Problems, Algorithms, and Programs"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/AlgAnal/ProblemAlgorithmCON.css"}], "section": [{"@ids": "problems", "@names": "problems", "title": "Problems", "paragraph": ["Programmers commonly deal with problems, algorithms, and\ncomputer programs.\nThese are three distinct concepts.", {"title_reference": "problem", "emphasis": "how", "#text": "As your intuition would suggest, a  is\na task to be performed.\nIt is best thought of in terms of inputs and matching outputs.\nA problem definition should not include any constraints on\n the problem is to be solved.\nThe solution method should be developed only after the problem is\nprecisely defined and thoroughly understood.\nHowever, a problem definition should include constraints on the\nresources that may be consumed by any acceptable\nsolution.\nFor any problem to be solved by a computer, there are always such\nconstraints, whether stated or implied.\nFor example, any computer program may use only the main memory\nand disk space available, and it must run in a \"reasonable\" amount\nof time."}, {"title_reference": ["function", "domain", "range", "parameters", "instance <problem instance>"], "#text": "Problems can be viewed as functions in the mathematical sense.\nA  is a matching\nbetween inputs (the ) and outputs (the ).\nAn input to a function might be a single value or a\ncollection of information.\nThe values making up an input are called the\n of the function.\nA specific selection of values for the parameters is called an\n of the problem.\nFor example, the input parameter to a sorting function might be an\narray of integers.\nA particular array of integers, with a given size and specific values\nfor each position in the array, would be an instance of the sorting\nproblem.\nDifferent instances might generate the same output.\nHowever, any problem instance must always result in the same output\nevery time the function is computed using that particular input."}, {"literal": "date", "title_reference": "Computability <computability> <Computability>", "#text": "This concept of all problems behaving like mathematical functions\nmight not match your intuition for the behavior of computer programs.\nYou might know of programs to which you can give the same input value\non two separate occasions, and two different outputs will result.\nFor example, if you type  to a typical Linux command\nline prompt, you will get the current date.\nNaturally the date will be different on different days, even though\nthe same command is given.\nHowever, there is obviously more to the input for the date program\nthan the command that you type to run the program.\nThe date program computes a function.\nIn other words, on any particular day there can only be a single\nanswer returned by a properly running date program on a completely\nspecified input.\nFor all computer programs, the output is completely determined by the\nprogram's full set of inputs.\nEven a \"random number generator\" is completely determined by its\ninputs (although some random number generating systems appear to get\naround this by accepting a random input from a physical\nprocess beyond the user's control).\nThe limits to what functions can be implemented by programs is part of\nthe domain of ."}]}, {"@ids": "algorithms", "@names": "algorithms", "title": "Algorithms", "paragraph": [{"title_reference": "algorithm", "#text": "An  is a method or a process followed to\nsolve a problem.\nIf the problem is viewed as a function, then an algorithm is an\nimplementation for the function\nthat transforms an input to the corresponding output.\nA problem can be solved by many different algorithms.\nA given algorithm solves only one\nproblem (i.e., computes a particular function).\nOpenDSA modules cover many problems, and for several of these\nproblems we will see more than one algorithm.\nFor the important problem of sorting there are over a dozen commonly\nknown algorithms!"}, {"title_reference": ["mathbf{A}", "mathbf{B}", "mathbf{B}", "mathbf{A}"], "#text": "The advantage of knowing several solutions to a problem is that\nsolution  might be more efficient than solution\n for a specific variation of the problem, or for a\nspecific class of inputs to the problem, while solution\n might be more efficient than\n for another variation or class of inputs.\nFor example, one sorting algorithm might be the best\nfor sorting a small collection of integers (which is important if you\nneed to do this many times).\nAnother might be the best for sorting a large collection of integers.\nA third might be the best for sorting a collection of variable-length\nstrings."}, "By definition, something can only be called an algorithm if it has all\nof the following properties."], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"emphasis": ["correct", "intended"], "#text": "It must be .\nIn other words, it must compute the desired function, converting\neach input to the correct output.\nNote that every algorithm implements some function,\nbecause every algorithm maps every input to some output (even if\nthat output is a program crash).\nAt issue here is whether a given algorithm implements the\n function."}}, {"paragraph": {"emphasis": "concrete steps", "#text": "It is composed of a series of .\nConcrete means that the action described by that step is\ncompletely understoodand doableby the person or machine\nthat must perform the algorithm.\nEach step must also be doable in a finite amount of time.\nThus, the algorithm gives us a \"recipe\" for solving the problem by\nperforming a series of steps, where each such step is within our\ncapacity to perform.\nThe ability to perform a step can depend on who or what is intended\nto execute the recipe.\nFor example, the steps of a cookie recipe in a cookbook might be\nconsidered sufficiently concrete for instructing a human cook,\nbut not for programming an automated cookie-making factory."}}, {"paragraph": {"emphasis": "no ambiguity", "literal": "if", "#text": "There can be  as to which step will be performed\nnext.\nOften it is the next step of the algorithm description.\nSelection (e.g., the  statement)\nis normally a part of any language for describing algorithms.\nSelection allows a choice for which step will be\nperformed next, but the selection process is unambiguous at the\ntime when the choice is made."}}, {"paragraph": {"emphasis": "finite", "literal": ["while", "for"], "#text": "It must be composed of a  number of steps.\nIf the description for the algorithm were made up of an infinite\nnumber of steps, we could never hope to write it down, nor\nimplement it as a computer program.\nMost languages for describing algorithms (including English\nand \"pseudocode\") provide some way to perform\nrepeated actions, known as iteration.\nExamples of iteration in programming languages include the\n and  loop constructs.\nIteration allows for short descriptions, with the number of\nsteps actually performed controlled by the input."}}, {"paragraph": {"emphasis": "terminate", "#text": "It must .\nIn other words, it may not go into an infinite loop."}}]}}, {"@ids": "programs", "@names": "programs", "title": "Programs", "paragraph": [{"title_reference": "program", "#text": "We often think of a computer  as an\ninstance, or concrete representation, of an algorithm in some\nprogramming language.\nAlgorithms are usually presented in terms of programs,\nor parts of programs.\nNaturally, there are many programs that are instances of the same\nalgorithm, because any modern computer programming language can be\nused to implement the same collection of algorithms (although some\nprogramming languages can make life easier for the programmer).\nTo simplify presentation,\npeople often use the terms \"algorithm\" and \"program\" interchangeably,\ndespite the fact that they are really separate concepts.\nBy definition, an algorithm must provide sufficient\ndetail that it can be converted into a program when needed."}, "The requirement that an algorithm must terminate means that not all\ncomputer programs meet the technical definition of an algorithm.\nYour operating system is one such program.\nHowever, you can think of the various tasks for an operating system\n(each with associated inputs and outputs) as individual problems,\neach solved by specific algorithms implemented by a part of the\noperating system program, and each one of which terminates once its\noutput is produced."]}, {"@ids": "summary", "@names": "summary", "title": "Summary", "paragraph": {"title_reference": ["problem", "algorithm", "program"], "#text": "To summarize:\nA  is a function or a mapping of\ninputs to outputs.\nAn  is a recipe for\nsolving a problem whose steps are concrete and unambiguous.\nAlgorithms must be correct, of finite length, and must terminate\nfor all inputs.\nA  is an instantiation of an algorithm\nin a programming language.\nThe following slideshow should help you to visualize the differences."}, "raw": {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "ProblemAlgorithmCON", "@long_name": "ProblemAlgorithmCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}}, {"@ids": "summary-questions", "@names": "summary\\ questions", "title": "Summary Questions", "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "AnalPrelimSumm", "@long_name": "AnalPrelimSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/AlgAnal/ProblemAlgorithmCON.js"}]}]}}