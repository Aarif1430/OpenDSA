{"document": {"@ids": "grammars-part-3", "@names": "grammars\\ -\\ part\\ 3", "@source": "<string>", "@title": "Grammars - Part 3", "title": "Grammars - Part 3", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}, {"@xml:space": "preserve", "#text": "(F 2/5/16)"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/PL/AV/parseTree.css"}], "section": [{"@ids": "rp-3-part-1", "@names": "rp\\ 3\\ part\\ 1", "title": "RP 3 part 1", "paragraph": ["In this module we will learn about", "In the previous module, we saw that ambiguous grammars are to be avoided because the parse trees that result from them lead to confusion when we attach semantic meaning to the structure of the parse tree. The tree cannot be relied on to specify the order of operations."], "block_quote": [{"enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Operator precedence"}, {"paragraph": "Operator associativity"}, {"paragraph": "EBNF extensions and their advantages"}]}}, {"paragraph": {"title_reference": ["eg1", "eg1", "A+B*C", "+", "*", "A+B", "C", "eg1"], "#text": "Although  does not suffer from ambiguity, it has another problem.  In particular, if you return to the parse tree slide-show that accompanied , you will note that in parsing , the  operation was at a deeper level in the tree than , thereby indicating that  would be evaluated first and then multiplied by .  However that order of operation does not coincide with the operator precedence rules in almost every programming language.  So , although unambiguous, is not the algebraic expression grammar that we need.  Instead consider:"}}], "section": {"@ids": "example-grammar-3", "@names": "example\\ grammar\\ 3", "title": "Example Grammar 3", "math_block": {"@xml:space": "preserve", "#text": "\\begin{eqnarray*}\n<exp> &::=& <trm>\\\\\n&|& <exp> + <trm> \\\\\n&|& <exp> - <trm> \\\\\n<trm> &:==& <fac> \\\\\n&|&  <trm> * <fac> \\\\\n&|&  <trm> / <fac> \\\\\n<fac> &::=& <pri> \\\\\n&|& ( <exp> ) \\\\\n<pri> &:==& A | B | C | \\ldots | X | Y | Z\n\\end{eqnarray*}"}, "paragraph": [{"title_reference": "eg1", "#text": "Note how the parse tree in the slide-show below produced by Example Grammar 3 is different from the one produced by ."}, "In particular, with Example Grammar 3, the sub-tree corresponding to the\nmultiplication operator is at a deeper level than the sub-tree for addition,\nthereby corresponding to normal operator precedence in programming\nlanguages.", "Below you have a slide-show \"producer\" for Example Grammar 3 that you can\ncontrol by entering the expression for which you want a parse tree\nproduced.  You should experiment  with producing a variety of\nslide-shows until you feel confident that you could manually construct\nthe parse tree corresponding to any possible expression.", "Once you feel confident working with parse trees, here are two\nquestions to consider before you start on the review problems for this\nmodule.", {"strong": "Question 1:", "#text": "If you are designing a grammar corresponding to expressions, what is the strategy you would employ for introducing a different level of operator precedence -- one that is either higher or lower than that of other operators?  How would this strategy play out with respect to Example Grammar 3 if you wanted to add an operator corresponding to exponentiation?"}, {"strong": "Question 2:", "title_reference": ["A+B-C", "((A+B)-C)", "(A+(B-C))"], "#text": "In Example Grammar 3, operators on the same level of precedence associate in left-to-right fashion, that is,  evaluates as the parenthesized expression .  What about the grammar dictates this left-to-right associativity?  How would you change the productions to achieve right-to-left associativity, that is, ?"}, "The review problem set for this module contains five review problems,\nthe first four of which concern themselves with how a grammar dictates\noperator precedence and associativity.  Do not start these problems\nuntil you have thought through answers to the two questions posed\nabove.", {"strong": "to get credit for the first problem,", "emphasis": "Check\nAnswer", "#text": "The first problem illustrates how grammatical structure influences the\nevaluation of arithmetic expressions, and thus the semantics of\nprograms.  Note that,  you\nmust solve it correctly three times in a row because the question is\nrandomized.  After you get the question right one time, the  button will then allow you to proceed to the next instance of\nthe question."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "parseTree3", "@long_name": "parseTree3", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "parseTree3a", "@long_name": "parseTree3a", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP3part1", "@long_name": "RP3part1", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}}, {"@ids": "rp-3-part-2", "@names": "rp\\ 3\\ part\\ 2", "title": "RP 3 part 2", "paragraph": "This problem demonstrates how grammatical structure impacts the\nassociativity property of arithmetic operators.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP3part2", "@long_name": "RP3part2", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "rp-3-part-3", "@names": "rp\\ 3\\ part\\ 3", "title": "RP 3 part 3", "paragraph": "This problem illustrates how grammatical structure impacts the\nassociativity property and order of precedence of arithmetic\noperators.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP3part3", "@long_name": "RP3part3", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "rp-3-part-4", "@names": "rp\\ 3\\ part\\ 4", "title": "RP 3 part 4", "paragraph": "This problem asks you to provide a characterization in English of the\nlanguage generated by a BNF grammar.   After you finish it, there is one more problem about Extended Backus-Naur Form, which is described before the problem.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP3part4", "@long_name": "RP3part4", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "rp-3-part-5", "@names": "rp\\ 3\\ part\\ 5", "title": "RP 3 part 5", "paragraph": [{"emphasis": ["Backus-Naur Form", "Extended Backus-Naur Form"], "#text": "The symbols we have used in our representation of grammars\ncollectively comprise what is known as  (BNF).  In\n (EBNF) we add five meta-symbols to those\nalready used in BNF notation:"}, "EBNF is used to reduce the number of productions a grammar needs to\nspecify a language.  However, it does not increase the expressive power of\ngrammars, that is, any grammatical structure that can be expressed in\nEBNF can also be expressed in BNF if one is willing to use more\nproductions.", "This last problem is about the equivalence between a given BNF grammar (the\nsame one as in part 4 above) and a smaller EBNF grammar."], "block_quote": {"enumerated_list": [{"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"title_reference": ["*", "<fn_name>", "<parameter>"], "#text": "Kleene closure operator , which means \"zero or more\" Hence if    were a non-terminal representing a valid function name and  were a non-terminal representing a valid parameter, then the EBNF notation for function calls with zero or more parameters would be"}, "math_block": {"@xml:space": "preserve", "#text": "<fn\\_name> \"(\" <parameter>* \")\""}}, {"paragraph": {"title_reference": "+", "#text": "Positive closure operator .  The EBNF notation for function calls that must have at least one parameter would be"}, "math_block": {"@xml:space": "preserve", "#text": "<fn\\_name> \"(\" <parameter>+ \")\""}}, {"paragraph": {"title_reference": ["( ; )", "<positive_number>"], "emphasis": "must", "#text": "The two paired parenthesis symbols , which are used for grouping.  For example, if  were the non-terminal denoting a valid positive number, then the following EBNF would dictate that we  have a plus or minus sign preceding a number"}}]}, {"@enumtype": "arabic", "@prefix": "", "@start": "4", "@suffix": ".", "list_item": {"paragraph": {"title_reference": "?", "#text": "The \"optional operator\" , which specifies that you can have zero or one of whatever grammatical structure precedes the operator.  For example, if our language allowed an optional plus or minus sign in front of a number, we would use the EBNF"}, "math_block": {"@xml:space": "preserve", "#text": "(+ | -)? <positive\\_number>"}}}], "block_quote": {"math_block": {"@xml:space": "preserve", "#text": "(+ | -) <positive\\_number>"}}}, "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP3part5", "@long_name": "RP3part5", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "Exercises/PL/RP3part1.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/PL/AV/parseTree3.js"}]}]}}