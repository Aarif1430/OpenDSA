{"document": {"@ids": "comparison-of-list-implementations", "@names": "comparison\\ of\\ list\\ implementations", "@source": "<string>", "@title": "Comparison of List Implementations", "title": "Comparison of List Implementations", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@ids": "space-comparison", "@names": "space\\ comparison", "title": "Space Comparison", "paragraph": ["Now that you have seen two substantially different implementations for\nlists, it is natural to ask which is better.\nIn particular, if you must implement a list for some task,\nwhich implementation should you choose?", {"title_reference": "overhead", "#text": "Given a collection of elements to store, they take up some amount of\nspace whether they are simple integers or large objects with many\nfields.\nAny container data structure like a list then requires some additional\nspace to organize the elements being stored.\nThis additional space is called ."}, {"title_reference": ["Array-based lists <array-based list>", "Linked lists <linked list>", "free store"], "math": ["\\Theta(n)", "\\Omega(n)"], "#text": "have the disadvantage\nthat their size must be predetermined before the array can be\nallocated.\nArray-based lists cannot grow beyond their predetermined size.\nWhenever the list contains only a few elements, a\nsubstantial amount of space might be tied up in a largely empty array.\nThis empty space is the overhead required by the array-based list.\n have the advantage that they only\nneed space for the objects actually on the list.\nThere is no limit to the number of elements on a linked list,\nas long as there is  memory available.\nThe amount of space required by a linked list is ,\nwhile the space required by the array-based list implementation is\n, but can be greater."}, {"literal": ["next", "next"], "#text": "Array-based lists have the advantage that there is no wasted\nspace for an individual element.\nLinked lists require that an extra pointer for the  field be\nadded to every list node.\nSo the linked list has these  pointers as overhead.\nIf the element size is small, then the overhead for\nlinks can be a significant fraction of the total storage.\nWhen the array for the array-based list is completely filled, there\nis no wasted space, and so no overhead.\nThe array-based list will then be more space efficient, by a\nconstant factor, than the linked implementation."}, {"math": ["n", "P", "E", "D", "DE", "n(P + E)", "n", "n", "n"], "title_reference": "break-even point", "#text": "A simple formula can be used to determine whether the array-based list\nor the linked list implementation will be more space efficient in a\nparticular situation.\nCall  the number of elements currently in the list,\n the size of a pointer in storage units\n(typically four bytes),  the size of a data element in\nstorage units (this could be anything, from one bit for a Boolean\nvariable on up to thousands of bytes or more for complex records),\nand  the maximum number of list elements that can be stored\nin the array.\nThe amount of space required for the array-based list is ,\nregardless of the number of elements actually stored in the list at\nany given time.\nThe amount of space required for the linked list is .\nThe smaller of these expressions for a given value \ndetermines the more space-efficient implementation for \nelements.\nIn general, the linked implementation requires less space than the\narray-based implementation when relatively few elements are in the\nlist.\nConversely, the array-based implementation becomes more space\nefficient when the array is close to full.\nUsing the equation, we can solve for  to determine the\n beyond which the array-based implementation\nis more space efficient in any particular situation.\nThis occurs when"}, {"math": ["P = E", "D/2"], "literal": ["int", "next"], "#text": "If , then the break-even point is at .\nThis would happen if the element field is either a four-byte\n value or a pointer, and the  field is a typical\nfour-byte pointer.\nThat is, the array-based implementation would be more efficient (if\nthe link field and the element field are the same size) whenever the\narray is more than half full."}, "As a rule of thumb, linked lists are more space efficient when\nimplementing lists whose number of elements varies widely or is\nunknown.\nArray-based lists are generally more space efficient when\nthe user knows in advance approximately how large the list will\nbecome, and can be confident that the list will never grow beyond a\ncertain limit."], "math_block": {"@xml:space": "preserve", "#text": "n > DE/(P + E)."}, "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "ListOverhead", "@long_name": "ListOverhead", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "time-comparison", "@names": "time\\ comparison", "title": "Time Comparison", "paragraph": [{"literal": ["next", "prev", "prev", "moveToPos"], "math": ["\\Theta(1)", "\\Theta(n)"], "#text": "Array-based lists are faster for access by position.\nPositions can easily be adjusted forwards or backwards by\nthe  and  methods.\nThese operations always take  time.\nIn contrast, singly linked lists have no explicit access to the\nprevious element, and access by position requires that we march\ndown the list from the front (or the current position) to the\nspecified position.\nBoth of these operations require  time in the average\nand worst cases, if we assume that each position on the list is\nequally likely to be accessed on any call to  or\n."}, {"literal": ["insert", "remove"], "math": ["\\Theta(1)", "\\Theta(n)"], "#text": "Given a pointer to a suitable location in the list,\nthe  and  methods for linked lists\nrequire only  time.\nArray-based lists must shift the remainder of the list up or down\nwithin the array.\nThis requires  time in the average and worst cases.\nFor many applications, the time to insert and delete elements\ndominates all other operations.\nFor this reason, linked lists are often preferred to array-based\nlists."}, {"title_reference": ["dynamic array", "amortized analysis <amortized analysis> <AmortAnal>"], "literal": "Vector", "#text": "When implementing the array-based list, an implementor could\nallow the size of the array to grow and shrink depending on the number\nof elements that are actually stored.\nThis data structure is known as a .\nFor example, both the Java and C++/STL  classes implement a\ndynamic array,\nand JavaScript arrays are always dynamic.\nDynamic arrays allow the programmer to get around the limitation on\nthe traditional array that its size cannot be changed once the array\nhas been created.\nThis also means that space need not be allocated to the dynamic array\nuntil it is to be used.\nThe disadvantage of this approach is that it takes time to deal\nwith space adjustments on the array.\nEach time the array grows in size, its contents must be copied.\nA good implementation of the dynamic array will grow and shrink\nthe array in such a way as to keep the overall cost for a series of\ninsert/delete operations relatively inexpensive, even though an\noccasional insert/delete operation might be expensive.\nA simple rule of thumb is to double the size of the array when it\nbecomes full, and to cut the array size in half when it becomes one\nquarter full.\nTo analyze the overall cost of dynamic array operations over time,\nwe need to use a technique known as\n."}], "section": {"@ids": "practice-questions", "@names": "practice\\ questions", "title": "Practice Questions", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "LLSumm", "@long_name": "LLSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}}}]}}