{"document": {"@dupnames": "calculating\\ program\\ running\\ time", "@ids": "calculating-program-running-time", "@source": "<string>", "@title": "Calculating Program Running Time", "title": "Calculating Program Running Time", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Searching/binarySearchCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/AlgAnal/BsearchDandCRecurCON.css"}], "section": [{"@dupnames": "calculating\\ program\\ running\\ time", "@ids": "id1", "title": "Calculating Program Running Time", "paragraph": ["This modules discusses the analysis for several simple code\nfragments.\nWe will make use of the algorithm analysis simplifying rules:", {"literal": ["While", "for", "if", "then", "else", "switch"], "title_reference": "n", "#text": "What about other control statements?\n loops are analyzed in a manner similar to \nloops.\nThe cost of an  statement in the worst case is the greater of\nthe costs for the  and  clauses.\nThis is also true for the average case, assuming that\nthe size of  does not affect the probability of executing one\nof the clauses (which is usually, but not necessarily, true).\nFor  statements, the worst-case cost is that of the most\nexpensive branch.\nFor subroutine calls, simply add the cost of executing the subroutine."}, {"literal": ["if", "switch", "then", "if", "if", "then", "if"], "title_reference": ["n", "1/n", "n", "amortized analysis <amortized analysis> <AmortAnal>"], "#text": "There are rare situations in which the probability for executing the\nvarious branches of an  or  statement are\nfunctions of the input size.\nFor example, for input of size , the  clause of an\n statement might be executed with probability .\nAn example would be an  statement that executes the\n clause only for the smallest of  values.\nTo perform an average-case analysis for such programs,\nwe cannot simply count the cost of the \nstatement as being the cost of the more expensive branch.\nIn such situations, the technique of\n can come to\nthe rescue."}, "Determining the execution time of a recursive\nsubroutine can be difficult.\nThe running time for a recursive subroutine is\ntypically best expressed by a recurrence relation.\nFor example, the recursive factorial function\ncalls itself with a value one less than its input value.\nThe result of this recursive call is then multiplied by the input\nvalue, which takes constant time.\nThus, the cost of the factorial function, if we wish to measure cost\nin terms of the number of multiplication operations,\nis one more than the number of multiplications made by the recursive\ncall on the smaller input.\nBecause the base case does no multiplications, its cost is zero.\nThus, the running time for this function can be expressed as", {"title_reference": "Theta(n)", "#text": "The closed-form solution for this\nrecurrence relation is ."}], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"title_reference": ["f(n)", "O(g(n))", "g(n)", "O(h(n))", "f(n)", "O(h(n))"], "#text": "If  is in  and  is in\n, then  is in ."}}, {"paragraph": {"title_reference": ["f(n)", "O(k g(n))", "k > 0", "f(n)", "O(g(n))"], "#text": "If  is in  for any constant\n, then  is in ."}}, {"paragraph": {"title_reference": ["f_1(n)", "O(g_1(n))", "f_2(n)", "O(g_2(n))", "f_1(n) + f_2(n)", "O(max(g_1(n), g_2(n)))"], "#text": "If  is in  and  is in\n, then  is in\n."}}, {"paragraph": {"title_reference": ["f_1(n)", "O(g_1(n))", "f_2(n)", "O(g_2(n))", "f_1(n) f_2(n)", "O(g_1(n) g_2(n))"], "#text": "If  is in  and  is in\n, then  is in\n."}}]}, "target": [{"@refid": "assignanal"}, {"@refid": "flanal"}], "topic": [{"@ids": "assignanal", "@names": "assignanal", "title": "Example", "paragraph": ["We begin with an analysis of a simple assignment to an integer\nvariable.", {"title_reference": "Theta(1)", "#text": "Because the assignment statement takes constant time, it is\n."}], "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}}, {"@ids": "flanal", "@names": "flanal", "title": "Example", "paragraph": [{"literal": "for", "#text": "Consider a simple  loop."}, {"title_reference": ["Theta(1)", "n", "Theta(n)", "Theta(n)"], "literal": ["for", "for"], "#text": "The first line is .\nThe  loop is repeated  times.\nThe third line takes constant time so, by simplifying rule (4),\nthe total cost for executing\nthe two lines making up the  loop is .\nBy rule (3), the cost of the entire code fragment is also\n."}], "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}}, {"title": "Example", "paragraph": [{"literal": "for", "#text": "We now analyze a code fragment with several \nloops, some of which are nested."}, {"literal": ["for", "for"], "title_reference": ["c_1", "#FLAnal", "c_2 n = Theta(n)"], "#text": "This code fragment has three separate statements: the\nfirst assignment statement and the two  loops.\nAgain the assignment statement takes constant time;\ncall it .\nThe second  loop is just like the one in\nExample  and takes  time."}, {"literal": ["for", "sum++", "for", "for"], "title_reference": ["c_3", "j", "c_3j", "n", "c_3j", "j", "j", "j", "j", "j = n", "c_3", "n"], "#text": "The first  loop is a double loop and requires a special\ntechnique.\nWe work from the inside of the loop outward.\nThe expression  requires constant time; call it\n.\nBecause the inner  loop is executed  times,\nby simplifying rule (4) it has cost .\nThe outer  loop is executed  times, but each time\nthe cost of the inner loop is different because it costs\n with  changing each time.\nYou should see that for the first execution of the outer loop,\n is 1.\nFor the second execution of the outer loop,  is 2.\nEach time through the outer loop,  becomes one greater,\nuntil the last time through the loop when .\nThus, the total cost of the loop is  times the sum of\nthe integers 1 through .\nWe know that"}, {"title_reference": ["Theta(n^2)", "Theta(c_1 + c_2 n + c_3 n^2)", "Theta(n^2)"], "#text": "which is .\nBy simplifying rule (3),  is\nsimply ."}], "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, "math_block": {"@xml:space": "preserve", "#text": "\\sum_{i = 1}^{n} i = \\frac{n (n+1)}{2},"}}, {"title": "Example", "paragraph": ["Compare the asymptotic analysis for the following two code\nfragments.", {"literal": ["for", "sum1++"], "title_reference": ["n", "n", "n^2", "sum_{j = 1}^{n} j", "{1 over 2} n^2", "Theta(n^2)"], "#text": "In the first double loop, the inner  loop always executes\n times.\nBecause the outer loop executes  times, it should be\nobvious that the statement  is executed precisely\n times.\nThe second loop is similar to the one analyzed in the previous\nexample, with cost .\nThis is approximately .\nThus, both double loops cost , though the second\nrequires about half the time of the first."}], "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}}, {"title": "Example", "paragraph": [{"literal": "for", "title_reference": "Theta(n^2)", "#text": "Not all doubly nested  loops are .\nThe following pair of nested loops illustrates this fact."}, {"title_reference": ["n", "log n+1", "k", "n", "n"], "literal": "for", "#text": "When analyzing these two code fragments, we will assume that\n is a power of two.\nThe first code fragment has its outer  loop executed\n times because on each iteration  is\nmultiplied by two until it reaches .\nBecause the inner loop always executes  times,\nthe total cost for the first code fragment can be expressed as"}, {"title_reference": ["Theta(n log n)", "k = 2^i"], "#text": "So the cost of this first double loop is .\nNote that a variable substitution takes place here to create the\nsummation, with ."}, {"title_reference": ["log n+1", "k"], "#text": "In the second code fragment, the outer loop is also executed\n times.\nThe inner loop has cost , which doubles each time.\nThe summation can be expressed as"}, {"title_reference": ["n", "k = 2^i"], "#text": "where  is assumed to be a power of two and again\n."}], "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, "math_block": [{"@xml:space": "preserve", "#text": "\\sum_{i=0}^{\\log n} n = n \\log n."}, {"@xml:space": "preserve", "#text": "\\sum_{i=0}^{\\log n} 2^i = \\Theta(n)"}]}], "raw": {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, "math_block": {"@xml:space": "preserve", "#text": "\\Theta(n) = \\Theta(n-1) + 1 \\ \\mbox{for}\\ n>1;\\ \\ T(1) = 0."}, "section": [{"@ids": "case-study-two-search-algorithms", "@names": "case\\ study:\\ two\\ search\\ algorithms", "title": "Case Study: Two Search Algorithms", "paragraph": {"title_reference": ["K", "Theta(n)", "binary search"], "#text": "The final example of algorithm analysis for this section will compare\ntwo algorithms for performing search in an array.\nEarlier, we determined that the running time for sequential search on\nan array where the search value  is equally likely to appear\nin any location is  in both the average and worst\ncases.\nWe would like to compare this running time to that required to perform\na  on an array whose values are stored in order\nfrom lowest to highest.\nHere is a visualization of the binary search method."}, "raw": {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "binarySearchCON", "@long_name": "binarySearchCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}}, {"@ids": "binary-search-practice-exercise", "@names": "binary\\ search\\ practice\\ exercise", "title": "Binary Search Practice Exercise", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "binarySearchPRO", "@long_name": "binarySearchPRO", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}}, {"@ids": "analyzing-binary-search", "@names": "analyzing\\ binary\\ search", "title": "Analyzing Binary Search", "raw": {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "BsearchDandCRecurCON", "@long_name": "BsearchDandCRecurCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, "paragraph": [{"literal": "binarySearch", "title_reference": ["K", "K", "K", "K", "K"], "#text": "Function  is designed to find the (single) occurrence of\n and return its position.\nA special value is returned if  does not appear in the array.\nThis algorithm can be modified to implement variations\nsuch as returning the position of the first\noccurrence of  in the array if multiple occurrences are\nallowed, and returning the position of the greatest value less than\n when  is not in the array."}, {"title_reference": ["n", "Theta(n)", "Theta(log n)"], "#text": "Comparing sequential search to binary search, we see that as \ngrows, the  running time for sequential search in the\naverage and worst cases quickly becomes much greater than the\n running time for binary search.\nTaken in isolation, binary search appears to be much more\nefficient than sequential search.\nThis is despite the fact that the constant factor for binary search is\ngreater than that for sequential search, because the calculation for\nthe next search position in binary search is more expensive than just\nincrementing the current position, as sequential search does."}, "Note however that the running time for sequential search will be\nroughly the same regardless of whether or not the array values are\nstored in order.\nIn contrast, binary search requires that the array values be ordered\nfrom lowest to highest.\nDepending on the context in which binary search is to be used, this\nrequirement for a sorted array could be detrimental to the running\ntime of a complete program, because  maintaining the values in sorted\norder requires a greater cost when inserting new elements into the\narray.\nThis is an example of a tradeoff between the\nadvantage of binary search during search and the disadvantage related\nto maintaining a sorted array.\nOnly in the context of the complete problem to be solved can we know\nwhether the advantage outweighs the disadvantage."]}]}, {"@ids": "summary-exercise", "@names": "summary\\ exercise", "title": "Summary Exercise", "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "AnalProgramSumm", "@long_name": "AnalProgramSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Searching/binarySearchCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/AlgAnal/BsearchDandCRecurCON.js"}]}]}}