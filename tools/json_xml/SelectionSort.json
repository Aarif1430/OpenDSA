{"document": {"@dupnames": "selection\\ sort", "@ids": "selection-sort", "@source": "<string>", "@title": "Selection Sort", "title": "Selection Sort", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Sorting/SelectionSortAnalysisCON.css"}], "section": [{"@dupnames": "selection\\ sort", "@ids": "id1", "title": "Selection Sort", "paragraph": [{"math": ["\\Theta(n^2)", "i", "i", "n-1"], "title_reference": "Selection Sort", "#text": "Consider again the problem of sorting a pile of phone bills for the\npast year.\nAnother intuitive approach might be to look through the pile until you\nfind the bill for January, and pull that out.\nThen look through the remaining pile until you find the bill for\nFebruary, and add that behind January.\nProceed through the ever-shrinking pile of bills to select the next\none in order until you are done.\nThis is the inspiration for\nour last  sort,\ncalled .\nThe 'th pass of Selection Sort \"selects\" the 'th\nlargest key in the array, placing that record at the end of the array.\nIn other words, Selection Sort first finds the largest key in an\nunsorted list, then the next largest, and so on.\nIts unique feature is that there are few record swaps.\nTo find the next-largest key value requires searching through\nthe entire unsorted portion of the array, but only one swap is\nrequired to put the record into place.\nThus, the total number of swaps required will be \n(we get the last record in place \"for free\")."}, "Here is an implementation for Selection Sort.", "Consider the example of the following array.", "Now we continue with the second pass.\nHowever, since the largest record is already at the right end,\nwe will not need to look at it again.", "Selection Sort continues in this way until the entire array is sorted.", "The following visualization puts it all together.", "Now try for yourself to see if you understand how Selection Sort works."], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "selectionsortS1CON", "@long_name": "selectionsortS1CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "selectionsortS2CON", "@long_name": "selectionsortS2CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "selectionsortAV", "@long_name": "selectionsortAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "SelsortPRO", "@long_name": "SelsortPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "selection-sort-analysis", "@names": "selection\\ sort\\ analysis", "title": "Selection Sort Analysis", "paragraph": ["Any algorithm can be written in slightly different ways.\nFor example, we could have written Selection Sort to find the smallest\nrecord, the next smallest, and so on.\nWe wrote this version of Selection Sort to mimic the behavior of our\nBubble Sort implementation as closely as possible.\nThis shows that Selection Sort is essentially a Bubble Sort\nexcept that rather than repeatedly swapping adjacent values to get\nthe next-largest record into place, we instead remember the position\nof the record to be selected and do one swap at the end.", "This visualization analyzes the number of\ncomparisons and swaps required by Selection Sort.", {"title_reference": "Figure #PointerSwap", "#text": "There is another approach to keeping the cost of swapping records low,\nand it can be used by any sorting algorithm even when the records are\nlarge.\nThis is to have each element of the array store a pointer to a record\nrather than store the record itself.\nIn this implementation, a swap operation need only exchange the\npointer values.\nThe large records do not need to move.\nThis technique is illustrated by Figure .\nAdditional space is needed to store the pointers, but the\nreturn is a faster swap operation."}, "Here are some review questions to check how well you understand\nSelection Sort."], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "SelectionSortAnalysisCON", "@long_name": "SelectionSortAnalysisCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@ids": "pointerswap", "@names": "pointerswap", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "SelsortSumm", "@long_name": "SelsortSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/selectionsortS1CON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/selectionsortS2CON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/SelectionSortAnalysisCON.js"}], "target": {"@refid": "pointerswap"}}]}}