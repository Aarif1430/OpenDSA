{"document": {"@ids": "finding-the-i-th-best-element", "@names": "finding\\ the\\ i\\ th\\ best\\ element", "@source": "<string>", "@title": "Finding the i th Best Element", "title": {"title_reference": "i", "#text": "Finding the  th Best Element"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}, {"@xml:space": "preserve", "#text": "_ MedPoset:"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "median", "@names": "median", "@xml:space": "preserve", "odsafig": "null"}], "paragraph": [{"title_reference": ["i", "i", "Figure #MedPoset", "i-1", "n-i", "n", "n/2", "i", "i"], "#text": "We now tackle the problem of finding the  th best element in\na list.\nOne solution is to sort the list and simply look\nin the  th position.\nHowever, this process provides considerably more information than we\nneed to solve the problem.\nThe minimum amount of information that we actually need to know can be\nvisualized as shown in Figure .\nThat is, all we need to know is the  items less than our\ndesired value, and the  items greater.\nWe do not care about the relative order within the upper and lower\ngroups.\nSo can we find the required information faster than by first sorting?\nLooking at the lower bound, can we tighten that beyond the\ntrivial lower bound of  comparisons?\nWe will focus on the specific question of finding the median element\n(i.e., the element with rank ), because the resulting\nalgorithm can easily be modified to find the  th largest\nvalue for any ."}, {"title_reference": ["i", "k > i", "i", "k < i", "i-k"], "#text": "Looking at the Quicksort algorithm might give us some insight into\nsolving the median problem.\nRecall that Quicksort works by selecting a pivot value, partitioning\nthe array into those elements less than the pivot and those greater\nthan the pivot, and moving the pivot to its proper location in the\narray.\nIf the pivot is in position , then we are done.\nIf not, we can solve the subproblem recursively by only considering\none of the sublists.\nThat is, if the pivot ends up in position , then we\nsimply solve by finding the  th best element in the left\npartition.\nIf the pivot is at position , then we wish to find the\n th element in the right partition."}, {"title_reference": ["O(n^2)", "mathbf{T}(n) = mathbf{T}(n/2) + n = 2n", "O(n)"], "#text": "What is the worst case cost of this algorithm?\nAs with Quicksort, we get bad performance if the pivot is the first or\nlast element in the array.\nThis would lead to possibly  performance.\nHowever, if the pivot were to always cut the array in half, then our\ncost would be modeled by the recurrence\n or \ncost."}, {"title_reference": ["mathbf{T}n", "O(n)"], "#text": "Finding the average cost requires us to use a recurrence with full\nhistory, similar to the one we used to model the cost of Quicksort.\nIf we do this, we will find that  is in\n in the average case."}, "Is it possible to modify our algorithm to get worst-case linear time?\nTo do this, we need to pick a pivot that is guaranteed to discard a\nfixed fraction of the elements.\nWe cannot just choose a pivot at random, because doing so will not meet\nthis guarantee.\nThe ideal situation would be if we could pick the median value for the\npivot each time.\nBut that is essentially the same problem that we are trying to solve\nto begin with.", {"title_reference": ["c", "n/c", "n/2c", "Figure #Median"], "#text": "Notice, however, that if we choose any constant ,\nand then if we pick the median from a sample of size ,\nthen we can guarantee that we will discard at least \nelements.\nActually, we can do better than this by selecting small subsets of a\nconstant size (so we can find the median of each in constant time),\nand then taking the median of these medians.\nFigure  illustrates this idea."}, "This observation leads directly to the following algorithm.", {"title_reference": "lceil (7n - 5)/10rceil", "#text": "While selecting the median in this way is guaranteed to eliminate a\nfraction of the elements\n(leaving at most  elements left),\nwe still need to be sure that our recursion yields a linear-time\nalgorithm.\nWe model the algorithm by the following recurrence."}, {"title_reference": ["mathbf{T}(lceil n/5 rceil)", "6lceil n/5 rceil", "mathbf{T}(lceil (7n - 5)/10rceil)"], "#text": "The  term comes from computing\nthe median of the medians-of-fives,\nthe  term comes from the cost to calculate\nthe median-of-fives (exactly six comparisons for each group of five\nelement),\nand the  term comes from\nthe recursive call of the remaining (up to) 70% of the elements that\nmight be left."}, {"title_reference": ["constructive induction", "r", "textbf{T}(n) leq rn", "n"], "#text": "We will prove that this recurrence is linear using the process of\n.\nWe assume that it is linear for some constant , and then show\nthat  for all  greater than some\nbound."}, {"title_reference": ["r geq 23", "n geq 380", "forall n geq 380, mathbf{T}(n) leq 23n"], "#text": "This is true for  and .\nThis provides a base case that allows us to use induction to prove\nthat ."}, "In reality, this algorithm is not practical\nbecause its constant factor costs are so high.\nSo much work is being done to guarantee linear time performance that\nit is more efficient on average to rely on chance to select the pivot,\nperhaps by picking it at random or picking the middle value out of the\ncurrent subarray."], "target": {"@refid": "median"}, "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": {"title_reference": "n/5", "#text": "Choose the  medians for groups of five elements from the\nlist. Choosing the median of five items can be done in constant time."}}, {"paragraph": {"title_reference": ["M", "n/5"], "#text": "Recursively, select , the median of the \nmedians-of-fives."}}, {"paragraph": {"title_reference": "M", "#text": "Partition the list into those elements larger and smaller than\n."}}]}, "math_block": [{"@xml:space": "preserve", "#text": "{\\bf T}(n) \\leq {\\bf T}(\\lceil n/5 \\rceil) +\n{\\bf T}(\\lceil (7n - 5)/10\\rceil) + 6\\lceil n/5 \\rceil + n - 1."}, {"@xml:space": "preserve", "#text": "\\begin{eqnarray*}\n\\mathbf{T}(n) &\\leq& {\\bf T}(\\lceil \\frac{n}{5} \\rceil) +\n        \\mathbf{T}(\\lceil \\frac{7n - 5}{10}\\rceil) +\n        6\\lceil \\frac{n}{5} \\rceil + n - 1\\\\\n&\\leq&r(\\frac{n}{5} + 1) + r(\\frac{7n-5}{10} + 1) + 6(\\frac{n}{5} + 1) + n - 1\\\\\n&\\leq&(\\frac{r}{5} + \\frac{7r}{10} + \\frac{11}{5})n + \\frac{3r}{2} + 5\\\\\n&\\leq&\\frac{9r + 22}{10}n + \\frac{3r + 10}{2}.\n\\end{eqnarray*}"}]}}