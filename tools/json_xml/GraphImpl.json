{"document": {"@ids": "graph-implementations", "@names": "graph\\ implementations", "@source": "<string>", "@title": "Graph Implementations", "title": "Graph Implementations", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}], "paragraph": [{"title_reference": ["graph", "adjacency matrix", "adjacency list"], "#text": "We next turn to the problem of implementing a general-purpose\n class.\nThere are two traditional approaches to representing graphs:\nThe  and the .\nIn this module we will show actual implementations for each approach.\nWe will begin with an abstract class defining an ADT for graphs that a\ngiven implementation must meet."}, {"literal": "init", "#text": "This ADT assumes that the number of vertices is fixed\nwhen the graph is created, but that edges can be added and removed.\nThe  method sets (or resets) the number of nodes in the graph,\nand creates necessary space for the adjacency matrix or adjacency list."}, {"title_reference": "n-1", "literal": ["Graph", "Graph"], "#text": "Vertices are defined by an integer index value.\nIn other words, there is a Vertex 0, Vertex 1, and so on through\nVertex .\nWe can assume that the graph's client application stores any additional\ninformation of interest about a given vertex elsewhere, such as a name\nor application-dependent value.\nNote that in a language like Java or C++, this ADT would not be\nimplemented using a language feature like a generic or template,\nbecause it is the  class users' responsibility to maintain\ninformation related to the vertices themselves.\nThe  class need have no knowledge of the type or content\nof the information associated with a vertex, only the index number for\nthat vertex."}, {"literal": ["Graph", "n", "e", "weight", "weight(0, 4)", "weight(0, 2)"], "title_reference": ["Figure #GraphTerms", "Figure #GraphTerms"], "#text": "Abstract class \nhas methods to return the number of vertices and edges\n(methods  and , respectively).\nFunction  returns the weight of a given edge, with that\nedge identified by its two incident vertices.\nFor example, calling  on the graph of\nFigure  (c) would return 4.\nIf no such edge exists, the weight is defined to be 0.\nSo calling  on the graph of\nFigure  (c) would return 0."}, {"literal": ["addEdge", "removeEdge", "addEdge", "getValue", "setValue"], "title_reference": "v", "#text": "Functions  and  add an edge (setting its\nweight) and removes an edge from the graph, respectively.\nAgain, an edge is identified by its two incident vertices.\n does not permit the user to set the weight to be 0,\nbecause this value is used to indicate a non-existent edge, nor are\nnegative edge weights permitted.\nFunctions  and  get and set, respectively,\na requested value for Vertex .\nIn our example applications the most frequent use of these methods\nwill be to indicate whether a given node has previously been visited\nin the process of the algorithm"}, {"literal": "neighbors", "#text": "Nearly every graph algorithm presented in this chapter will require\nvisits to all neighbors of a given vertex.\nThe  method returns an array containing the indices for\nthe neighboring vertices, in ascending order.\nThe following lines appear in many graph algorithms."}, {"literal": ["v", "for"], "#text": "First, an array is generated that contains the indices of the nodes\nthat can be directly reached from node .\nThe  loop then iterates through this neighbor array to execute\nsome function on each."}, {"literal": "addEdge", "#text": "It is reasonably straightforward to implement our graph ADT\nusing either the adjacency list or adjacency matrix.\nThe sample implementations presented here do not address the issue of\nhow the graph is actually created.\nThe user of these implementations must add functionality for\nthis purpose, perhaps reading the graph description from a file.\nThe graph can be built up by using the  function\nprovided by the ADT."}, "Here is an implementation for the adjacency matrix.", {"literal": ["nodeValues", "setValue", "getValue"], "title_reference": ["n times n", "n", "(i, j)", "(i, j)", "(i, j)", "i", "j"], "#text": "Array  stores the information manipulated by the\n and  functions.\nThe edge matrix is implemented as an integer array of size\n for a graph of  vertices.\nPosition  in the matrix stores the weight for edge\n if it exists.\nA weight of zero for edge  is used to indicate that no\nedge connects Vertices  and ."}, {"title_reference": ["v", "v"], "literal": ["neighbors", "v", "addEdge", "removeEdge", "weight"], "#text": "Given a vertex , the  method scans through row\n of the matix to locate the positions of the various neighbors.\nIf no edge is incident on , then returned neighbor array will\nhave length 0.\nFunctions  and  adjust the\nappropriate value in the array.\nFunction  returns the value stored in the\nappropriate position in the array."}, {"literal": "Edge", "#text": "Here is an implementation of the adjacency list representation for\ngraphs.\nIts main data structure is an array of linked lists, one linked list\nfor each vertex.\nThese linked lists store objects of type , which merely\nstores the index for the vertex pointed to by the edge, along with the\nweight of the edge."}, {"literal": ["Graphl", "addEdge", "removeEdge", "weight"], "title_reference": "v", "#text": "Implementation for  member functions is straightforward\nin principle, with the key functions being ,\n, and .\nThey simply start at the beginning of the adjacency list and move\nalong it until the desired vertex has been found.\nPrivate method find is a utility for finding the last edge preceding\nthe one that holds vertex  if that exists."}]}}