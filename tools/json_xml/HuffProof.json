{"document": {"@dupnames": "proof\\ of\\ optimality\\ for\\ huffman\\ coding", "@ids": "proof-of-optimality-for-huffman-coding", "@source": "<string>", "@title": "Proof of Optimality for Huffman Coding", "title": "Proof of Optimality for Huffman Coding", "subtitle": {"@dupnames": "proof\\ of\\ optimality\\ for\\ huffman\\ coding", "@ids": "id1", "#text": "Proof of Optimality for Huffman Coding"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Binary/HuffProofCON.css"}, {"@format": "xml", "@ids": "hproof", "@names": "hproof", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "HuffProofCON", "@long_name": "HuffProofCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/HuffProofCON.js"}], "paragraph": [{"title_reference": "greedy algorithm", "#text": "Huffman tree building is an example of a\n.\nAt each step, the algorithm makes a \"greedy\" decision to merge\nthe two subtrees with least weight.\nThis makes the algorithm simple, but does it give the desired result?\nThis section concludes with a proof that the Huffman tree\nindeed gives the most efficient arrangement for the set of letters.\nThe proof requires the following lemma."}, {"strong": "Lemma:", "literal": "buildHuff", "#text": "For any Huffman tree built by function  containing at\nleast two letters, the two letters with least frequency are stored\nin sibling nodes whose depth is at least as deep as any other leaf\nnodes in the tree."}, {"strong": "Proof:", "title_reference": ["l_1", "l_2", "l_1", "l_2", "Figure #HProof", "l_1", "l_2", "V", "X", "V", "X", "U", "l_1", "l_2"], "literal": ["buildHuff", "buildHuff"], "#text": "Call the two letters with least frequency \nand .\nThey must be siblings because \nselects them in the first step of the construction process.\nAssume that  and  are\nnot the deepest nodes in the tree.\nIn this case, the Huffman tree must either look as shown in\nFigure , or effectively symmetrical to\nthis.\nFor this situation to occur, the parent of \nand ,\nlabeled , must have greater weight than the node\nlabeled .\nOtherwise, function  would have selected node\n in place of node  as the child of node\n.\nHowever, this is impossible because  and\n are the letters with least frequency."}, "Here is the proof."], "target": {"@refid": "hproof"}, "block_quote": {"paragraph": [{"strong": "Theorem:", "literal": "buildHuff", "#text": "Function  builds the Huffman tree with the minimum\nexternal path weight for the given set of letters."}, {"strong": "Proof:", "title_reference": "n", "#text": "The proof is by induction on , the number of letters."}, {"literal": "buildHuff", "#text": "Thus by mathematical induction, function  creates\nthe Huffman tree with minimum external path length."}], "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": {"strong": "Base Case:", "title_reference": "n = 2", "#text": "For , the Huffman tree must have the\nminimum external path weight because there are only two possible\ntrees, each with identical weighted path lengths for the two\nleaves."}}, {"paragraph": {"strong": "Induction Hypothesis:", "literal": "buildHuff", "title_reference": "n-1", "#text": "Assume that any tree created by\n that contains  leaves has minimum\nexternal path length."}}, {"paragraph": {"strong": "Induction Step:", "title_reference": ["mathbf{T}", "n", "n geq 2", "w_1 leq w_2 leq ... leq w_n", "w_1", "w_n", "V", "w_1", "w_2", "w_1", "w_2", "mathbf{T}", "w_1", "w_2", "mathbf{T}'", "mathbf{T}", "V", "V'", "w_1 + w_2", "mathbf{T}'", "V'", "mathbf{T}"], "literal": "buildHuff", "#text": "Given a Huffman tree \nbuilt by  with  leaves,\n, suppose that\n where\n to  are the weights of the letters.\nCall  the parent of the letters with frequencies\n and .\nFrom the lemma, we know that the leaf nodes containing the\nletters with frequencies  and  are as\ndeep as any nodes in .\nIf any other leaf nodes in the tree were deeper, we could reduce\ntheir weighted path length by swapping them with  or\n.\nBut the lemma tells us that no such deeper nodes exist.\nCall  the Huffman tree that is\nidentical to  except that node  is\nreplaced with a leaf node  whose weight is\n.\nBy the induction hypothesis,  has minimum\nexternal path length.\nReturning the children to  restores tree\n, which must also have minimum external path\nlength."}}]}}}}