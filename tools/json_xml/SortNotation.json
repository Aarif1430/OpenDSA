{"document": {"@dupnames": "sorting\\ terminology\\ and\\ notation", "@ids": "sorting-terminology-and-notation", "@source": "<string>", "@title": "Sorting Terminology and Notation", "title": "Sorting Terminology and Notation", "subtitle": {"@dupnames": "sorting\\ terminology\\ and\\ notation", "@ids": "id1", "#text": "Sorting Terminology and Notation"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "SortIntroSumm", "@long_name": "SortIntroSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "paragraph": [{"math": ["r_1", "r_2", "r_n", "k_1", "k_2", "k_n", "s", "r_{s_1}", "r_{s_2}", "r_{s_n}", "k_{s_1} \\leq k_{s_2} \\leq ... \\leq k_{s_n}"], "title_reference": "Sorting Problem", "#text": "Given a set of records , , ..., \nwith associated key values , , ..., ,\nthe  is to\narrange the records into any order  such that records\n, , ..., \nhave keys obeying the property\n.\nIn other words, the sorting problem is to arrange a set of records so\nthat the values of their key fields are in non-decreasing order."}, "As defined, the Sorting Problem allows input with two or more\nrecords that have the same key value.\nCertain applications require that input not contain\nduplicate key values.\nTypically, sorting algorithms can handle duplicate key values unless\nnoted otherwise.", {"title_reference": "stable", "#text": "When duplicate key values are allowed, there might be an implicit\nordering to the duplicates, typically based on their order of\noccurrence within the input.\nIt might be desirable to maintain this initial ordering among\nduplicates.\nA sorting algorithm is said to be  if it does not\nchange the relative ordering of records with identical key values.\nMany, but not all, of the sorting algorithms presented in this chapter\nare stable, or can be made stable with minor changes."}, {"title_reference": "empirical comparison <empirical comparison> <SortingEmpirical>", "#text": "When comparing two sorting algorithms, the simplest approach would be to\nprogram both and measure their running times.\nThis is an example of\n.\nHowever, doing fair empirical comparisons can be tricky because\nthe running time for many sorting algorithms depends on specifics of\nthe input values.\nThe number of records, the size of the keys and the records,\nthe allowable range of the key values, and the amount\nby which the input records are \"out of order\" can all greatly affect\nthe relative running times for sorting algorithms."}, "When analyzing sorting algorithms, it is traditional to measure the\ncost by counting the number of comparisons made between keys.\nThis measure is usually closely related to the actual running time for\nthe algorithm and has the advantage of being machine and data-type\nindependent.\nHowever, in some cases records might be so large that their physical\nmovement might take a significant fraction of the total running time.\nIf so, it might be appropriate to measure the cost by counting the\nnumber of swap operations performed by the algorithm.\nIn most applications we can assume that all records and keys are of\nfixed length, and that a single comparison or a single swap operation\nrequires a constant amount of time regardless of which keys are\ninvolved.\nHowever, some special situations \"change the rules\" for comparing\nsorting algorithms.\nFor example, an application with records or keys having widely\nvarying length (such as sorting a sequence of variable length strings)\ncannot expect all comparisons to cost roughly the same.\nNot only do such situations require special measures for analysis,\nthey also will usually benefit from a special-purpose sorting\ntechnique.", "Other applications require that a small number of records be\nsorted, but that the sort be performed frequently.\nAn example would be an application that repeatedly sorts groups of\nfive numbers.\nIn such cases, the constants in the runtime equations that usually\nget ignored in asymptotic analysis now become crucial.\nNote that recursive sorting algorithms end up sorting lots of small\nlists as well.", "Finally, some situations require that a sorting algorithm use as\nlittle memory as possible.\nWe will call attention to sorting algorithms that require significant\nextra memory beyond the input array."]}}