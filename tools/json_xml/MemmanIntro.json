{"document": {"@ids": "chapter-introduction-memory-management", "@names": "chapter\\ introduction:\\ memory\\ management", "@source": "<string>", "@title": "Chapter Introduction: Memory Management", "title": "Chapter Introduction: Memory Management", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}], "paragraph": [{"literal": "new", "#text": "Most data structures are designed to store and access objects of\nuniform size.\nA typical example would be an integer stored in a list or a queue.\nSome applications require the ability to store variable-length records,\nsuch as a string of arbitrary length.\nOne solution is to store in list or queue a bunch of pointers to\nstrings, where each pointer is pointing to space of whatever size is\nnecessary to old that string.\nThis is fine for data structures stored in main memory.\nBut if the collection of strings is meant to be stored on disk, then\nwe might need to worry about how exactly these strings are stored.\nAnd even when stored in main memory, something has to figure out where\nthere are available bytes to hold the string.\nIn a language like C++ or Java, programmers can allocate space as\nnecessary (either explicitly with  or implicitly with a\nvariable declaration).\nWhere does this space come from?\nThis section discusses memory management techniques for the general\nproblem of handling space requests of variable size."}, {"title_reference": ["memory pool", "memory manager", "memory allocation", "handle", "memory deallocation"], "#text": "The basic model for memory management is that we have a (large)\nblock of contiguous memory locations, which we will call the\n.\nPeriodically, memory requests are issued for some amount of space in\nthe pool.\nA  has the job of finding a contiguous block of\nlocations of at least the requested size from somewhere within the\nmemory pool.\nHonoring such a request is called\n.\nThe memory manager will typically return some piece of information\nthat the requestor can hold on to so that later it can recover the\ndata that were just stored by the memory manager.\nThis piece of information is called a .\nAt some point, space that has been requested might no longer be needed,\nand this space can be returned to the memory manager so that it can be\nreused.\nThis is called a .\nWe can define an ADT for a simple memory manager for storing variable\nlength arrays of integers as follows."}, {"literal": ["MemManager", "info", "receipt", "MemHandle", "MemHandle"], "#text": "The user of the  ADT provides a pointer\n(in parameter ) to space that\nholds some message to be stored or retrieved.\nThis is similar to the C++ basic file read/write methods.\nThe fundamental idea is that the client gives messages to the memory\nmanager for safe keeping.\nThe memory manager returns a  for the message in the form\nof a  object.\nThe client holds the  until it wishes to get the\nmessage back."}, {"literal": ["insert", "getRecord", "release"], "#text": "Method  lets the client tell the memory manager the\nlength and contents of the message to be stored.\nThis ADT assumes that the memory manager will remember the length of\nthe message associated with a given handle, thus method\n does not include a length parameter but instead\nreturns the message actually stored.\nMethod  allows the client to tell the memory\nmanager to release the space that stores a given message."}, {"title_reference": "dynamic memory allocation", "literal": ["new", "delete"], "#text": "When all inserts and releases follow a simple pattern, such as last\nrequested, first released (stack order), or first requested, first\nreleased (queue order), memory management is fairly easy.\nWe are concerned here with the general case where blocks\nof any size might be requested and released in any order.\nThis is known as .\nOne example of dynamic memory allocation is managing free store for a\ncompiler's runtime environment, such as the system-level\n and  operations in C++.\nAnother example is managing main memory in a multitasking operating\nsystem.\nHere, a program might require a certain amount of space, and the\nmemory manager must keep track of which programs are using which parts\nof the main memory.\nYet another example is the file manager for a disk drive.\nWhen a disk file is created, expanded, or deleted, the file manager\nmust allocate or deallocate disk space."}, {"title_reference": "heap", "#text": "A block of memory or disk space managed in this way is sometimes\nreferred to as a .\nThe term \"heap\" is being used here in a different way\nthan the heap data structure typically used to implement a priority\nqueue.\nHere \"heap\" refers to the memory controlled by a dynamic memory\nmanagement scheme."}, "In the rest of this chapter, we first study techniques for dynamic\nmemory management.\nWe then tackle the issue of what to do when no single block\nof memory in the memory pool is large enough to honor a given request."]}}