{"document": {"@ids": "implementing-recursion", "@names": "implementing\\ recursion", "@source": "<string>", "@title": "Implementing Recursion", "title": "Implementing Recursion", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@ids": "recurstack", "@names": "recurstack", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}], "paragraph": [{"title_reference": "recursive <recursion> <Recursion>", "emphasis": "how", "#text": "WARNING! You should not read this section unless you are already\ncomfortable with implementing \nfunctions.\nOne of the biggest hang-ups for students learning recursion is too\nmuch focus on the recursive \"process\".\nThe right way to think about recursion is to just think about the\nreturn value that the recursive call gives back.\nThinking about  that answer is computed just gets in the way of\nunderstanding.\nThere are good reasons to understand how recursion is implemented,\nbut helping you to write recursive functions is not one of them."}, {"title_reference": ["stacks <stack> <StackArray>", "runtime environments <runtime environment>", "pushing <push>", "activation record", "pops <pop>"], "#text": "Perhaps the most common computer application that uses\n is not even visible to its users.\nThis is the implementation of subroutine calls in most programming\nlanguage .\nA subroutine call is normally implemented by \nnecessary information about the subroutine (including the return\naddress, parameters, and local variables) onto a stack.\nThis information is called an .\nFurther subroutine calls add to the stack.\nEach return from a subroutine  the top activation\nrecord off the stack.\nAs an example, here is a recursive implementation for the factorial\nfunction."}, "Here is an illustration for how the internal processing works.", {"title_reference": "beta", "literal": ["fact", "n", "fact"], "#text": "values indicate the address of the program instruction\nto return to after completing the current function call.\nOn each recursive function call to , both the return\naddress and the current value of  must be saved.\nEach return from  pops the top activation record off the\nstack."}, {"literal": ["fact", "fact", "fact", "fact", "fact"], "title_reference": ["beta", "beta", "beta_1", "beta_1", "n"], "#text": "Consider what happens when we call  with the value 4.\nWe use  to indicate the address of the program\ninstruction where the call to  is made.\nThus, the stack must first store the address , and the\nvalue 4 is passed to .\nNext, a recursive call to  is made, this time with value 3.\nWe will name the program address from which the call is\nmade .\nThe address , along with the current value for\n (which is 4), is saved on the stack.\nFunction  is invoked with input parameter 3."}, {"title_reference": ["beta_2", "n", "beta_3"], "#text": "In similar manner, another recursive call is made with input\nparameter 2, requiring that the address from which the call is made\n(say ) and the current value for  (which is 3)\nare stored on the stack.\nA final recursive call with input parameter 1 is made, requiring that\nthe stack store the calling address (say ) and current\nvalue (which is 2)."}, {"literal": ["fact", "fact", "fact"], "title_reference": ["n", "n"], "#text": "At this point, we have reached the base case for , and so\nthe recursion begins to unwind.\nEach return from  involves popping the stored value for\n from the stack, along with the return address from the\nfunction call.\nThe return value for  is multiplied by the restored value\nfor , and the result is returned."}, "Because an activation record must be created and placed onto the stack\nfor each subroutine call, making subroutine calls is a relatively\nexpensive operation.\nWhile recursion is often used to make implementation easy and clear,\nsometimes you might want to eliminate the overhead imposed by the\nrecursive function calls.\nIn some cases, such as the factorial function above,\nrecursion can easily be replaced by iteration.", {"title_reference": ["traversing a binary tree <traversal> <BinaryTreeTraversal>", "Mergesort <Mergesort> <Mergesort>", "Quicksort <Quicksort> <Quicksort>"], "#text": "An iterative form of the factorial function is both\nsimpler and faster than the version shown in the example.\nBut it is not always possible to replace recursion with iteration.\nRecursion, or some imitation of it, is necessary when implementing\nalgorithms that require multiple branching such as in the Towers of\nHanoi algorithm, or when\n.\nThe  and\n sorting algorithms\nalso require recursion.\nFortunately, it is always possible to imitate recursion with a stack.\nLet us now turn to a non-recursive version of the Towers of\nHanoi function, which cannot be done iteratively."}, {"title_reference": "Quicksort <Quicksort> <Quicksort>", "#text": "Recursive algorithms lend themselves to efficient implementation with\na stack when the amount of information needed to describe a\nsub-problem is small.\nFor example,  can effectively\nuse a stack to replace its recursion since only bounds information for\nthe subarray to be processed needs to be saved."}], "target": [{"@refid": "recurstack"}, {"@refid": "stackfact"}], "topic": [{"@ids": "stackfact", "@names": "stackfact", "title": "Example", "paragraph": ["As a simple example of replacing recursion with a stack, consider\nthe following non-recursive version of the factorial function.", {"title_reference": "n", "#text": "Here, we simply push successively smaller values of  onto\nthe stack until the base case is reached, then repeatedly pop off\nthe stored values and multiply them into the result."}], "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}}, {"title": "Example", "paragraph": ["Here is a recursive implementation for Towers of Hanoi.", {"literal": ["TOH", "TOH"], "title_reference": ["n-1", "n-1"], "#text": "makes two recursive calls:\none to move  rings off the bottom ring, and another to\nmove these  rings back to the goal pole.\nWe can eliminate the recursion by using a stack to store a\nrepresentation of the three operations that  must perform:\ntwo recursive calls and a move operation.\nTo do so, we must first come up with a representation of the\nvarious operations, implemented as a class whose objects will be\nstored on the stack."}, {"literal": ["move", "TOH", "TOHobj"], "#text": "We first enumerate the possible operations MOVE and TOH, to\nindicate calls to the  function\nand recursive calls to , respectively.\nClass  stores five values: an operation value\n(indicating either a MOVE or a new TOH operation), the number of\nrings, and the three poles.\nNote that the move operation actually needs only to store\ninformation about two poles.\nThus, there are two constructors: one to store the state when\nimitating a recursive call, and one to store the state for a move\noperation."}, {"title_reference": ["2n+1", "n", "n>0"], "literal": ["TOH", "while", "TOH"], "#text": "An array-based stack is used because we know that the stack\nwill need to store exactly  elements.\nThe new version of  begins by placing on the stack a\ndescription of the initial problem for  rings.\nThe rest of the function is simply a  loop that pops the\nstack and executes the appropriate operation.\nIn the case of a  operation (for ), we store on\nthe stack representations for the three operations executed by the\nrecursive version.\nHowever, these operations must be placed on the stack in reverse\norder, so that they will be popped off in the correct order."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}]}]}}