<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="linked\ lists" ids="linked-lists" source="&lt;string&gt;" title="Linked Lists"><title>Linked Lists</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/List/llistCON.css</odsalink></raw><section dupnames="linked\ lists" ids="id1"><title>Linked Lists</title><paragraph>In this module we present one of the two traditional implementations
for lists, usually called a <title_reference>linked list</title_reference>.
The linked list uses <title_reference>dynamic memory allocation</title_reference>,
that is, it allocates memory for new list elements as needed.
The following diagram illustrates the linked list concept.
Here there are three <title_reference>nodes &lt;node&gt;</title_reference> that
are "linked" together.
Each node has two boxes.
The box on the right holds a link to the next node in the list.
Notice that the rightmost node has a diagonal slash through its link
box, signifying that there is no link coming out of this box.</paragraph><target refid="linkedlistnodes"></target><raw format="xml" ids="linkedlistnodes" names="linkedlistnodes" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="llistRepCON"
    long_name="llistRepCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Because a list node is a distinct object (as opposed to simply a cell
in an array), it is good practice to make a separate list node class.
(We can also re-use the list node class to implement linked
implementations for the <title_reference>stack &lt;stack&gt; &lt;Stack&gt;</title_reference> and
<title_reference>queue &lt;queue&gt; &lt;Queue&gt;</title_reference> data structures.
Here is an implementation for list nodes, called the <literal>Link</literal> class.
Objects in the <literal>Link</literal> class contain an <literal>element</literal> field to
store the element value, and a <literal>next</literal> field to store a pointer to
the next node on the list.
The list built from such nodes is called a <title_reference>singly linked list</title_reference>,
or a <title_reference>one-way list</title_reference>, because each list node
has a single pointer to the next node on the list.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>The <literal>Link</literal> class is quite simple.
There are two forms for its constructor, one with
an initial element value and one without.
Member functions allow the link user to get or set the <literal>element</literal>
and <literal>link</literal> fields.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="llistBadCON"
    long_name="llistBadCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><section ids="why-this-has-problems" names="why\ this\ has\ problems"><title>Why This Has Problems</title><paragraph>There are a number of problems with the representation just
described.
First, there are lots of special cases to code for.
For example, when the list is empty we have
no element for <literal>head</literal>, <literal>tail</literal>, and <literal>curr</literal> to point to.
Implementing special cases for <literal>insert</literal> and <literal>remove</literal>
increases code complexity, making it harder to understand,
and thus increases the chance of introducing bugs.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="llistBadDelCON"
    long_name="llistBadDelCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></section><section ids="a-better-solution" names="a\ better\ solution"><title>A Better Solution</title><paragraph>Fortunately, there is a fairly easy way to deal with all of the
special cases, as well as the problem with deleting the last node.
Many special cases can be eliminated by implementing
linked lists with an additional <title_reference>header node</title_reference>
as the first node of the list.
This header node is a link node like any other, but its value is
ignored and it is not considered to be an actual element of the list.
The header node saves coding effort because we no longer need to
consider special cases for empty lists or when the current position is
at one end of the list.
The cost of this simplification is the space for the header node.
However, there are space savings due to smaller code size,
because statements to handle the special cases are omitted.
We get rid of the remaining special cases related to being at the end
of the list by adding a "trailer" node that also never stores a
value.</paragraph><paragraph>The following diagram shows initial conditions for a linked list
with header and trailer nodes.</paragraph><target refid="linkedlistinit"></target><raw format="xml" ids="linkedlistinit" names="linkedlistinit" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="llistInitCON"
    long_name="llistInitCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Here is what a list with some elements looks like with the header and
trailer nodes added.</paragraph><target refid="linkedlisttailer"></target><raw format="xml" ids="linkedlisttailer" names="linkedlisttailer" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="llistHeaderCON"
    long_name="llistHeaderCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Adding the trailer node also solves our problem with deleting the last
node on the list, as we will see when we take a closer look at the
remove method's implementation.</paragraph></section></section><section ids="linked-list-implementation" names="linked\ list\ implementation"><title>Linked List Implementation</title><paragraph>Here is the implementation for the linked list class,
named <literal>LList</literal>.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="llistVarsCON"
    long_name="llistVarsCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="llistConsCON"
    long_name="llistConsCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="llistInsertCON"
    long_name="llistInsertCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Here are some special cases for linked list insertion: Inserting at
the end, and inserting to an empty list.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="llistSpecialCON"
    long_name="llistSpecialCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="LlistInsertPRO"
    long_name="LlistInsertPRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="linked-list-remove" names="linked\ list\ remove"><title>Linked List Remove</title><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="llistRemoveCON"
    long_name="llistRemoveCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="LlistRemovePRO"
    long_name="LlistRemovePRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="llistOtherCON"
    long_name="llistOtherCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Implementations for the remaining operations each require
<title_reference>Theta(1)</title_reference> time.</paragraph><raw format="xml" xml:space="preserve"><odsascript>AV/List/llist.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/llistRepCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/llistBadCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/llistBadDelCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/llistInitCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/llistHeaderCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/llistVarsCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/llistConsCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/llistInsertCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/llistSpecialCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/llistRemoveCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/llistOtherCON.js</odsascript></raw></section></document>