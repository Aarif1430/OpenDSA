{"document": {"@dupnames": "sequential-fit\\ methods", "@ids": "sequential-fit-methods", "@source": "<string>", "@title": "Sequential-Fit Methods", "title": "Sequential-Fit Methods", "subtitle": {"@dupnames": "sequential-fit\\ methods", "@ids": "id1", "#text": "Sequential-Fit Methods"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/MemManage/seqFitCON.css"}, {"@format": "xml", "@ids": "freeblck", "@names": "freeblck", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "seqFitCON", "@long_name": "seqFitCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@ids": "memtags", "@names": "memtags", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "memex", "@names": "memex", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/MemManage/seqFitCON.js"}], "paragraph": ["Sequential-fit methods attempt to find a \"good\" block to service\na storage request.\nThe three sequential-fit methods described here assume that the free\nblocks are organized into a doubly linked list, as illustrated by\nthis figure.", "There are two basic approaches to implementing the freelist.\nThe simpler approach is to store the freelist separately from the\nmemory pool.\nIn other words, a simple linked-list implementation\ncan be used, where each node of the linked list\ncontains a pointer to a single free block in the memory pool.\nThis is fine if there is space available for the linked list itself,\nseparate from the memory pool.", {"title_reference": ["m", "m"], "#text": "The second approach to storing the freelist is more complicated but\nsaves space.\nBecause the free space is free, it can be used by the memory manager to\nhelp it do its job; that is, the memory manager temporarily\n\"borrows\" space within the free blocks to maintain its doubly\nlinked list.\nTo do so, each unallocated block must be large enough to hold these\npointers.\nIn addition, it is usually worthwhile to let the memory manager add a\nfew bytes of space to each reserved block for its own purposes.\nIn other words, a request for  bytes of space might result in\nslightly more than  bytes being allocated by the memory\nmanager, with the extra bytes used by the memory manager itself rather\nthan the requester.\nWe will assume that all memory blocks are organized as shown in\nthe figure below, with space for tags and linked list pointers.\nHere, free and reserved blocks are distinguished by a tag bit at both\nthe beginning and the end of the block, for reasons that will be\nexplained.\nIn addition, both free and reserved blocks have a size indicator\nimmediately after the tag bit at the beginning of the block to\nindicate how large the block is.\nFree blocks have a second size indicator immediately preceding the tag\nbit at the end of the block.\nFinally, free blocks have left and right pointers to their neighbors\nin the free block list."}, {"title_reference": ["m", "m", "k", "k - m"], "#text": "The information fields associated with each block permit the memory\nmanager to allocate and deallocate blocks as needed.\nWhen a request comes in for  words of storage, the memory\nmanager searches the linked list of free blocks until it finds a\n\"suitable\" block for allocation.\nHow it determines which block is suitable will be discussed below.\nIf the block contains exactly  words (plus space for the tag\nand size fields), then it is removed from the freelist.\nIf the block (of size ) is large enough,\nthen the remaining  words are reserved as a block on the\nfreelist, in the current location."}, {"title_reference": ["F", "F", "P", "P", "P", "P", "F", "P", "F", "F", "S", "S", "F"], "#text": "When a block  is freed, it must be merged into the freelist.\nIf we do not care about merging adjacent free blocks, then this\nis a simple insertion into the doubly linked list of free blocks.\nHowever, we would like to merge adjacent blocks, because\nthis allows the memory manager to serve requests of the largest\npossible size.\nMerging is easily done due to the tag and size fields stored at the\nends of each block, as illustrated by the figure below.\nHere, the memory manager first checks the unit of memory immediately\npreceding block  to see if the preceding block (call\nit ) is also free.\nIf it is, then the memory unit before  's tag bit stores\nthe size of , thus indicating the position for the beginning\nof the block in memory.\n can then simply have its size extended to include\nblock .\nIf block  is not free, then we just add block  to\nthe freelist.\nFinally, we also check the bit following the end of block .\nIf this bit indicates that the following block (call it ) is\nfree, then  is removed from the freelist and the size\nof  is extended appropriately."}, "We now consider how a \"suitable\" free block is selected to service a\nmemory request.\nTo illustrate the process, assume that we have a memory pool with 200\nunits of storage. After some series of allocation requests and releases,\nwe have reached a point where there are four free blocks\non the freelist of sizes 25, 35, 32, and 45 (in that order).\nAssume that a request is made for 30 units of storage.\nFor our examples, we ignore the overhead imposed for the tag, link,\nand size fields discussed above."], "target": [{"@refid": "freeblck"}, {"@refid": "memtags"}, {"@refid": "memex"}]}}