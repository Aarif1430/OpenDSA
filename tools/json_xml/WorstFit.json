{"document": {"@dupnames": "worst\\ fit", "@ids": "worst-fit", "@source": "<string>", "@title": "Worst Fit", "title": "Worst Fit", "subtitle": {"@dupnames": "worst\\ fit", "@ids": "id1", "#text": "Worst Fit"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "firstFitAV", "@long_name": "firstFitAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}], "paragraph": {"title_reference": "worst fit", "#text": "A strategy contrary to best fit might make sense because it tends to\nminimize the effects of external fragmentation.\nThis is called , which always allocates the largest\nblock on the list hoping that the remainder of the block will be\nuseful for servicing a future request.\nIn our example, the worst fit is the block of size 45, leaving a\nremainder of size 15.\nIf there are a few unusually large requests, this approach\nwill have less chance of servicing them.\nIf requests generally tend to be of the same size, then this might be\nan effective strategy.\nLike best fit, worst fit requires searching the entire freelist at\neach memory request to find the largest block.\nAlternatively, the freelist can be ordered from largest to smallest\nfree block, possibly by using a priority queue implementation."}}}