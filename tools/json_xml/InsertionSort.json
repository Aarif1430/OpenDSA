{"document": {"@dupnames": "insertion\\ sort", "@ids": "insertion-sort", "@source": "<string>", "@title": "Insertion Sort", "title": "Insertion Sort", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Sorting/InsertionSortWorstCaseCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Sorting/InsertionSortBestCaseCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Sorting/InsertionSortAverageCaseCON.css"}], "section": [{"@dupnames": "insertion\\ sort", "@ids": "id1", "title": "Insertion Sort", "paragraph": [{"title_reference": "Insertion Sort", "#text": "What would you do if you have a stack of phone bills from the past\ntwo years and you want to order by date?\nA fairly natural way to handle this is to look at the first two\nbills and put them in order.\nThen take the third bill and put it into the right position with\nrespect to the first two, and so on.\nAs you take each bill, you would add it to the sorted pile that you\nhave already made.\nThis simple approach is the inspiration for\nour first sorting algorithm, called ."}, {"literal": "A", "title_reference": "n", "#text": "Insertion Sort iterates through a list of records.\nFor each iteration, the current record is inserted in turn at the\ncorrect position within a sorted list composed of those records\nalready processed.\nHere is an implementation.\nThe input is an array named  that stores  records."}, {"@ids": "practice", "@names": "practice", "title_reference": ["key", "have a way <comparable> <Comparison>", "comparable"], "#text": "(Note that to make the explanation for these sorting algorithms as\nsimple as possible, our visualizations will show the array as though\nit stored simple integers rather than more complex records.\nBut you should realize that in practice, there is rarely any point\nto sorting an array of simple integers.\nNearly always we want to sort more complex records that each have a\n value.\nIn such cases we must  to\nassociate a key value with a record.\nThe sorting algorithms will simply assume that the records are\n.)"}, "Here we see the first few iterations of Insertion Sort.", {"title_reference": ["x", "x"], "literal": "inssort", "#text": "This continues on with each record in turn.\nCall the current record .\nInsertion Sort will move it to the left so\nlong as its value is less than that of the record immediately\npreceding it.\nAs soon as a key value less than or equal to  is\nencountered,  is done with that record because all\nrecords to its left in the array must have smaller keys."}], "target": [{"@refid": "introduction"}, {"@refid": "practice"}], "raw": [{"@format": "xml", "@ids": "introduction", "@names": "introduction", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "insertionsortCON", "@long_name": "insertionsortCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "insertionsortAV", "@long_name": "insertionsortAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "InssortPRO", "@long_name": "InssortPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "insertion-sort-analysis", "@names": "insertion\\ sort\\ analysis", "title": "Insertion Sort Analysis", "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "InsertionSortWorstCaseCON", "@long_name": "InsertionSortWorstCaseCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "InsertionSortBestCaseCON", "@long_name": "InsertionSortBestCaseCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "InsertionSortAverageCaseCON", "@long_name": "InsertionSortAverageCaseCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "InssortSumm", "@long_name": "InssortSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/insertionsortCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/InsertionSortWorstCaseCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/InsertionSortBestCaseCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/InsertionSortAverageCaseCON.js"}], "line_block": [{"line": null}, {"line": null}], "paragraph": [{"title_reference": ["Shellsort <Shellsort> <Shellsort>", "Quicksort <Quicksort> <Quicksort>"], "#text": "While the best case is significantly faster than the average and worst\ncases, the average and worst cases are usually more reliable\nindicators of the \"typical\" running time.\nHowever, there are situations where we can expect the input to be in\nsorted or nearly sorted order.\nOne example is when an already sorted list is slightly disordered by a\nsmall number of additions to the list;\nrestoring sorted order using Insertion Sort might be a good idea if we\nknow that the disordering is slight.\nAnd even when the input is not perfectly sorted, Insertion Sort's cost\ngoes up in proportion to the number of inversions.\nSo a \"nearly sorted\" list will always be cheap to sort with Insertion\nSort.\nExamples of algorithms that take advantage of Insertion Sort's\nnear-best-case running time are\n\nand ."}, {"literal": ["for", "for"], "title_reference": ["n-1", "Theta(n^2)"], "#text": "Counting comparisons or swaps yields similar results.\nEach time through the inner  loop yields both a\ncomparison and a swap, except the last (i.e., the comparison that\nfails the inner  loop's test), which has no swap.\nThus, the number of swaps for the entire sort operation is\n less than the number of comparisons.\nThis is 0 in the best case, and  in the\naverage and worst cases."}, {"title_reference": "Theta(n^2)", "#text": "Later we will see algorithms whose growth rate is much\nbetter than .\nThus for larger arrays, Insertion Sort will not be so good a\nperformer as other algorithms.\nSo Insertion Sort is not the best sorting algorithm to use in most\nsituations.\nBut there are special situations where it is ideal.\nWe already know that Insertion Sort works great when the input is\nsorted or nearly so.\nAnother good time to use Insertion Sort is when the array is very\nsmall, since Insertion Sort is so simple.\nThe algorithms that have better asymptotic growth rates tend to be\nmore complicated, which leads to larger constant factors in their\nrunning time.\nThat means they typically need fewer comparisons for larger arrays,\nbut they cost more per comparison.\nThis observation might not seem that helpful, since even an algorithm\nwith high cost per comparison will be fast on small input sizes.\nBut there are times when we might need to do many, many sorts on very\nsmall arrays.\nYou should spend some time right now trying to think of a situation\nwhere you will need to sort many small arrays.\nActually, it happens a lot."}, {"raw": {"@format": "html", "@xml:space": "preserve", "#text": "<a href=\"http://computationaltales.blogspot.com/2011/04/why-tailors-use-insertion-sort.html\" target=\"_blank\">Computational Fairy Tales: Why Tailors Use Insertion Sort</a>"}, "#text": "See  for a discussion on how the relative costs of search and insert can\naffect what is the best sort algorithm to use."}], "substitution_definition": {"@names": "external_link", "raw": {"@format": "html", "@xml:space": "preserve", "#text": "<a href=\"http://computationaltales.blogspot.com/2011/04/why-tailors-use-insertion-sort.html\" target=\"_blank\">Computational Fairy Tales: Why Tailors Use Insertion Sort</a>"}}, "comment": [{"@xml:space": "preserve", "#text": "`Computational Fairy Tales: Why Tailors Use Insertion Sort"}, {"@xml:space": "preserve", "#text": "<http://computationaltales.blogspot.com/2011/04/why-tailors-use-insertion-sort.html target = \"_blank\">`_"}]}]}}