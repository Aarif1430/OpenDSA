{"document": {"@dupnames": "comparing\\ records", "@ids": "comparing-records", "@source": "<string>", "@title": "Comparing Records", "title": "Comparing Records", "subtitle": {"@dupnames": "comparing\\ records", "@ids": "id1", "#text": "Comparing Records"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "CompareSumm", "@long_name": "CompareSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "paragraph": [{"title_reference": "key", "#text": "If we want to sort some things, we have to be able to compare them, to\ndecide which one is bigger.\nHow do we compare two things?\nIf all that we wanted to sort or search for was simple integer values,\nthis would not be an interesting question.\nWe can just use standard comparison operators like \"<\" or \">\".\nEven if we wanted to store strings, most programming languages give us\nbuilt-in functions for comparing strings alphabetically.\nBut we do not usually want to store just integers or strings in a data\nstructure.\nUsually we want to store records, where a record is made up of\nmultiple values, such as a name, an address, and a phone number.\nIn that case, how can we \"compare\" records to decide which one is\n\"smaller\"?\nWe cannot just use \"<\" to compare the records!\nNearly always in this situation, we actually are interested in sorting\nthe records based on the values of one particular field used to\nrepresent the record,\nwhich itself is something simple like an integer.\nThis field is referred to as the  for the record."}, {"title_reference": "search key", "#text": "Likewise, if we want to search for a given record in a database, how\nshould we describe what we are looking for?\nA database record could simply be a number, or it could be quite\ncomplicated, such as a payroll record with many fields of varying\ntypes.\nWe do not want to describe what we are looking for by detailing and\nmatching the entire contents of the record.\nIf we knew everything about the record already, we probably would not\nneed to look for it.\nInstead, we typically define what record we want in terms of a\nkey value.\nFor example, if searching for payroll records, we might wish to\nsearch for the record that matches a particular ID number.\nIn this example the ID number is the ."}, {"title_reference": ["comparable", "total order <total order> <SetDef>"], "#text": "To implement sorting or searching, we require that keys be .\nAt a minimum, we must be able to take two keys and reliably determine\nwhether they are equal or not.\nThat is enough to enable a sequential search through a database of\nrecords and find one that matches a given key.\nHowever, we typically would like for the keys to define a\n,\nwhich means that we can always tell which of two keys is greater than\nthe other.\nUsing key types with total orderings gives the database\nimplementor the opportunity to organize a collection of records in\na way that makes searching more efficient.\nAn example is storing the records in sorted order in an array, which\npermits a binary search.\nFortunately, in practice most fields of most records consist of\nsimple data types with natural total orders.\nFor example, integers, floats, doubles, and character strings all are\ntotally ordered."}, {"literal": ".key()", "#text": "But if we want to write a general purpose sorting or searching\nfunction, we need a general way to get the key for the record.\nWe could insist that every record have a particular method called\n.\nThat seems like a good name for it!"}, {"literal": ["Comparable", ".compareTo()"], "#text": "Some languages like Java and C++ have special infrastructure for\nsupporting this (such as the  interface in Java,\nwhich has the  method for defining the exact process\nby which two objects are compared).\nBut many languages like Processing and JavaScript do not."}, "But what if the programmer had already used that method name for\nanother purpose?\nAn even bigger problem is, what if the programmer wants to sort the\nrecord now using one field as the key, and later using another field?\nOr search sometimes on one key, and at other times on another?\nThe problem is that the \"keyness\" of a given field is not an inherent\nproperty within the record, but rather depends on the context.\nSo, you cannot always count on being able to use your favorite method\nname (or even the comparable interface) to extract the desired key\nvalue.", "whose job is to extract the key from the record.\nA comparator function can be passed in as a parameter, such as in a\ncall to a sorting function.\nIn this case, the comparator function would be invoked on two records\nwhenever they need to be compared.\nIn this way, different comparator functions can be passed in to handle\ndifferent record types or different fields within a record.\nIn Java (with generics) or C++ (with templates), a comparator class\ncan be a parameter for another class definition.\nFor example, a BST could take a comparator class as a generics\nparameter in Java.\nThis comparator class would be responsible for dealing with the\ncomparison of two records.", {"footnote_reference": {"@auto": "1", "@ids": "id2", "@refid": "id3", "#text": "1"}, "#text": "Unfortunately, while flexible and able to handle nearly all\nsituations, there are a few situations for which it is not possible to\nwrite a key extraction method.\nIn that case, a comparator will not work."}, {"title_reference": "key-value pairs <key-value pair>", "#text": "One good general-purpose solution is to explicitly store\n in the data structure.\nFor example, if we want to sort a bunch of records, we can store them\nin an array where every array entry contains both a key value for the\nrecord and a pointer to the record itself.\nThis might seem like a lot of extra space required, but remember that\nwe can then store pointers to the records in another array with\nanother field as the key for another purpose.\nThe records themselves do not need to be duplicated.\nA simple class for representing key-value pairs is shown here."}, {"title_reference": ["dictionary", "Insertion Sort <Insertion Sort> <InsertionSort>"], "literal": ["Comparable", "KVPair", "Comparable", "KVPair"], "#text": "The main places where we will need to be concerned with comparing\nrecords and extracting keys is for various \nimplementations and sorting algorithms.\nTo keep them clear and simple, visualizations for sorting algorithms\nwill usually show them as operating on integer values stored in an\narray.\nBut almost never do people really want to sort an array of integers.\nBut to be useful, a real sorting algorithm typically has to\ndeal with the fact that it is sorting a collection of records.\nA general-purpose sorting routine meant to operate on multiple record\ntypes would have to be written in a way to deal with the generic\ncomparison problem.\nTo illustrate, here is an example of\n implemented to\nwork on an array that stores records that support the \ninterface.\nNote that since  is implemented to implement the\n interface, an array of  could be used by this\nsort function."}, "Here are some review questions to test your knowledge from this module."], "definition_list": {"definition_list_item": {"term": "Another, more general approach is to supply a function or class", "definition": {"paragraph": {"title_reference": "comparator", "#text": "called a"}}}}, "footnote": {"@auto": "1", "@backrefs": "id2", "@ids": "id3", "@names": "1", "label": "1", "paragraph": "One example of a situation where it is not possible to write a\nfunction that extracts a key from a record is when we have a\ncollection of records that describe books in a library.\nOne of the fields for such a record might be a list of subject\nkeywords, where the typical record stores a few keywords.\nOur dictionary might be implemented as a list of records sorted\nby keyword.\nIf a book contains three keywords, it would appear three times\non the list, once for each associated keyword.\nHowever, given the record, there is no simple way to determine\nwhich keyword on the keyword list triggered this appearance of\nthe record.\nThus, we cannot write a function that extracts the key from\nsuch a record."}}}