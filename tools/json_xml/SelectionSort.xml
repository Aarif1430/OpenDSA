<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="selection\ sort" ids="selection-sort" source="&lt;string&gt;" title="Selection Sort"><title>Selection Sort</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><index>null</index></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Sorting/SelectionSortAnalysisCON.css</odsalink></raw><section dupnames="selection\ sort" ids="id1"><title>Selection Sort</title><paragraph>Consider again the problem of sorting a pile of phone bills for the
past year.
Another intuitive approach might be to look through the pile until you
find the bill for January, and pull that out.
Then look through the remaining pile until you find the bill for
February, and add that behind January.
Proceed through the ever-shrinking pile of bills to select the next
one in order until you are done.
This is the inspiration for
our last <math>\Theta(n^2)</math> sort,
called <title_reference>Selection Sort</title_reference>.
The <math>i</math>'th pass of Selection Sort "selects" the <math>i</math>'th
largest key in the array, placing that record at the end of the array.
In other words, Selection Sort first finds the largest key in an
unsorted list, then the next largest, and so on.
Its unique feature is that there are few record swaps.
To find the next-largest key value requires searching through
the entire unsorted portion of the array, but only one swap is
required to put the record into place.
Thus, the total number of swaps required will be <math>n-1</math>
(we get the last record in place "for free").</paragraph><paragraph>Here is an implementation for Selection Sort.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>Consider the example of the following array.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="selectionsortS1CON"
    long_name="selectionsortS1CON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Now we continue with the second pass.
However, since the largest record is already at the right end,
we will not need to look at it again.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="selectionsortS2CON"
    long_name="selectionsortS2CON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Selection Sort continues in this way until the entire array is sorted.</paragraph><paragraph>The following visualization puts it all together.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="selectionsortAV"
    long_name="selectionsortAV"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>Now try for yourself to see if you understand how Selection Sort works.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="SelsortPRO"
    long_name="SelsortPRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="selection-sort-analysis" names="selection\ sort\ analysis"><title>Selection Sort Analysis</title><paragraph>Any algorithm can be written in slightly different ways.
For example, we could have written Selection Sort to find the smallest
record, the next smallest, and so on.
We wrote this version of Selection Sort to mimic the behavior of our
Bubble Sort implementation as closely as possible.
This shows that Selection Sort is essentially a Bubble Sort
except that rather than repeatedly swapping adjacent values to get
the next-largest record into place, we instead remember the position
of the record to be selected and do one swap at the end.</paragraph><paragraph>This visualization analyzes the number of
comparisons and swaps required by Selection Sort.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="SelectionSortAnalysisCON"
    long_name="SelectionSortAnalysisCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>There is another approach to keeping the cost of swapping records low,
and it can be used by any sorting algorithm even when the records are
large.
This is to have each element of the array store a pointer to a record
rather than store the record itself.
In this implementation, a swap operation need only exchange the
pointer values.
The large records do not need to move.
This technique is illustrated by Figure <title_reference>Figure #PointerSwap</title_reference>.
Additional space is needed to store the pointers, but the
return is a faster swap operation.</paragraph><target refid="pointerswap"></target><raw format="xml" ids="pointerswap" names="pointerswap" xml:space="preserve"><odsafig>null</odsafig></raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>Here are some review questions to check how well you understand
Selection Sort.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="SelsortSumm"
    long_name="SelsortSumm"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Sorting/selectionsortS1CON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Sorting/selectionsortS2CON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Sorting/SelectionSortAnalysisCON.js</odsascript></raw></section></document>