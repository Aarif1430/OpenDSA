<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="linear\ indexing" ids="linear-indexing" source="&lt;string&gt;" title="Linear Indexing"><title>Linear Indexing</title><subtitle dupnames="linear\ indexing" ids="id1">Linear Indexing</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Indexing/linearIndexingCON.css</odsalink></raw><paragraph>A <title_reference>linear index</title_reference> is an <title_reference>index file</title_reference> organized as a
sequence of <title_reference>key-value pairs &lt;key-value pair&gt;</title_reference> where the
<title_reference>keys &lt;key&gt;</title_reference> are in sorted order and the pointers either
(1) point to the position of the complete record on disk,
(2) point to the position of the <title_reference>primary key</title_reference> in the primary
index, or
(3) are actually the value of the primary key.
Depending on its size, a linear index might be stored in main
memory or on disk.
A linear index provides a number of advantages.
It provides convenient access to variable-length database records,
because each entry in the index file contains a fixed-length key field
and a fixed-length pointer to the beginning of a (variable-length)
record as shown in the following slideshow
A linear index also allows for efficient search and random access to
database records, because it is amenable to
<title_reference>binary search &lt;binary search&gt; &lt;ProgAnal&gt;</title_reference>.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="varindexCON"
    long_name="varindexCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>If the database contains enough records, the linear index might
be too large to store in <title_reference>main memory</title_reference>.
This makes binary search of the index more expensive because many
<title_reference>disk accesses &lt;disk access&gt;</title_reference> would typically be required by the
search process.
One solution to this problem is to store a second-level linear index
in main memory that indicates which disk block in the index file
stores a desired key.
For example, the linear index on disk might reside in a series of
1024-byte blocks.
If each key/pointer pair in the linear index requires 8~bytes
(a 4-byte key and a 4-byte pointer), then
128 key/pointer pairs are stored per block.
The second-level index, stored in main memory, consists of a simple
table storing the value of the key in the first position of each block
in the linear index file.
This arrangement is shown in the next slideshow.
If the linear index requires 1024 disk blocks (1MB), the second-level
index contains only 1024 entries, one per disk block.</paragraph><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>To find which disk block contains a desired search key value,
first search through the 1024-entry table to
find the greatest value less than or equal to the search key.
This directs the search to the proper block in the index file, which
is then read into memory.
At this point, a binary search within this block
will produce a pointer to the actual record in the database.
Because the second-level index is stored in main memory,
accessing a record by this method requires two disk reads:
one from the index file and one from the database file for the actual
record.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="linindexCON"
    long_name="linindexCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="linearIndexingPRO"
    long_name="linearIndexingPRO"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw><paragraph>Every time a record is inserted to or deleted from the database,
all associated secondary indices must be updated.
Updates to a linear index are expensive, because the
entire contents of the array might be shifted.
Another problem is that multiple records with
the same secondary key each duplicate that key value within the
index.
When the secondary key field has many duplicates, such as when it has
a limited range (e.g., a field to indicate job category from among a
small number of possible job categories),
this duplication might waste considerable space.</paragraph><paragraph>One improvement on the simple sorted array is a two-dimensional
array where each row corresponds to a secondary key value.
A row contains the primary keys whose records have the indicated
secondary key value.
Figure <title_reference>Figure #TwoDArray</title_reference> illustrates this approach.
Now there is no duplication of secondary key values,
possibly yielding a considerable space savings.
The cost of insertion and deletion is reduced, because only one row
of the table need be adjusted.
Note that a new row is added to the array when a new secondary key
value is added.
This might lead to moving many records, but this will happen
infrequently in applications suited to using this arrangement.</paragraph><target refid="twodarray"></target><raw format="xml" ids="twodarray" names="twodarray" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>A drawback to this approach is that the array must be of fixed
size, which imposes an upper limit on the number of primary keys
that might be associated with a particular secondary key.
Furthermore, those secondary keys with fewer records than the width
of the array will waste the remainder of their row.
A better approach is to have a one-dimensional array of secondary key
values, where each secondary key is associated with a linked
list.
This works well if the index is stored in main memory, but not so
well when it is stored on disk because the linked list for a given key
might be scattered across several disk blocks.</paragraph><paragraph>Consider a large database of employee records.
If the primary key is the employee's ID number and the secondary key
is the employee's name, then each record in the name index associates a
name with one or more ID numbers.
The ID number index in turn associates an ID number with a unique
pointer to the full record on disk.
The secondary key index in such an organization is also known as an
<title_reference>inverted list</title_reference> or <title_reference>inverted file</title_reference>.
It is inverted in that searches work backwards from the
secondary key to the primary key to the actual data record.
It is called a list because each secondary key value
has (conceptually) a list of primary keys associated with it.
Figure <title_reference>Figure #Inverted</title_reference> illustrates this arrangement.
Here, we have last names as the secondary key.
The primary key is a four-character unique identifier.</paragraph><target refid="inverted"></target><raw format="xml" ids="inverted" names="inverted" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>Figure <title_reference>Figure #InvList</title_reference> shows a better approach to storing inverted
lists.
An array of secondary key values is shown as before.
Associated with each secondary key is a pointer to an array of primary
keys.
The primary key array uses a linked-list implementation.
This approach combines the storage for all of the secondary key lists
into a single array, probably saving space.
Each record in this array consists of a primary key value and a
pointer to the next element on the list.
It is easy to insert and delete secondary keys from this array, making
this a good implementation for disk-based inverted files.</paragraph><target refid="invlist"></target><raw format="xml" ids="invlist" names="invlist" xml:space="preserve"><odsafig>null</odsafig></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Indexing/varindexCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Indexing/linindexCON.js</odsascript></raw></document>