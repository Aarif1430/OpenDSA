<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="general-tree-implementations" names="general\ tree\ implementations" source="&lt;string&gt;" title="General Tree Implementations"><title>General Tree Implementations</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>We now tackle the problem of devising an implementation for general
trees that allows efficient processing for all member functions of the
ADTs of Module <title_reference>&lt;GenTreeIntro&gt;</title_reference>.
This section presents several approaches to implementing general
trees.
Each implementation yields  advantages and disadvantages in the amount
of space required to store a node and the relative ease with which
key operations can be performed.
General tree implementations should place no restriction on how many
children a node may have.
In some applications, once a node is created the number of children
never changes.
In such cases, a fixed amount of space can be allocated for the
node when it is created, based on the number of children for the node.
Matters become more complicated if children can be added to or deleted
from a node, requiring that the node's space allocation be adjusted
accordingly.</paragraph><section ids="list-of-children" names="list\ of\ children"><title>List of Children</title><paragraph>Our first attempt to create a general tree implementation is called
the "list of children" implementation for general trees.
It simply stores with each internal node a
linked list of its children.
This is illustrated by Figure <title_reference>Figure #ChildList</title_reference>.</paragraph><target refid="childlist"></target><raw format="xml" ids="childlist" names="childlist" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>The "list of children" implementation stores the tree nodes in an
array.
Each node contains a value, a pointer (or index) to its parent, and a
pointer to a linked list of the node's children, stored in order from
left to right.
Each linked list element contains a pointer to one child.
Thus, the leftmost child of a node can be found directly because it is
the first element in the linked list.
However, to find the right sibling for a node is more difficult.
Consider the case of a node <title_reference>M</title_reference> and its parent <title_reference>P</title_reference>.
To find <title_reference>M</title_reference> 's right sibling, we must move down the child list
of <title_reference>P</title_reference> until the linked list element storing the pointer
to <title_reference>M</title_reference> has been found.
Going one step further takes us to the linked list element that stores
a pointer to <title_reference>M</title_reference> 'sright sibling.
Thus, in the worst case, to find <title_reference>M</title_reference> 's right sibling requires
that all children of <title_reference>M</title_reference> 's parent be searched.</paragraph><paragraph>Combining trees using this representation is difficult if each tree
is stored in a separate node array.
If the nodes of both trees are stored in a single node array, then
adding tree <title_reference>mathbf{T}</title_reference> as a subtree of node <title_reference>R</title_reference> is done
by simply adding the root of <title_reference>mathbf{T}</title_reference> to <title_reference>R</title_reference> 's list
of children.</paragraph></section><section ids="the-left-child-right-sibling-implementation" names="the\ left-child/right-sibling\ implementation"><title>The Left-Child/Right-Sibling Implementation</title><paragraph>With the "list of children" implementation, it is difficult to
access a node's right sibling.
Figure <title_reference>Figure #Explicit</title_reference> presents an improvement.
Here, each node stores its value and pointers to its parent, leftmost
child, and right sibling.
Thus, each of the basic ADT operations can be implemented by reading a
value directly from the node.
If two trees are stored within the same node array, then adding one
as the subtree of the other simply requires setting three pointers.
Combining trees in this way is illustrated by
Figure <title_reference>Figure #AddExplicit</title_reference>.
This implementation is more space efficient than the
"list of children" implementation, and each node requires a fixed
amount of space in the node array.</paragraph><target refid="explicit"></target><raw format="xml" ids="explicit" names="explicit" xml:space="preserve"><odsafig>null</odsafig></raw><target refid="addexplicit"></target><raw format="xml" ids="addexplicit" names="addexplicit" xml:space="preserve"><odsafig>null</odsafig></raw></section><section ids="dynamic-node-implementations" names="dynamic\ node\ implementations"><title>Dynamic Node Implementations</title><paragraph>The two general tree implementations just described use an
array to store the collection of nodes.
In contrast, our standard implementation for binary trees stores each
node as a separate dynamic object containing its value and pointers to
its two children.
Unfortunately, nodes of a general tree can have any number of
children, and this number may change during the life of the node.
A general tree node implementation must support these properties.
One solution is simply to limit the number of children permitted for
any node and allocate pointers for exactly that number of children.
There are two major objections to this.
First, it places an undesirable limit on the number of children, which
makes certain trees unrepresentable by this implementation.
Second, this might be extremely wasteful of space because most
nodes will have far fewer children and thus leave some pointer
positions empty.</paragraph><paragraph>The alternative is to allocate variable space for each node.
There are two basic approaches.
One is to allocate an array of child pointers as part of the node.
In essence, each node stores an array-based list of child pointers.
Figure <title_reference>Figure #GenLinkedFixed</title_reference> illustrates the concept.
This approach assumes that the number of children is known when the
node is created, which is true for some applications but not for
others.
It also works best if the number of children does not change.
If the number of children does change (especially if it increases),
then some special recovery mechanism must be provided to support
a change in the size of the child pointer array.
One possibility is to allocate a new node of the correct size from
free store and return the old copy of the node to free store for
later reuse.
This works especially well in a language with built-in garbage
collection such as Java.
For example, assume that a node <title_reference>M</title_reference> initially has two children,
and that space for two child pointers is allocated when <title_reference>M</title_reference> is
created.
If a third child is added to <title_reference>M</title_reference>, space for a new node with
three child pointers can be allocated, the contents of <title_reference>M</title_reference> is
copied over to the new space, and the old space is then returned to
free store.
As an alternative to relying on the system's garbage collector,
a memory manager for variable size storage units can be implemented,
as described in Chapter <title_reference>Memory Management</title_reference>.
Another possibility is to use a collection of free lists, one for each
array size, as described in Module <title_reference>&lt;Freelist&gt;</title_reference>.
Note in Figure <title_reference>Figure #GenLinkedFixed</title_reference> that the current number
of children for each node is stored explicitly in a <literal>size</literal> field.
The child pointers are stored in an array with <literal>size</literal> elements.</paragraph><target refid="genlinkedfixed"></target><raw format="xml" ids="genlinkedfixed" names="genlinkedfixed" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>Another approach that is more flexible, but which requires more space,
is to store a linked list of child pointers with each node
as illustrated by Figure <title_reference>Figure #GenLinkedLinked</title_reference>.
This implementation is essentially the same as the "list of
children" implementation, but with
dynamically allocated nodes rather than storing the nodes in an
array.</paragraph><target refid="genlinkedlinked"></target><raw format="xml" ids="genlinkedlinked" names="genlinkedlinked" xml:space="preserve"><odsafig>null</odsafig></raw></section><section ids="dynamic-left-child-right-sibling-implementation" names='dynamic\ "left-child/right-sibling"\ implementation'><title>Dynamic "Left-Child/Right-Sibling" Implementation</title><paragraph>The "left-child/right-sibling" implementation
stores a fixed number of pointers with each node.
This can be readily adapted to a dynamic implementation.
In essence, we substitute a binary tree for a
general tree.
Each node of the "left-child/right-sibling" implementation points to
two "children" in a new binary tree structure.
The left child of this new structure is the node's first child
in the general tree.
The right child is the node's right sibling.
We can easily extend this conversion to a forest of general trees,
because the roots of the trees can be considered siblings.
Converting from a forest of general trees to a single binary tree is
illustrated by Figure <title_reference>Figure #FortoBin</title_reference>.
Here we simply include links from each node to its right sibling and
remove links to all children except the leftmost child.
Figure <title_reference>Figure #GenBin</title_reference> shows how this might look in an
implementation with two pointers at each node.
Compared with the implementation illustrated by
Figure <title_reference>Figure #GenLinkedLinked</title_reference> which requires overhead of three
pointers/node, the implementation of Figure <title_reference>Figure #GenBin</title_reference> only
requires two pointers per node.
The representation of Figure <title_reference>Figure #GenBin</title_reference> is likely to be
easier to implement, space efficient, and more flexible than the other
implementations presented in this section.</paragraph><target refid="fortobin"></target><raw format="xml" ids="fortobin" names="fortobin" xml:space="preserve"><odsafig>null</odsafig></raw><target refid="genbin"></target><raw format="xml" ids="genbin" names="genbin" xml:space="preserve"><odsafig>null</odsafig></raw></section></document>