{"document": {"@dupnames": "radix\\ sort", "@ids": "radix-sort", "@source": "<string>", "@title": "Radix Sort", "title": "Radix Sort", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Development/RadixSortAnalysisCON.css"}], "section": [{"@dupnames": "radix\\ sort", "@ids": "id1", "title": "Radix Sort", "paragraph": [{"strong": ["in order", "in order"], "math": "i", "literal": ["A", "A[i]/10"], "#text": "The major problem with Binsort is that it does not work so well for a\nlarge key range.\nFortunately, there is a way to keep the number of bins small and the\nrelated processing relatively cheap while still using the idea of\nbinning records that have similar key values.\nConsider a sequence of records with keys in the range 0 to 99.\nIf we have ten bins available, we can first assign records to bins by\ntaking their key value modulo 10.\nThus, every key will be assigned to the\nbin matching its rightmost decimal digit.\nWe can then take these records from the bins ,\nand reassign them to the bins\non the basis of their leftmost (10's place) digit.\nWe will define values in the range 0 to 9 to have a leftmost digit of\n0.\nIn other words, assign the 'th record from array  to\na bin using the formula .\nIf we now gather the values from\nthe bins , the result is a sorted list.\nWe can see this process in the following visualization."}, {"math": ["r=10", "r^2-1", "\\Theta(n)", "r = 10", "k", "k"], "title_reference": ["Radix Sort", "radix", "base"], "#text": "In this example, we have  bins and key values in\nthe range 0 to .\nThe total computation is , because we look at each\nrecord and each bin a constant number of times.\nThis is a great improvement over the simple Binsort where the number\nof bins must be as large as the key range.\nNote that the example uses  so as\nto make the bin computations easy to visualize:\nRecords were placed into bins based on the value of first the\nrightmost and then the leftmost decimal digits.\nAny number of bins would have worked if we interpret the key values in\nterms of the corresponding base.\nThis is an example of a , so called because the\nbin computations are based on the  or the\n of the key values.\nThis sorting algorithm can be extended to any number of\nkeys in any key range.\nWe simply assign records to bins based on the\nkeys' digit values working from the rightmost digit to the leftmost.\nIf there are  digits, then this requires that we assign keys to\nbins  times."}, "Here is a practice exercise for placing keys into bins."], "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "radixLinkAV", "@long_name": "radixLinkAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RadixsortPRO", "@long_name": "RadixsortPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "array-based-radix-sort", "@names": "array-based\\ radix\\ sort", "title": "Array-based Radix Sort", "paragraph": [{"math": "r", "#text": "As with Mergesort, an efficient implementation of Radix Sort is\nsomewhat difficult to achieve.\nIn particular, we would prefer to sort an array of values and avoid\nprocessing linked lists.\nIf we knew how  many values would be in each bin, then an auxiliary\narray of size  can be used to define these lengths and guide\nus to were each one starts in the output array.\nFor example, if during the first pass the 0 bin will receive three\nrecords and the 1 bin will receive five records, then we could simply\nreserve the first three array positions for the 0 bin and the next\nfive array positions for the 1 bin.\nExactly this approach is taken by the following implementation.\nAt the end of each pass, the records are copied back to the original\narray."}, {"literal": ["for", "cnt", "cnt", "B", "cnt[j]", "j", "B", "A", "rtoi"], "emphasis": "last", "math": ["r^i", "i"], "#text": "The first inner  loop initializes array .\nThe second loop counts the number of records to be assigned to each\nbin.\nThe third loop sets the values in  to their proper\nindices within array .\nNote that the index stored in \nis the  index for bin ; bins are filled\nfrom high index to low index.\nThe fourth loop assigns the records to the bins (within\narray ).\nThe final loop simply copies the records back to\narray  to be ready for the next pass.\nVariable  stores  for use in bin computation\non the 'th iteration."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "radixArrayAV", "@long_name": "radixArrayAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}], "section": {"@ids": "radix-sort-analysis", "@names": "radix\\ sort\\ analysis", "title": "Radix Sort Analysis", "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "RadixSortAnalysisCON", "@long_name": "RadixSortAnalysisCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RadixSortSumm", "@long_name": "RadixSortSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/RadixSortAnalysisCON.js"}], "paragraph": [{"strong": ["Is it really a reasonable assumption to treat", "as a\nconstant?"], "math": ["k", "k", "n", "k", "n", "N", "n", "N \\leq n", "\\log_r N", "r", "N", "k \\geq \\log_r N"], "#text": "Or is there some relationship between  and ?\nIf the key range is limited and duplicate key values are common,\nthere might be no relationship between  and .\nTo make this distinction more clear, use  to denote the\nnumber of distinct key values used by the  records.\nThus, .\nBecause it takes a minimum of  base  digits\nto represent  distinct key values, we know that\n."}, {"math": ["n", "n = N", "n", "\\log_r n", "r", "n", "k \\geq \\log_r n", "\\log n", "n", "\\Omega(\\log n)", "k", "\\Omega(\\log n)", "\\Omega(n \\log n)", "n"], "emphasis": "at least", "strong": ["This means that Radix Sort requires", "time to process", "distinct key values."], "#text": "Now, consider the situation in which no keys are duplicated.\nIf there are  unique keys then .\nIt would require  distinct values to represent them.\nSo now it takes a minimum of  base  digits to\nrepresent the  distinct key values.\nThis means that .\nBecause it requires   digits\nto distinguish between the  distinct keys\n(within a constant factor  meaning, the number of digits is\n),\n is in ."}, {"math": ["\\log_r n", "n", "\\log_r n", "k", "n", "\\Omega(n \\log n)"], "#text": "Of course the key range could be much bigger\n bits is merely the best case possible for \ndistinct values.\nThus, the  estimate for  could be overly\noptimistic.\nThe bottom line of this analysis is that, for the general case of\n distinct key values, Radix Sort is at best a\n sorting algorithm."}, {"math": ["r", "r = 2^i", "i", "r", "r = 256", "r = 2^{16} = 64\\mbox{K}"], "literal": "cnt", "#text": "Radix Sort's running time can be much improved (by a constant factor)\nif we make base  be as large as possible.\nThis is simplest if we think about integer key values.\nSet  for some .\nIn other words, the value of  is related to the\nnumber of bits of the key processed on each pass.\nEach time the number of bits is doubled, the number of passes is cut\nin half.\nWhen processing an integer key value, setting  allows\nthe key to be processed one byte at a time.\nProcessing a 32-bit integer key requires only four passes.\nIt is not unreasonable on most computers to use\n, resulting in only two passes for a\n32-bit key.\nOf course, this requires a  array of size 64K.\nPerformance will be good\nonly if the number of records is about 64K or greater.\nIn other words, the number of records must be large compared to the\nkey size for Radix Sort to be efficient.\nIn many sorting applications, Radix Sort can be tuned in this way to\ngive better performance."}, {"title_reference": "alphabet trie <alphabet trie> <Trie>", "#text": "Radix Sort depends on the ability to make a fixed number of multiway\nchoices based on a digit value, as well as random access to the bins.\nThus, Radix Sort might be difficult to implement for certain key\ntypes.\nFor example, if the keys are real numbers or arbitrary length strings,\nthen some care will be necessary in implementation.\nIn particular, Radix Sort will need to be careful about deciding when\nthe \"last digit\" has been found to distinguish among real numbers,\nor the last character in variable length strings.\nImplementing the concept of Radix Sort with the\n data structure is most\nappropriate for these situations."}]}}]}}