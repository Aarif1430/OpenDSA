<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="the-avl-tree" names="the\ avl\ tree" source="&lt;string&gt;" title="The AVL Tree"><title>The AVL Tree</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>The AVL tree (named for its inventors Adelson-Velskii and Landis)
should be viewed as a BST with the following additional property:
For every node, the heights of its left and right subtrees differ by
at most 1.
As long as the tree maintains this property, if the tree contains
<math>n</math> nodes, then it has a depth of at most <math>O(\log n)</math>.
As a result, search for any node will cost <math>O(\log n)</math>,
and if the updates can be done in time proportional to the depth of
the node inserted or deleted, then updates will also cost
<math>O(\log n)</math>, even in the worst case.</paragraph><paragraph>The key to making the AVL tree work is to alter the insert and delete
routines so as to maintain the balance property.
Of course, to be practical, we must be able to implement the revised
update routines in <math>\Theta(\log n)</math> time.</paragraph><target refid="avlinsert"></target><raw format="xml" ids="avlinsert" names="avlinsert" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>Consider what happens when we insert a node with key value 5,
as shown in Figure <title_reference>Figure #AVLinsert</title_reference>.
The tree on the left meets the AVL tree balance requirements.
After the insertion, two nodes no longer meet the requirements.
Because the original tree met the balance requirement, nodes in the
new tree can only be unbalanced by a difference of at most 2 in the
subtrees.
For the bottommost unbalanced node, call it <math>S</math>, there are 4
cases:</paragraph><enumerated_list enumtype="arabic" prefix="(" suffix=")"><list_item><paragraph>The extra node is in the left child of the left child of
<math>S</math>.</paragraph></list_item><list_item><paragraph>The extra node is in the right child of the left child of
<math>S</math>.</paragraph></list_item><list_item><paragraph>The extra node is in the left child of the right child of
<math>S</math>.</paragraph></list_item><list_item><paragraph>The extra node is in the right child of the right child of
<math>S</math>.</paragraph></list_item></enumerated_list><paragraph>Cases 1 and 4 are symmetrical, as are cases 2 and 3.
Note also that the unbalanced nodes must be on the path from
the root to the newly inserted node.</paragraph><paragraph>Our problem now is how to balance the tree in <math>O(\log n)</math> time.
It turns out that we can do this using a series of local operations
known as <title_reference>rotations &lt;rotation&gt;</title_reference>.
Cases 1 and 4 can be fixed using a <title_reference>single rotation</title_reference>,
as shown in Figure <title_reference>Figure #AVLsingle</title_reference>.
Cases 2 and 3 can be fixed using a <title_reference>double rotation</title_reference>, as shown
in Figure <title_reference>Figure #AVLdouble</title_reference>.</paragraph><target refid="avlsingle"></target><raw format="xml" ids="avlsingle" names="avlsingle" xml:space="preserve"><odsafig>null</odsafig></raw><target refid="avldouble"></target><raw format="xml" ids="avldouble" names="avldouble" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>The AVL tree insert algorithm begins with a normal BST insert.
Then as the recursion unwinds up the tree, we perform the appropriate
rotation on any node that is found to be unbalanced.
Deletion is similar; however, consideration for unbalanced nodes must
begin at the level of the <title_reference>deletemin</title_reference> operation.</paragraph><topic><title>Example</title><paragraph>In Figure <title_reference>Fig #AVLinsert</title_reference> (b), the bottom-most unbalanced
node has value 7.
The excess node (with value 5) is in the right subtree of the left
child of 7, so we have an example of Case 2.
This requires a double rotation to fix.
After the rotation, 5 becomes the left child of 24, 2 becomes the
left child of 5, and 7 becomes the right child of 5.</paragraph></topic></document>