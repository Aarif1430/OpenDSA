{"document": {"@dupnames": "shellsort", "@ids": "shellsort", "@source": "<string>", "@title": "Shellsort", "title": "Shellsort", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}], "section": [{"@dupnames": "shellsort", "@ids": "id1", "title": "Shellsort", "paragraph": [{"title_reference": ["diminishing increment sort", "Shellsort", "theta(n^2)", "theta(n^2)"], "#text": "Shellsort was named for its inventor, D.L. Shell, who first published\nit in 1959.\nIt is also sometimes called the .\nWhen properly implemented,  will give\nsubstantially better performance than any of the \nsorts like Insertion Sort or Selection Sort.\nBut it is also a bit more complicated than those simple\n sorts.\nUnlike Insertion Sort and Selection Sort, there is no real-life\nintuition to inspire Shellsort -- nobody will use Shellsort to\nsort their Bridge hand or organize their bills.\nThe key idea behind Shellsort is to exploit the best-case performance\nof Insertion Sort.\nRecall that when a list is sorted or nearly sorted, Insertion Sort\nruns in linear time.\nSo Shellsort's strategy is to quickly make the list \"mostly sorted\",\nso that a final Insertion Sort can finish the job."}, "Shellsort does what most good sorts do:\nBreak the input into pieces, sort the pieces, then recombine them.\nBut Shellsort does this in an unusual way, breaking its input\ninto \"virtual\" sublists that are often not contiguous.\nEach such sublist is sorted using an Insertion Sort.\nAnother group of sublists is then chosen and sorted, and so on.", "Shellsort works by performing its Insertion Sorts on carefully\nselected sublists, first on small sublists and then on increasingly\nlarge sublists.\nSo at each stage, any Insertion Sort is either working on a small list\n(and so is fast) or is working on a nearly sorted list (and again is\nfast).", {"title_reference": ["I", "I"], "#text": "Shellsort breaks the list into disjoint sublists, where a sublist\nis defined by an \"increment\", .\nEach record in a given sublist is  positions apart.\nFor example, if the increment were 4, then each record in the sublist\nwould be 4 positions apart."}, {"title_reference": ["I", "n", "I"], "#text": "One possible implementation for Shellsort is to use increments that\nare all powers of two.\nWe start by picking as  the largest power of two less than\n.\nThis will generate  sublists of 2 records each.\nIf there were 16 records in the array indexed from 0\nto 15, there would initially be 8 sublists of 2 records each,\nwith each record in the sublist being 8 positions apart.\nThe first sublist would be the records in positions 0 and 8.\nThe second is in positions 1 and 9, and so on."}, {"title_reference": "n/2", "#text": "Actually, the increment size does not need to start at exactly\n.\nIn the following example, we will use an array of 12 records\n(since 16 records makes the example a bit long).\nWe will still begin with an increment size of 8.\nAs you click through the following slideshow, you will see each of the\nsublists of length 2.\nIf we reach a point where the remaining sublists have only one\nrecord (as will be the case for each of the sublists beginning with\nrecords 4 through 7), then we can skip processing them."}, "Shellsort will sort each of these sublists of length 2 using Insertion\nSort.\nAs you click through the next slideshow, you will first see the current\nsublist highlighted in yellow.\nThen a pair of records to be compared will be shown in blue.\nThey are swapped if necessary to put them in sort order.\n(Of course, since these first sublists are each of length 2 when\nthe two items are being compared you won't see anything yellow anymore!)", "At the end of the first pass, the resulting array is \"a little better\nsorted\".", {"title_reference": ["n/4", "n=12", "12/4 = 3"], "#text": "The second pass of Shellsort looks at fewer, bigger sublists.\nIn our example, the second pass will have an increment of size 4,\nresulting in  sublists.\nSince the array in our example has  records, we have\n4 sublists that each have  records.\nThus, the second pass would have as its first\nsublist the 3 records in positions 0, 4, and 8.\nThe second sublist would have records in positions 1, 5, and 9,\nand so on."}, "As you click through the slides, you will see the sublists for\nincrement size 4.", "Each sublist of 3 records would also be sorted using an Insertion\nSort, as shown next.", "At the end of processing sublists with increment 4, the array is\n\"even more sorted\".", "The third pass will be made on sublists with increment 2.\nThe effect is that we process 2 lists, one consisting of the odd\npositions and the other consisting of the even positions.\nAs usual, we sort the sublists using Insertion Sort.", "At this point, we are getting close to sorted.", "Shellsort's final pass will always use an increment of 1,\nwhich means a \"regular\" Insertion Sort of all records.\nBut the list is far closer to sorted than it was at the start,\nso this final call to Insertion Sort runs far faster than if we had\nrun Insertion Sort on the original array.", "Finally, the array is sorted.", "Here is a code implementation for Shellsort.", "Now, test your understanding of the sublist concept."], "raw": [{"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "shellsortCON1", "@long_name": "shellsortCON1", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "shellsortCON2", "@long_name": "shellsortCON2", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "shellsortCON3", "@long_name": "shellsortCON3", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "shellsortCON4", "@long_name": "shellsortCON4", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "shellsortCON5", "@long_name": "shellsortCON5", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "shellsortCON6", "@long_name": "shellsortCON6", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "shellsortCON7", "@long_name": "shellsortCON7", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "shellsortCON8", "@long_name": "shellsortCON8", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "shellsortCON9", "@long_name": "shellsortCON9", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "ShellsortSublistSumm", "@long_name": "ShellsortSublistSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "putting-it-together", "@names": "putting\\ it\\ together", "title": "Putting It Together", "paragraph": [{"title_reference": "n", "#text": "There is a lot of flexibility to picking the increment series.\nIt does not need to start with the greatest power of less than\n and cut in half each time.\nIn fact that is not even a good choice for the increment series.\nWe will come back to this later.\nFor now, just realize that so long as each increment is smaller than the\nlast, and the last increment is 1, Shellsort will work."}, "At this point try running Shellsort on an array of your chosen size,\nwith either random values or values that you select.\nYou can also set the increment series.\nUse this visualization to make sure that you understand how Shellsort\nworks.", "Next, let's review what makes for a legal increment series."], "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "shellsortAV", "@long_name": "shellsortAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "ShellsortSeries", "@long_name": "ShellsortSeries", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "shellsort-practice-exercise", "@names": "shellsort\\ practice\\ exercise", "title": "Shellsort Practice Exercise", "paragraph": "Now test yourself to see how well you understand Shellsort.\nCan you reproduce its behavior?", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "shellsortPRO", "@long_name": "shellsortPRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}}, {"@ids": "optimizing-shellsort", "@names": "optimizing\\ shellsort", "title": "Optimizing Shellsort", "paragraph": [{"title_reference": ["(2^k, 2^{k-1}, ldots, 4, 2, 1)", "3n+1"], "#text": "Some choices for the series of increments will make Shellsort\nrun more efficiently than others.\nIn particular, the choice of increments described above\n turns out to be relatively inefficient.\nYou should notice for example that all records in a given 8 increment\nsublist are also part of some 4 increment sublist, which are all in turn\nrecords of the same 2 increment sublist.\nSo there is no \"crossover\" between sublists as the increments\nreduce.\nA better choice is the following series based on \"\":\n(..., 121, 40, 13, 4, 1).\nAnother approach is to make sure that the various increments are\nrelatively prime.\nThe series (..., 11, 7, 3, 1) would be an example.\nIn this case, there is a lot of \"crossover\" between the lists at the\nvarious increment sizes."}, "Now you are ready to try out some different increment series to see\nhow they affect the cost of Shellsort.", {"title_reference": ["Theta(nsqrt{n}) = Theta(n^{1.5})", "theta(n^2)", "n"], "#text": "A theoretical analysis of Shellsort is difficult, so we must accept\nwithout proof that the average-case performance of Shellsort\n(for a reasonable increment series)\nis .\nThus, Shellsort is substantially better than Insertion Sort,\nor any of the other  sorts presented earlier.\nIn fact, Shellsort is not so much worse than the\nasymptotically better sorts to be presented later,\nwhenever  is of medium size (though it tends to be a little\nslower than these other algorithms if they are well implemented).\nShellsort illustrates how we can sometimes exploit the special properties\nof an algorithm (in this case Insertion Sort) even if in general that\nalgorithm is unacceptably slow."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "shellsortPerf", "@long_name": "shellsortPerf", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}}, {"@ids": "shellsort-summary-questions", "@names": "shellsort\\ summary\\ questions", "title": "Shellsort Summary Questions", "paragraph": ["Here are some review questions to check that you understand Shellsort.", "If you want to know more about Shellsort, you can find a lot of\ndetails about its analysis along with ideas on how to pick a good\nincrement series in ."], "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "ShellsortSumm", "@long_name": "ShellsortSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/shellsortCODE.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/shellsortCON1.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/shellsortCON2.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/shellsortCON3.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/shellsortCON4.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/shellsortCON5.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/shellsortCON6.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/shellsortCON7.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/shellsortCON8.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/shellsortCON9.js"}]}]}}