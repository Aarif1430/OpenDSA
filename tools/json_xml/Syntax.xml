<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="syntax-of-the-lambda-calculus" names="syntax\ of\ the\ lambda\ calculus" source="&lt;string&gt;" title="Syntax of the Lambda Calculus"><title>Syntax of the Lambda Calculus</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-13 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/PL/AV/parseTree.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/PL/main.css</odsalink></raw><raw format="xml" xml:space="preserve"><index>null</index></raw><section ids="lambda-calculus" names="lambda\ calculus"><title>Lambda Calculus</title><paragraph>The <title_reference>lambda calculus</title_reference> (also written as <title_reference>lambda</title_reference>-calculus,
where <title_reference>lambda</title_reference> is the name of the Greek letter <title_reference>lambda</title_reference>)
was created by Alonzo Church in the early 1930s to study which
functions are computable. In addition to being a concise yet powerful
model in computability theory, the lambda calculus is also the
simplest functional programming language. So much so that the lambda
calculus looks like a toy language, even though it is (provably!) as
powerful as any of the programming languages being used today, such as
JavaScript, Java, C++, etc.</paragraph><raw format="xml" xml:space="preserve"><index>null</index></raw><target refid="bnf-grammar-for-lc"></target><paragraph ids="bnf-grammar-for-lc" names="bnf-grammar-for-lc">Programs in the lambda calculus are called <title_reference>lambda expressions</title_reference>
(abbreviated <title_reference>lambda exp</title_reference>), of which there are only three
kinds. In fact, here is a complete BNF grammar for the lambda
calculus:</paragraph><raw format="xml" xml:space="preserve"><index>null</index></raw><math_block xml:space="preserve">\begin{eqnarray*}
&lt;\lambda exp&gt; &amp;::=&amp; &lt;var&gt;\\
                     &amp;|&amp; \lambda &lt;\mathrm{var}&gt;\ .\ &lt;\lambda exp&gt;\\
                     &amp;|&amp; (\ &lt;\lambda exp&gt;\ &lt;\lambda exp&gt;\ )\\
\end{eqnarray*}</math_block><raw format="xml" xml:space="preserve"><index>null</index></raw><paragraph>This BNF grammar tells us that expressions in the lambda calculus come
in one of three flavors:</paragraph><block_quote><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>A <title_reference>variable</title_reference> (the first production above): typically, we
will use a single letter, with an optional integer subscript, to
denote a variable. So, <title_reference>x, y, a_1</title_reference>, and <title_reference>p_2</title_reference> are
examples of variables.</paragraph></list_item><list_item><paragraph>A <title_reference>function abstraction</title_reference> (the second production above):
this type of <title_reference>lambda</title_reference> expressions, also called a
<title_reference>lambda abstraction</title_reference>, corresponds to a function
definition, which contains two components: the formal parameter
of the function (there must be exactly one parameter, namely the
<title_reference>&lt; var &gt;</title_reference> non-terminal in the second production above) and
the body of the function (namely the <title_reference>&lt;lambda exp &gt;</title_reference>
non-terminal in the same production). So, for example,
<title_reference>lambda x.y</title_reference> is the function whose formal parameter is
<title_reference>x</title_reference> and whose body is <title_reference>y</title_reference>. Note that the non-terminal
<title_reference>&lt;var&gt;</title_reference> after the <title_reference>lambda</title_reference> terminal is <emphasis>not</emphasis> the
name of the function. In fact, all functions in the lambda calculus
are anonymous.</paragraph></list_item><list_item><paragraph>An <title_reference>application</title_reference> (the third production above): this type of
<title_reference>lambda</title_reference> expressions corresponds to a function call (or
application, or invocation), which contains two components: the
function being called, followed by the argument that is passed
into the function. So, for example, <title_reference>(fx)</title_reference> is the
application of the variable <title_reference>f</title_reference> (which must stand for a
function, since functions are the only values in the lambda
calculus) to the argument <title_reference>x</title_reference>, which must also stand for a
function.</paragraph><raw format="xml" xml:space="preserve"><index>null</index></raw><paragraph>Note that in the lambda calculus, the parentheses
surround both the function and its argument, while in many modern
programming languages (and in mathematical notation), the
function would come first and be followed by the formal parameter
in parentheses, like this: <title_reference>f(x)</title_reference>. In the lambda calculus,
the parentheses are not optional around function
calls. Furthermore, the grammar above makes it clear that they
cannot be used anywhere else.</paragraph></list_item></enumerated_list></block_quote><paragraph>The grammar above is quite concise, since it contains only two
non-terminals. Yet it generates an infinite set of expressions that
represent all computable functions! Recall that the expressive power
of BNF grammars comes from recursion, which is present in both the
second and third productions in the grammar  above.</paragraph><paragraph>The following slideshow demonstrates how to use the grammar above
to build the parse tree for a given lambda expression.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="parseTree"
    long_name="parseTree"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph><strong>Questions to ponder</strong></paragraph><raw format="xml" xml:space="preserve"><index>null</index></raw><paragraph>Q1. Why does the non-terminal <title_reference>&lt;var&gt;</title_reference> not appear on the
left-hand size of any productions in the grammar above? Is the grammar
incomplete?</paragraph><paragraph>Q2. How many terminals does this grammar contain?</paragraph><paragraph>Q3. Is this grammar ambiguous, since the third production is doubly recursive?</paragraph></section><section ids="rp-14-part-1" names="rp\ 14\ part\ 1"><title>RP 14 part 1</title><paragraph>Test your mastery of the syntax of the lambda calculus with this
exercise.  To get credit for this randomized exercise, you must solve
it correctly three times in a row.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP14part1"
    long_name="RP14part1"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="rp-14-part-2" names="rp\ 14\ part\ 2"><title>RP 14 part 2</title><paragraph>Once you can consistently solve the previous problem, try this more
intense exercise, in which you have to analyze four expressions each
time.  To get credit for this randomized exercise, you must solve it
correctly three times in a row.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP14part2"
    long_name="RP14part2"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/PL/AV/parseTree.js</odsascript></raw></section></document>