{"document": {"@dupnames": "binsort", "@ids": "binsort", "@source": "<string>", "@title": "Binsort", "title": "Binsort", "subtitle": {"@dupnames": "binsort", "@ids": "id1", "#text": "Binsort"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "binsortS1CON", "@long_name": "binsortS1CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "binsortS2CON", "@long_name": "binsortS2CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/binsortS1CON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/binsortS2CON.js"}], "paragraph": [{"title_reference": "Binsort", "#text": "Imagine that for the past year, as you paid your various bills, you\nthen simply piled all the paperwork into a corner somewhere.\nNow the year has ended and you have decided that it is time to sort\nall of these papers by what the bill was for (phone, electricity,\nrent, etc.) and date.\nA pretty natural approach is to make some space on the floor and, as\nyou go through the pile of papers, put the phone bills into one pile,\nthe electric bills into another pile, and so on.\nOnce this initial assignment of bills to piles is done (in one pass),\nyou can then sort each pile by date relatively quickly, because each\npile is fairly small.\nThis is the basic idea behind a ."}, {"title_reference": "n-1", "#text": "Let's start with an especially easy situation.\nConsider the following code fragment to sort a permutation of the\nnumbers 0 through ."}, {"title_reference": ["Binsort", "Theta(n)", "n-1"], "#text": "Here the key value is used to determine the\nposition for a record in the final sorted array.\nThis is the most basic example of a ,\nwhere key values are used to assign records to bins.\nThis algorithm is extremely efficient,\nalways taking  time\nregardless of the initial ordering of the keys.\nThis is far better than the performance of any sorting\nalgorithm that we have seen so far.\nThe problem is that this algorithm has limited use because it\nworks only for a permutation of the numbers from 0 to ."}, "We can extend this simple version of the Binsort algorithm to be more\nuseful.\nBecause Binsort must perform direct computation on the key value (as\nopposed to just asking which of two records comes first as our\nprevious sorting algorithms did),\nwe will assume that the records use an integer key type.", {"literal": ["B", "B[i]", "B", "MaxKeyValue"], "title_reference": ["i", "n", "n", "2n"], "#text": "The simplest extension is to allow for duplicate values among the\nkeys.\nThis can be done by turning array slots into arbitrary-length bins by\nturning array  into an array of linked lists.\nIn this way, all records with key value  can be placed in bin\n.\nA second extension allows for a key range greater than .\nFor example, a set of  records might have keys in the range 1\nto .\nThe only requirement is that each possible key value have a\ncorresponding bin in .\nWe assume that we know that the range of possible keys is between\n0 and .\nHere is the extended Binsort algorithm."}, {"literal": "MaxKeyValue", "#text": "This version of Binsort can sort any collection of records whose key\nvalues fall in the range from 0 to ."}, {"title_reference": "Theta(n)", "#text": "The total work required is simply that needed to place each record\ninto the appropriate bin and then take all of the records out of the\nbins.\nThus, we need to process each record twice, for \nwork."}, {"strong": "wrong", "literal": ["MaxKeyValue", "MaxKeyValue", "MaxKeyValue", "MaxKeyValue", "B"], "title_reference": ["n", "= n^2", "Theta(n + n^2) = Theta(n^2)", "n"], "#text": "Does that cost analysis really make sense?\nActually, that last statement is ,\nbecause it neglects a crucial observation.\nTaking all of the records out of the bins requires Binsort to look at\nevery bin to see if it contains a record.\nThus, the algorithm must process  bins,\nregardless of how many of them actually hold records.\nIf \nis small compared to , then this is not a great expense.\nSuppose that  .\nIn this case, the total amount of work done will be\n.\nThis results in a poor sorting algorithm.\nAnd the algorithm becomes even worse as the disparity between\n and  increases.\nIn addition, a large key range requires an unacceptably large array\n.\nThus, even the extended Binsort is useful only for a limited key\nrange."}, {"title_reference": "bucket sort", "#text": "A further generalization to Binsort would yield a .\nHere, each bin (now called a bucket) is associated with not just one\nkey, but rather a range of key values.\nA bucket sort assigns records to buckets and then relies on some\nother sorting technique to sort the records within each bucket.\nThe hope is that the relatively inexpensive bucketing process will put\nonly a small number of records into each bucket, and that a\n\"cleanup sort\" to each bucket will then be relatively cheap.\nThis is similar in spirit to the Radix Sort, which extends the\nconcept of the Binsort in a practical way."}]}}