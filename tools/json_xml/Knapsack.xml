<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="0/1\ knapsack\ problem" ids="knapsack-problem" source="&lt;string&gt;" title="0/1 Knapsack Problem"><title>0/1 Knapsack Problem</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-13 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><section dupnames="0/1\ knapsack\ problem" ids="id1"><title>0/1 Knapsack Problem</title><paragraph>The 0/1 Knapsack problem can be defined in terms of a thief who enters the
place they will rob with a single knapsack to carry away their spoils. This
knapsack has a specified limit on the weight it can support without tearing.
This weight capacity will be refered to as CAP. After cracking open a safe, the
theif finds that the safe contains N items, each with a specific weight and
value (both are integers). The thief's goal is to maximize the total value of
set of items they take without going over the weight limit, CAP. The "0/1"
binary qualifier in the name of this problem denotes that each item must be
entirely accepted or rejected, that is, the theif can't subdivide an item.</paragraph><paragraph>The first step in solving this problem is to formulate a recurcive solution,
then see if the solution can be made more efficent using dynamic programming.
To provide some insight into the problem, the following notation will be used</paragraph><table><tgroup cols="2"><colspec colwidth="10"></colspec><colspec colwidth="38"></colspec><thead><row><entry><paragraph>Symbol</paragraph></entry><entry><paragraph>Definition</paragraph></entry></row></thead><tbody><row><entry><paragraph>N</paragraph></entry><entry><paragraph>is the number of items in the safe</paragraph></entry></row><row><entry><paragraph>CAP</paragraph></entry><entry><paragraph>is the weight capacity of the knapsack</paragraph></entry></row><row><entry><paragraph>WT(i)</paragraph></entry><entry><paragraph>is the weight of the ith item</paragraph></entry></row><row><entry><paragraph>VALUE(i)</paragraph></entry><entry><paragraph>is the value of the ith item</paragraph></entry></row><row><entry><paragraph>V(i,c)</paragraph></entry><entry><paragraph>i&lt;=n c&lt;=cap denotes the total value of
the optimal solution to a version of
the problem in which c is the capacity
of the knapsack and only items
1, 2, 3, ... , i are considered.</paragraph></entry></row></tbody></tgroup></table><paragraph>The key to solving this algorithm will be to define V(<emphasis>i</emphasis>, <emphasis>c</emphasis>) recursively for all
<emphasis>i</emphasis> &lt;= <emphasis>N</emphasis>, <emphasis>c</emphasis> &lt;= <emphasis>CAP</emphasis>. Note that when <emphasis>i</emphasis> = <emphasis>N</emphasis> and <emphasis>c</emphasis> =  <emphasis>CAP</emphasis> in V(<emphasis>i</emphasis>, <emphasis>c</emphasis>), the problem has been
solved.</paragraph><paragraph>To create a solution for this problem, it would be best to start simple.
Consider the how V(<emphasis>i</emphasis>, <emphasis>c</emphasis>) can be defined when <emphasis>i</emphasis> = 1. In this case, we are asking
for the total value of an optimal solution when only the first item is involved
and the knapsack has a capacity of <emphasis>c</emphasis>. A definition of V(<emphasis>i</emphasis>, <emphasis>c</emphasis>) is:</paragraph><line_block><line>V(1, <emphasis>c</emphasis>) = VALUE(<emphasis>i</emphasis>) <strong>IF</strong> WT(<emphasis>i</emphasis>) &lt;= <emphasis>c</emphasis></line><line>V(1, <emphasis>c</emphasis>) = 0 otherwise since the knapsack cannot accommodate the items weight</line></line_block><paragraph>Another simple case to consider would be if <emphasis>i</emphasis> = 0 or <emphasis>c</emphasis> = 0. If <emphasis>i</emphasis> = 0,
there are no items to consider so V(0, <emphasis>c</emphasis>) = 0. If <emphasis>c</emphasis> = 0, the knapsack
can not hold anything else, so V(<emphasis>i</emphasis> ,0) = 0.</paragraph><paragraph>Next consider how to define V(<emphasis>i</emphasis>, <emphasis>c</emphasis>) in terms of small parameter values when
<emphasis>i</emphasis> &gt; 1. A good way to break this down is as follows:</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>If WT(<emphasis>i</emphasis>) &gt; c then V(<emphasis>i</emphasis>, <emphasis>c</emphasis>) must be the same as V(<emphasis>i</emphasis>-1, <emphasis>c</emphasis>)
since the knapsack is capacity is not large enough to contain the item <emphasis>i</emphasis></paragraph></list_item><list_item><paragraph>Otherwise to determine whether of not the solution contains item <emphasis>i</emphasis>, we must compare:</paragraph><enumerated_list enumtype="loweralpha" prefix="" suffix=")"><list_item><paragraph>A) The optimal solution to the capaciy <emphasis>c</emphasis> version when only items 1,2,3 ... <emphasis>i</emphasis>-1 are used, that is, V(<emphasis>i</emphasis>-1, <emphasis>c</emphasis>))</paragraph></list_item><list_item><paragraph>B) The optimal solution to V(<emphasis>i</emphasis>-1, <emphasis>c</emphasis>-WT(<emphasis>i</emphasis>)) + VALUE(<emphasis>i</emphasis>).</paragraph><paragraph>Why is this true? If an item <emphasis>i</emphasis> is included in the knapsack, the remaining capacity
of the knapsack drops by WT(<emphasis>i</emphasis>). So V(<emphasis>i</emphasis>-1, <emphasis>c</emphasis>-WT(<emphasis>i</emphasis>)) represents
the best vale that can be obtained from the remaining items with this new capacity.
Since we are including item <emphasis>i</emphasis> in the knapsack, VALUE(<emphasis>i</emphasis>) is added.
hence V(<emphasis>i</emphasis>-1, <emphasis>c</emphasis>-WT(<emphasis>i</emphasis>)) + VALUE(<emphasis>i</emphasis>) represents the optimal value if
the <emphasis>ith</emphasis> item is taken.</paragraph><paragraph>Whichever is the larger of (A) and (B) above represents the solution
to the capacity <emphasis>c</emphasis> problem for items chosen from among 1, 2, 3, ..., <emphasis>i</emphasis>.
If (A) is larger, the item should not be included in the knapsack. If
(B) is larger, the item should be included in the knapsack. If the numbers
are equal it does not matter if the item is included or not. For the rest of the
discusion on this page, if (A) and (B) are equal, <strong>dont include the item in the
knapsack</strong>. In the equal case it does not matter if the item is taken or left, so to
remain consistent it will always be left out of the solution set.</paragraph></list_item></enumerated_list></list_item></enumerated_list><paragraph>Using the definitions given above, An implementation of this algorithm in a java
like language would look something like this:</paragraph><literal_block xml:space="preserve">//this function behaves like the V(i,c) method defined previously
//in this chapter
int V(int i, int c){
    //base cases
    if(i == 0 || c == 0){
        return 0;
    }
    //item does not fit case
    if(wt(i) &gt; c){
        return V(i-1, c);
    }
    //compare best case if item i is taken or left behind.
    //and return the larger number.
    int B = V(i-1, c-wt(i)) + value(i);
    int A = V(i-1, c);
    if(A &gt;= B){
        return A;
    }
    else{
        return B;
    }
}</literal_block><paragraph>The efficency of this recusive approach would not be very good. Most call to this
algorithm would result in 2 additional recursive calls until a base case is
encountered. To demonstrate this, click the show button below to view a
visualization of the call tree this algorithm would produce working on a set of
three items. Every node in the tree represents a call to V(<emphasis>i</emphasis>, <emphasis>c</emphasis>).It should
be very apparent from the tree that the algorithm is of exponential efficency,
O(2 ^ <emphasis>N</emphasis>), where <emphasis>N</emphasis> is the number of items.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="sackCallTree"
    long_name="sackCallTree"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>Now, consider what makes a problem suited to dynamic programing.</paragraph><bullet_list bullet="-"><list_item><paragraph>The problems solution is initially formulated in a recursive fashion.</paragraph></list_item><list_item><paragraph>The recursion involved in the solution typically results in making multiple
recursive calls using the same values for parameters to the function. That is,
to solve the original problem, it is necessary to have the solution to particular
smaller versions of the problem computed many times. This is the key of nearly
all problems to which dynamic programming can be applied.</paragraph></list_item><list_item><paragraph>the value returned by the recursive function is of a type that can be stored
in a data structure capable of being indexed by critical parameters of the
function. This data structure can be used to stor previously computed
instances of the solution to the problem, thereby replacing recursive
recomputation with fast O(1) recall of previously computed values.</paragraph></list_item></bullet_list><paragraph>The recursive solution to the 0/1 Knapsack problem definatly meets all three
of the criterion above. The call tree visualization above clearly shows that
large amounts of work is being repeated. The value returned by our V(<emphasis>i</emphasis>, <emphasis>c</emphasis>)
are simple integers,that could easily be stored in a two dimensional array.
The following visualization shows how dynamic programming could be used to
greatly increase the efficency of the original recursive algorithm.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="sackTreePluck"
    long_name="sackTreePluck"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>One important thing to notice is, although this algorithm finds the optimal value,
it does not find the item set that produced the value. To answer the 0/1
Knapsack problem, some additional work is required. Recall that the larger
of the two values, A or B, shows what action is taken on a particular item.
If A was larger or equal, the item <emphasis>is not</emphasis> in the solution set. If B was larger
the item <emphasis>is</emphasis> part of the solution. In the visualization below, the optimal
solution set is recovered from a complete table of optimal values for the
set of items.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="sackTraceBack"
    long_name="sackTraceBack"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>But how would a complete table of values be easily obtained? Recall that the two
function calls are V(<emphasis>i</emphasis>-1, <emphasis>c</emphasis>) and V(<emphasis>i</emphasis>-1, <emphasis>c</emphasis>-WT(<emphasis>i</emphasis>)). As it turns out,
each row in the table only depends on the row above it. With this fact known,
it is simple to see that the table can be filled in with an iterative approach.
The code below shows how the table could be generated in a java like language.</paragraph><literal_block xml:space="preserve">int v(int n, int cap)
{
    int table[][] = new int[n+1][cap+1];
    for(int i = 0; i &lt;= n; i++){
        for(int j = 0; j &lt;= cap; j++){
            //base case
            if(i == 0 || j == 0)
                table[i][j] = 0;
            else{
                //item wont fit case
                if(wt(i) &gt; j)
                    table[i][j] = table[i-1][j];
                else{
                    int A,B;
                    B = table[i-1][j-wt(i)] + value(i);
                    A = table[i-1][j];
                    if(A &gt;= B)
                        table[i][j] = A;
                    else
                        table[i][j] = B;
                }
            }
        }
    }
    //some code could go here to recover the solution set.

    //return the optimal value
    return table[i][j];
}</literal_block><paragraph>The algorithm above creates the full table and returns the value of a particular
optimal solution. A small bit of code could be added to the end of the algorithm
to obtain the item set of the solution with little trouble. As an exercise,
try modifing the function above to obtain and return the optimal solution set,
and implement it in you language of choice. The efficency of the algorithm
above is O(<emphasis>N</emphasis> * <emphasis>CAP</emphasis>), because each cell in the table requires constant
work to fill. This is a huge improvement over the orignal efficency of
O(2 ^ <emphasis>N</emphasis>).</paragraph><paragraph>A series of exercises are provided to help you test your knowlege of the
0/1 Knapsack algorithm. Some of the exercises are easier if you have some
scratch paper to work on.</paragraph></section><section ids="exercise-1" names="exercise\ 1"><title>Exercise 1</title><paragraph>In the exercise below, you are provided a row of the table from the previous
algorithm. Determine if the item with weigh and value given on the left should
be taken as part of the optimal solution.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="knapsackSelect"
    long_name="knapsackSelect"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="exercise-2" names="exercise\ 2"><title>Exercise 2</title><paragraph>This next exercise has you fill in an entire row of the table. Enter the answer
as a list of integers sparated by spaces or commas. Clicking a cell in the table
will hilight the cell, alowing you to keep your place as you progress</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="knapsackFillRow"
    long_name="knapsackFillRow"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="exercise-3" names="exercise\ 3"><title>Exercise 3</title><paragraph>In this exercise you must determine the correct set of items to produce the
optimal solution. To select an item, click on the item's column in the item table
on the left. You can also select cells in the main table like you could in the
previous exercise.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="knapsackSolution"
    long_name="knapsackSolution"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="exercise-4" names="exercise\ 4"><title>Exercise 4</title><paragraph>For a final proficency exercise, you will be required to select values from the
"choices" list and put them into the correct location in the table. You must
follow the order that the recursive algorithm would use to enter fill in cells,
or your grade will not increase. You can check your grade at any time by clicking
on the grade button. If you make a mistake, the undo button can be used as much
as you like. A new set of data can be generated by clicking the reset button.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="sackProficiency"
    long_name="sackProficiency"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw></section></document>