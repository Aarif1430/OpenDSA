<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.2a -->
<document dupnames="heapsort" ids="heapsort" source="&lt;string&gt;" title="Heapsort"><title>Heapsort</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><index>null</index></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Development/HeapSortAnalysisCON.css</odsalink></raw><section dupnames="heapsort" ids="id1"><title>Heapsort</title><paragraph>Our discussion of Quicksort began by considering the practicality of
using a BST for sorting.
The BST requires more space than the other sorting methods and will
be slower than Quicksort or Mergesort due to the relative expense of
inserting values into the tree.
There is also the possibility that the BST might be unbalanced,
leading to a <math>\Theta(n^2)</math> worst-case running time.
Subtree balance in the BST is closely related to Quicksort's partition
step.
Quicksort's pivot serves roughly the same purpose as the BST root
value in that the left partition (subtree) stores values less than
the pivot (root) value, while the right partition (subtree) stores
values greater than or equal to the pivot (root).</paragraph><paragraph>A good sorting algorithm can be devised based on a tree structure more
suited to the purpose.
In particular, we would like the tree to be balanced, space efficient,
and fast.
The algorithm should take advantage of the fact that sorting is a
special-purpose application in that all of the values to be stored are
available at the start.
This means that we do not necessarily need to insert one value at a
time into the tree structure.</paragraph><paragraph><title_reference>Heapsort</title_reference> is based on the
<title_reference>heap &lt;heap&gt; &lt;Heaps&gt;</title_reference> data structure.
Heapsort has all of the advantages just listed.
The complete binary tree is balanced, its array representation is
space efficient, and we can load all values into the tree at once,
taking advantage of the efficient <literal>buildheap</literal> function.
The asymptotic performance of Heapsort when all of the records have
unique key values is <math>\Theta(n \log n)</math> in the best, average,
and worst cases.
It is not as fast as Quicksort in the average case (by a constant
factor), but Heapsort has special properties that will make it
particularly useful for
<title_reference>external sorting &lt;external sort&gt; &lt;ExternalSort&gt;</title_reference> algorithms,
used when sorting data sets too large to fit in main memory.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="heapsortCON"
    long_name="heapsortCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>A complete implementation is as follows.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>Here is a warmup practice exercise for Heapsort.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="HeapsortStepPRO"
    long_name="HeapsortStepPRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="heapsort-proficiency-practice" names="heapsort\ proficiency\ practice"><title>Heapsort Proficiency Practice</title><paragraph>Now test yourself to see how well you understand Heapsort.
Can you reproduce its behavior?</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="heapsortPRO"
    long_name="heapsortPRO"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw></section><section ids="heapsort-analysis" names="heapsort\ analysis"><title>Heapsort Analysis</title><paragraph>This visualization presents the running time analysis of Heap Sort</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="HeapSortAnalysisCON"
    long_name="HeapSortAnalysisCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>While typically slower than Quicksort by a constant factor
(because unloading the heap using <literal>removemax</literal> is somewhat slower
than Quicksort's series of partitions), Heapsort
has one special advantage over the other sorts studied so far.
Building the heap is relatively cheap, requiring
<math>\Theta(n)</math> time.
Removing the maximum-valued record from the heap requires
<math>\Theta(\log n)</math> time.
Thus, if we wish to find the <math>k</math> records with the largest
key values in an array, we can do so in time
<math>\Theta(n + k \log n)</math>.
If <math>k</math> is small, this is a substantial improvement over the time
required to find the <math>k</math> largest-valued records using one of the
other sorting methods described earlier (many of which would require
sorting all of the array first).
One situation where we are able to take advantage of this concept is
in the implementation of
<title_reference>Kruskal's algorithm &lt;Kruskal's algorithm&gt; &lt;MCST&gt;</title_reference> for
<title_reference>minimal-cost spanning trees &lt;minimal-cost spanning tree&gt;</title_reference>.
That algorithm requires that edges be visited in ascending
order (so, use a min-heap), but this process stops as soon as the MST
is complete.
Thus, only a relatively small fraction of the edges need be sorted.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="HeapsortSumm"
    long_name="HeapsortSumm"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>DataStructures/binaryheap.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Sorting/heapsortCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Development/HeapSortAnalysisCON.js</odsascript></raw></section></document>