{"document": {"@dupnames": "linear\\ indexing", "@ids": "linear-indexing", "@source": "<string>", "@title": "Linear Indexing", "title": "Linear Indexing", "subtitle": {"@dupnames": "linear\\ indexing", "@ids": "id1", "#text": "Linear Indexing"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Indexing/linearIndexingCON.css"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "varindexCON", "@long_name": "varindexCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "linindexCON", "@long_name": "linindexCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "linearIndexingPRO", "@long_name": "linearIndexingPRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}, {"@format": "xml", "@ids": "twodarray", "@names": "twodarray", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "inverted", "@names": "inverted", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "invlist", "@names": "invlist", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Indexing/varindexCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Indexing/linindexCON.js"}], "paragraph": [{"title_reference": ["linear index", "index file", "key-value pairs <key-value pair>", "keys <key>", "primary key", "binary search <binary search> <ProgAnal>"], "#text": "A  is an  organized as a\nsequence of  where the\n are in sorted order and the pointers either\n(1) point to the position of the complete record on disk,\n(2) point to the position of the  in the primary\nindex, or\n(3) are actually the value of the primary key.\nDepending on its size, a linear index might be stored in main\nmemory or on disk.\nA linear index provides a number of advantages.\nIt provides convenient access to variable-length database records,\nbecause each entry in the index file contains a fixed-length key field\nand a fixed-length pointer to the beginning of a (variable-length)\nrecord as shown in the following slideshow\nA linear index also allows for efficient search and random access to\ndatabase records, because it is amenable to\n."}, {"title_reference": ["main memory", "disk accesses <disk access>"], "#text": "If the database contains enough records, the linear index might\nbe too large to store in .\nThis makes binary search of the index more expensive because many\n would typically be required by the\nsearch process.\nOne solution to this problem is to store a second-level linear index\nin main memory that indicates which disk block in the index file\nstores a desired key.\nFor example, the linear index on disk might reside in a series of\n1024-byte blocks.\nIf each key/pointer pair in the linear index requires 8~bytes\n(a 4-byte key and a 4-byte pointer), then\n128 key/pointer pairs are stored per block.\nThe second-level index, stored in main memory, consists of a simple\ntable storing the value of the key in the first position of each block\nin the linear index file.\nThis arrangement is shown in the next slideshow.\nIf the linear index requires 1024 disk blocks (1MB), the second-level\nindex contains only 1024 entries, one per disk block."}, "To find which disk block contains a desired search key value,\nfirst search through the 1024-entry table to\nfind the greatest value less than or equal to the search key.\nThis directs the search to the proper block in the index file, which\nis then read into memory.\nAt this point, a binary search within this block\nwill produce a pointer to the actual record in the database.\nBecause the second-level index is stored in main memory,\naccessing a record by this method requires two disk reads:\none from the index file and one from the database file for the actual\nrecord.", "Every time a record is inserted to or deleted from the database,\nall associated secondary indices must be updated.\nUpdates to a linear index are expensive, because the\nentire contents of the array might be shifted.\nAnother problem is that multiple records with\nthe same secondary key each duplicate that key value within the\nindex.\nWhen the secondary key field has many duplicates, such as when it has\na limited range (e.g., a field to indicate job category from among a\nsmall number of possible job categories),\nthis duplication might waste considerable space.", {"title_reference": "Figure #TwoDArray", "#text": "One improvement on the simple sorted array is a two-dimensional\narray where each row corresponds to a secondary key value.\nA row contains the primary keys whose records have the indicated\nsecondary key value.\nFigure  illustrates this approach.\nNow there is no duplication of secondary key values,\npossibly yielding a considerable space savings.\nThe cost of insertion and deletion is reduced, because only one row\nof the table need be adjusted.\nNote that a new row is added to the array when a new secondary key\nvalue is added.\nThis might lead to moving many records, but this will happen\ninfrequently in applications suited to using this arrangement."}, "A drawback to this approach is that the array must be of fixed\nsize, which imposes an upper limit on the number of primary keys\nthat might be associated with a particular secondary key.\nFurthermore, those secondary keys with fewer records than the width\nof the array will waste the remainder of their row.\nA better approach is to have a one-dimensional array of secondary key\nvalues, where each secondary key is associated with a linked\nlist.\nThis works well if the index is stored in main memory, but not so\nwell when it is stored on disk because the linked list for a given key\nmight be scattered across several disk blocks.", {"title_reference": ["inverted list", "inverted file", "Figure #Inverted"], "#text": "Consider a large database of employee records.\nIf the primary key is the employee's ID number and the secondary key\nis the employee's name, then each record in the name index associates a\nname with one or more ID numbers.\nThe ID number index in turn associates an ID number with a unique\npointer to the full record on disk.\nThe secondary key index in such an organization is also known as an\n or .\nIt is inverted in that searches work backwards from the\nsecondary key to the primary key to the actual data record.\nIt is called a list because each secondary key value\nhas (conceptually) a list of primary keys associated with it.\nFigure  illustrates this arrangement.\nHere, we have last names as the secondary key.\nThe primary key is a four-character unique identifier."}, {"title_reference": "Figure #InvList", "#text": "Figure  shows a better approach to storing inverted\nlists.\nAn array of secondary key values is shown as before.\nAssociated with each secondary key is a pointer to an array of primary\nkeys.\nThe primary key array uses a linked-list implementation.\nThis approach combines the storage for all of the secondary key lists\ninto a single array, probably saving space.\nEach record in this array consists of a primary key value and a\npointer to the next element on the list.\nIt is easy to insert and delete secondary keys from this array, making\nthis a good implementation for disk-based inverted files."}], "target": [{"@refid": "twodarray"}, {"@refid": "inverted"}, {"@refid": "invlist"}]}}