{"document": {"@ids": "optimal-sorting", "@names": "optimal\\ sorting", "@source": "<string>", "@title": "Optimal Sorting", "title": "Optimal Sorting", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@ids": "bininsert", "@names": "bininsert", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "binmerge10", "@names": "binmerge10", "@xml:space": "preserve", "odsafig": "null"}], "paragraph": ["What if we would like to find the sorting algorithm\nwith the absolute fewest possible comparisons?\nIt might well be that the result will not be practical for a\ngeneral-purpose use.\nBut consider this analogy to sports tournaments.\nIn sports, a \"comparison\" between two teams or individuals means\ndoing a competition between the two.\nThis is fairly expensive (at least compared to some minor book keeping\nin a computer), and it might be worth trading a fair amount\nof book keeping to cut down on the number of games that need to be\nplayed.\nWhat if we want to figure out how to hold a tournament that will give\nus the exact ordering for all teams in the fewest number of total\ngames?\nOf course, we are assuming that the results of each game will be\n\"accurate\" in that we assume not only that the outcome of A\nplaying B would always be the same (at least over the time\nperiod of the tournament), but that transitivity in\nthe results also holds.\nIn practice these are unrealistic assumptions, but such assumptions\nare implicitly part of many tournament organizations.\nLike most tournament organizers, we can simply accept these\nassumptions and come up with an algorithm for playing the games that\ngives us some rank ordering based on the results we obtain.", {"title_reference": ["i", "i-1", "i", "binary insert sort", "i/2"], "emphasis": "only", "#text": "Recall Insertion Sort, where we put\nelement  into a sorted sublist of the first \nelements.\nWhat if we modify the standard Insertion Sort algorithm to use binary\nsearch to locate where the  th element goes in the sorted\nsublist?\nThis algorithm is called .\nAs a general-purpose sorting algorithm, this is not practical because\nwe then have to (on average) move about  elements to make\nroom for the newly inserted element in the sorted sublist.\nBut if we count  comparisons, binary insert sort is pretty\ngood.\nAnd we can use some ideas from binary insert sort to get closer to an\nalgorithm that uses the absolute minimum number of comparisons needed\nto sort."}, {"title_reference": ["2^i - 1", "2^i", "2^i"], "#text": "Consider what happens when we run binary insert sort on five elements.\nHow many comparisons do we need to do?\nWe can insert the second element with one comparison, the third with\ntwo comparisons,\nand the fourth with 2 comparisons.\nWhen we insert the fifth element into the sorted list of four\nelements, we need to do three comparisons in the worst case.\nNotice exactly what happens when we attempt to do this insertion.\nWe compare the fifth element against the second.\nIf the fifth is bigger, we have to compare it against the third, and\nif it is bigger we have to compare it against the fourth.\nIn general, when is binary search most efficient?\nWhen we have  elements in the list.\nIt is least efficient when we have  elements in the list.\nSo, we can do a bit better if we arrange our insertions to avoid\ninserting an element into a list of size  if possible."}, {"title_reference": ["Figure #BinInsert", "A", "B", "Figure #BinInsert", "A"], "#text": "Figure  illustrates a different organization\nfor the comparisons that we might do.\nFirst we compare the first and second element, and the third and\nfourth elements.\nThe two winners are then compared, yielding a binomial tree.\nWe can view this as a (sorted) chain of three elements, with element\n hanging off from the root.\nIf we then insert element  into the sorted chain of three\nelements, we will end up with one of the two posets shown on the right\nside of Figure , at a cost of 2 comparisons.\nWe can then merge  into the chain, for a cost of two\ncomparisons (because we already know that it is smaller then either one\nor two elements, we are actually merging it into a list of two or\nthree elements).\nThus, the total number of comparisons needed to sort the five elements\nis at most seven instead of eight."}, "If we have ten elements to sort, we can first make five pairs of\nelements (using five compares) and then sort the five winners\nusing the algorithm just described (using seven more compares).\nNow all we need to do is to deal with the original losers.\nWe can generalize this process for any number of elements as:", {"title_reference": ["2^i", "2^{i+1} -1", "merge insert sort", "Ford and Johnson sort"], "#text": "We use binary insert to place the losers.\nHowever, we are free to choose the best ordering for inserting,\nkeeping in mind the fact that binary search has the same cost for\n through  items.\nFor example, binary search requires three comparisons in the worst\ncase for lists of size 4, 5, 6, or 7.\nSo we pick the order of inserts to optimize the binary searches, which\nmeans picking an order that avoids growing a sublist size such that it\ncrosses the boundary on list size to require an additional comparison.\nThis sort is called , and also known as the\n."}, {"title_reference": "Figure #BinMerge10", "#text": "For ten elements, given the poset shown in\nFigure  we\nfold in the last four elements (labeled 1 to 4) in the order Element 3,\nElement 4, Element 1, and finally Element 2.\nElement 3 will be inserted into a list of size three, costing two\ncomparisons.\nDepending on where Element 3 then ends up in the list, Element 4 will\nnow be inserted into a list of size 2 or 3, costing two comparisons in\neither case.\nDepending on where Elements 3 and 4 are in the list, Element 1 will\nnow be inserted into a list of size 5, 6, or 7, all of which requires\nthree comparisons to place in sort order.\nFinally, Element 2 will be inserted into a list of size 5, 6, or 7."}, {"title_reference": ["sorting lower bound proof <sorting lower bound> <SortingLowerBound>", "Omega(n log n)", "information theoretic lower bound", "lceil log n!rceil", "lceil log n!rceil", "n = 12", "n = 12", "n=12"], "#text": "Merge insert sort is pretty good, but is it optimal?\nWe know from the\n\nthat no sorting algorithm can be faster than .\nTo be precise, the  for\nsorting can be proved to be .\nThat is, we can prove a lower bound of exactly\n comparisons.\nMerge insert sort gives us a number of comparisons equal to this\ninformation theoretic lower bound for all values up to\n.\nAt , merge insert sort requires 30 comparisons while the\ninformation theoretic lower bound is only 29 comparisons.\nHowever, for such a small number of elements, it is possible to do an\nexhaustive study of every possible arrangement of comparisons.\nIt turns out that there is in fact no possible arrangement of\ncomparisons that makes the lower bound less than 30 comparisons when\n.\nThus, the information theoretic lower bound is an underestimate in this\ncase, because 30 really is the best that can be done."}, {"title_reference": ["n", "S(n)", "S(n+1) leq S(n) + lceil log (n+1)rceil", "n", "n", "m", "S(n+m) leq S(n) + S(m) + M(m, n)", "M(m, n)", "n = 47"], "#text": "Call the optimal worst cost for  elements .\nWe know that \nbecause we could sort  elements and use binary insert for the\nlast one.\nFor all  and ,\n where\n is the best time to merge two sorted lists.\nFor , it turns out that we can do better by splitting the\nlist into pieces of size 5 and 42, and then merging.\nThus, merge sort is not quite optimal.\nBut it is extremely good, and nearly optimal for smallish numbers of\nelements."}], "target": [{"@refid": "bininsert"}, {"@refid": "binmerge10"}], "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": {"title_reference": "lfloor frac{n}{2} rfloor", "#text": "Pair up all the nodes with \ncomparisons."}}, {"paragraph": "Recursively sort the winners."}, {"paragraph": "Fold in the losers."}]}}}