{"document": {"@dupnames": "binary\\ tree\\ space\\ requirements", "@ids": "binary-tree-space-requirements", "@source": "<string>", "@title": "Binary Tree Space Requirements", "title": "Binary Tree Space Requirements", "subtitle": {"@dupnames": "binary\\ tree\\ space\\ requirements", "@ids": "id1", "#text": "Binary Tree Space Requirements"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "TreeOverheadFIB", "@long_name": "TreeOverheadFIB", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "paragraph": [{"title_reference": ["overhead", "binary tree", "full binary tree <full tree>"], "#text": "This module presents techniques for calculating the amount of\n required by a ,\nbased on its node implementation.\nRecall that overhead is the amount of space necessary to maintain the\ndata structure.\nIn other words, it is any space not used to store data records.\nThe amount of overhead depends on several factors including which\nnodes store data values (all nodes, or just the leaves),\nwhether the leaves store child pointers, and whether the tree is a\n."}, {"title_reference": ["pointer-based implementation for binary tree nodes <pointer-based implementation for binary tree nodes> <BinaryTreeImpl>", "n(2P + D)", "n", "P", "D", "2Pn", "2P/(2P + D)", "P = D"], "#text": "In a simple\n,\nevery node has two pointers to its children (even when the children\nare NULL).\nThis implementation requires total space amounting to\n for a tree of  nodes.\nHere,  stands for the amount of space required by a pointer,\nand  stands for the amount of space required by a data value.\nThe total overhead space will be  for the entire tree.\nThus, the overhead fraction will be .\nThe actual value for this expression depends on the relative size of\npointers versus data fields.\nIf we arbitrarily assume that , then a binary tree\nhas about two thirds of its total space taken up in overhead.\nWorse yet, the Full Binary Tree Theorem tells us that about half of\nthe pointers are \"wasted\" NULL values that serve only to indicate tree\nstructure, but which do not provide access to new data."}, {"title_reference": "3P/(3P + D)", "#text": "In many languages (such as Java or JavaScript), the most typical\nimplementation is not to store any actual\ndata in a node, but rather a pointer to the data record.\nIn this case, each node will typically store three pointers, all of\nwhich are overhead, resulting in an overhead fraction of\n."}, "If only leaves store data values, then the fraction of total space\ndevoted to overhead depends on whether the tree is\nfull.\nIf the tree is not full, then conceivably there might only be one leaf\nnode at the end of a series of internal nodes.\nThus, the overhead can be an arbitrarily high percentage for non-full\nbinary trees.\nThe overhead fraction drops as the tree becomes closer to full,\nbeing lowest when the tree is truly full.\nIn this case, about one half of the nodes are internal.", "Great savings can be had by eliminating the pointers from leaf\nnodes in full binary trees.\nAgain assume the tree stores a pointer to the data field.\nBecause about half of the nodes are leaves and half internal nodes,\nand because only internal nodes now have child pointers, the\noverhead fraction in this case will be approximately", {"title_reference": "P = D", "#text": "If , the overhead drops to about one half of the\ntotal space.\nHowever, if only leaf nodes store useful information, the overhead\nfraction for this implementation is actually three quarters of the\ntotal space, because half of the \"data\" space is unused."}, "If a full binary tree needs to store data only\nat the leaf nodes, a better implementation would have\nthe internal nodes store two pointers and no data\nfield while the leaf nodes store only a pointer to the data field.\nThis implementation requires", {"title_reference": ["P = D", "3P/(3P + D) = 3/4"], "#text": "units of space.\nIf , then the overhead is\n.\nIt might seem counter-intuitive that the overhead ratio has gone up\nwhile the total amount of space has gone down.\nThe reason is because we have changed our definition of \"data\" to\nrefer only to what is stored in the leaf nodes,\nso while the overhead fraction is higher, it is from a\ntotal storage requirement that is lower."}, {"literal": "isLeaf", "#text": "There is one serious flaw with this analysis.\nWhen using separate implementations for internal and leaf nodes,\nthere must be a way to distinguish between the node types.\nWhen separate node types are implemented via Java subclasses,\nthe runtime environment stores information with\neach object allowing it to determine, for example, the correct\nsubclass to use when the  virtual function\nis called.\nThus, each node requires additional space.\nOnly one bit is truly necessary to distinguish the two possibilities.\nIn rare applications where space is a critical resource,\nimplementors can often find a spare bit within the node's value field\nin which to store the node type indicator.\nAn alternative is to use a spare bit within a node pointer to\nindicate node type.\nFor example, this is often possible when the compiler requires that\nstructures and objects start on word boundaries, leaving the last bit\nof a pointer value always zero.\nThus, this bit can be used to store the node-type flag and is reset to\nzero before the pointer is dereferenced.\nAnother alternative when the leaf value field is smaller than a\npointer is to replace the pointer to a leaf with that leaf's value.\nWhen space is limited, such techniques can make the difference between\nsuccess and failure.\nIn any other situation, such \"bit packing\" tricks should be\navoided because they are difficult to debug and understand at\nbest, and are often machine dependent at worst."}], "math_block": [{"@xml:space": "preserve", "#text": "\\frac{\\frac{n}{2} (2P)}{\\frac{n}{2} (2P) + Dn} =\n\\frac{P}{P + D}"}, {"@xml:space": "preserve", "#text": "\\frac{n}{2}2P + \\frac{n}{2}(P+D)"}]}}