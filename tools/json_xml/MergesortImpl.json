{"document": {"@dupnames": "implementing\\ mergesort", "@ids": "implementing-mergesort", "@source": "<string>", "@title": "Implementing Mergesort", "title": "Implementing Mergesort", "subtitle": {"@dupnames": "implementing\\ mergesort", "@ids": "id1", "#text": "Implementing Mergesort"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "mergeImplS1CON", "@long_name": "mergeImplS1CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "mergeImplS2CON", "@long_name": "mergeImplS2CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "MergesortSumm", "@long_name": "MergesortSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/mergeImplS1CON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/mergeImplS2CON.js"}], "paragraph": [{"literal": "merge", "#text": "Implementing Mergesort presents a number of technical difficulties.\nThe first decision is how to represent the lists.\nMergesort lends itself well to sorting a singly linked list because\nmerging does not require random access to the list elements.\nThus, Mergesort is the method of choice when the input is in the form\nof a linked list.\nImplementing  for linked lists is straightforward,\nbecause we need only remove items from the front of the input lists\nand append items to the output list.\nBreaking the input list into two equal halves presents some\ndifficulty.\nIdeally we would just break the lists into front and back halves.\nHowever, even if we know the length of the list in advance, it would\nstill be necessary to traverse halfway down the linked list to reach\nthe beginning of the second half.\nA simpler method, which does not rely on knowing the length of the\nlist in advance, assigns elements of the input list alternating\nbetween the two sublists.\nThe first element is assigned to the first sublist, the\nsecond element to the second sublist, the third to first sublist, the\nfourth to the second sublist, and so on.\nThis requires one complete pass through the input list to build the\nsublists."}, {"math": "\\log n", "#text": "When the input to Mergesort is an array, splitting input into two\nsubarrays is easy if we know the array bounds.\nMerging is also easy if we merge the subarrays into a second array.\nNote that this approach requires twice the amount of space as any of\nthe sorting methods presented so far, which is a serious disadvantage\nfor Mergesort.\nIt is possible to merge the subarrays without using a second array,\nbut this is extremely difficult to do efficiently and is\nnot really practical.\nMerging the two subarrays into a second array, while\nsimple to implement, presents another difficulty.\nThe merge process ends with the sorted list in the auxiliary array.\nConsider how the recursive nature of Mergesort breaks\nthe original array into subarrays.\nMergesort is recursively called until subarrays of size 1 have been\ncreated, requiring  levels of recursion.\nThese subarrays are merged into subarrays of size 2, which are in\nturn merged into subarrays of size 4, and so on.\nWe need to avoid having each merge operation\nrequire a new array.\nWith some difficulty, an algorithm can be\ndevised that alternates between two arrays.  A much simpler approach\nis to copy the sorted sublists to the auxiliary array first, and then\nmerge them back to the original array."}, {"literal": ["A", "temp", "left", "right", "mergesort", "mergesort(array, temparray, 0, n-1)"], "#text": "Here is a complete implementation for mergesort following this\napproach.\nThe input records are in array .\nArray  is used as a place to temporarily copy records during\nthe merge process.\nParameters  and  define the left and right\nindices, respectively, for the subarray being sorted.\nThe initial call to  would be\n."}, "Here is a visualization for the merge step.", {"literal": "THRESHOLD", "#text": "An optimized Mergesort implementation is shown below.\nIt reverses the order of the second subarray during the initial copy.\nNow the current positions of the two subarrays work inwards from the\nends, allowing the end of each subarray to act as a sentinel for the\nother.\nUnlike the previous implementation, no test is needed to check for\nwhen one of the two subarrays becomes empty.\nThis version also has a second optimization:\nIt uses Insertion Sort to sort small subarrays whenever the size of\nthe array is smaller than a value defined by ."}, "Here is a visualization for the optimized merge step."]}}