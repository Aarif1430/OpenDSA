<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="grammars-part-3" names="grammars\ -\ part\ 3" source="&lt;string&gt;" title="Grammars - Part 3"><title>Grammars - Part 3</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-13 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/PL/AV/parseTree.css</odsalink></raw><comment xml:space="preserve">(F 2/5/16)</comment><section ids="rp-3-part-1" names="rp\ 3\ part\ 1"><title>RP 3 part 1</title><paragraph>In this module we will learn about</paragraph><block_quote><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Operator precedence</paragraph></list_item><list_item><paragraph>Operator associativity</paragraph></list_item><list_item><paragraph>EBNF extensions and their advantages</paragraph></list_item></enumerated_list></block_quote><paragraph>In the previous module, we saw that ambiguous grammars are to be avoided because the parse trees that result from them lead to confusion when we attach semantic meaning to the structure of the parse tree. The tree cannot be relied on to specify the order of operations.</paragraph><block_quote><paragraph>Although <title_reference>eg1</title_reference> does not suffer from ambiguity, it has another problem.  In particular, if you return to the parse tree slide-show that accompanied <title_reference>eg1</title_reference>, you will note that in parsing <math>A+B*C</math>, the <math>+</math> operation was at a deeper level in the tree than <math>*</math>, thereby indicating that <math>A+B</math> would be evaluated first and then multiplied by <math>C</math>.  However that order of operation does not coincide with the operator precedence rules in almost every programming language.  So <title_reference>eg1</title_reference>, although unambiguous, is not the algebraic expression grammar that we need.  Instead consider:</paragraph></block_quote><section ids="example-grammar-3" names="example\ grammar\ 3"><title>Example Grammar 3</title><math_block xml:space="preserve">\begin{eqnarray*}
&lt;exp&gt; &amp;::=&amp; &lt;trm&gt;\\
&amp;|&amp; &lt;exp&gt; + &lt;trm&gt; \\
&amp;|&amp; &lt;exp&gt; - &lt;trm&gt; \\
&lt;trm&gt; &amp;:==&amp; &lt;fac&gt; \\
&amp;|&amp;  &lt;trm&gt; * &lt;fac&gt; \\
&amp;|&amp;  &lt;trm&gt; / &lt;fac&gt; \\
&lt;fac&gt; &amp;::=&amp; &lt;pri&gt; \\
&amp;|&amp; ( &lt;exp&gt; ) \\
&lt;pri&gt; &amp;:==&amp; A | B | C | \ldots | X | Y | Z
\end{eqnarray*}</math_block><paragraph>Note how the parse tree in the slide-show below produced by Example Grammar 3 is different from the one produced by <title_reference>eg1</title_reference>.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="parseTree3"
    long_name="parseTree3"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>In particular, with Example Grammar 3, the sub-tree corresponding to the
multiplication operator is at a deeper level than the sub-tree for addition,
thereby corresponding to normal operator precedence in programming
languages.</paragraph><paragraph>Below you have a slide-show "producer" for Example Grammar 3 that you can
control by entering the expression for which you want a parse tree
produced.  You should experiment  with producing a variety of
slide-shows until you feel confident that you could manually construct
the parse tree corresponding to any possible expression.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="parseTree3a"
    long_name="parseTree3a"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>Once you feel confident working with parse trees, here are two
questions to consider before you start on the review problems for this
module.</paragraph><paragraph><strong>Question 1:</strong> If you are designing a grammar corresponding to expressions, what is the strategy you would employ for introducing a different level of operator precedence -- one that is either higher or lower than that of other operators?  How would this strategy play out with respect to Example Grammar 3 if you wanted to add an operator corresponding to exponentiation?</paragraph><paragraph><strong>Question 2:</strong> In Example Grammar 3, operators on the same level of precedence associate in left-to-right fashion, that is, <math>A+B-C</math> evaluates as the parenthesized expression <math>((A+B)-C)</math>.  What about the grammar dictates this left-to-right associativity?  How would you change the productions to achieve right-to-left associativity, that is, <math>(A+(B-C))</math>?</paragraph><paragraph>The review problem set for this module contains five review problems,
the first four of which concern themselves with how a grammar dictates
operator precedence and associativity.  Do not start these problems
until you have thought through answers to the two questions posed
above.</paragraph><paragraph>The first problem illustrates how grammatical structure influences the
evaluation of arithmetic expressions, and thus the semantics of
programs.  Note that, <strong>to get credit for the first problem,</strong> you
must solve it correctly three times in a row because the question is
randomized.  After you get the question right one time, the <emphasis>Check
Answer</emphasis> button will then allow you to proceed to the next instance of
the question.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP3part1"
    long_name="RP3part1"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section></section><section ids="rp-3-part-2" names="rp\ 3\ part\ 2"><title>RP 3 part 2</title><paragraph>This problem demonstrates how grammatical structure impacts the
associativity property of arithmetic operators.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP3part2"
    long_name="RP3part2"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="rp-3-part-3" names="rp\ 3\ part\ 3"><title>RP 3 part 3</title><paragraph>This problem illustrates how grammatical structure impacts the
associativity property and order of precedence of arithmetic
operators.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP3part3"
    long_name="RP3part3"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="rp-3-part-4" names="rp\ 3\ part\ 4"><title>RP 3 part 4</title><paragraph>This problem asks you to provide a characterization in English of the
language generated by a BNF grammar.   After you finish it, there is one more problem about Extended Backus-Naur Form, which is described before the problem.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP3part4"
    long_name="RP3part4"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="rp-3-part-5" names="rp\ 3\ part\ 5"><title>RP 3 part 5</title><paragraph>The symbols we have used in our representation of grammars
collectively comprise what is known as <emphasis>Backus-Naur Form</emphasis> (BNF).  In
<emphasis>Extended Backus-Naur Form</emphasis> (EBNF) we add five meta-symbols to those
already used in BNF notation:</paragraph><block_quote><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Kleene closure operator <math>*</math>, which means "zero or more" Hence if <math>&lt;fn\_name&gt;</math>   were a non-terminal representing a valid function name and <math>&lt;parameter&gt;</math> were a non-terminal representing a valid parameter, then the EBNF notation for function calls with zero or more parameters would be</paragraph><math_block xml:space="preserve">&lt;fn\_name&gt; "(" &lt;parameter&gt;* ")"</math_block></list_item><list_item><paragraph>Positive closure operator <math>+</math>.  The EBNF notation for function calls that must have at least one parameter would be</paragraph><math_block xml:space="preserve">&lt;fn\_name&gt; "(" &lt;parameter&gt;+ ")"</math_block></list_item><list_item><paragraph>The two paired parenthesis symbols <math>( \; )</math>, which are used for grouping.  For example, if <math>&lt;positive\_number&gt;</math> were the non-terminal denoting a valid positive number, then the following EBNF would dictate that we <emphasis>must</emphasis> have a plus or minus sign preceding a number</paragraph></list_item></enumerated_list><block_quote><math_block xml:space="preserve">(+ | -) &lt;positive\_number&gt;</math_block></block_quote><enumerated_list enumtype="arabic" prefix="" start="4" suffix="."><list_item><paragraph>The "optional operator" <math>?</math>, which specifies that you can have zero or one of whatever grammatical structure precedes the operator.  For example, if our language allowed an optional plus or minus sign in front of a number, we would use the EBNF</paragraph><math_block xml:space="preserve">(+ | -)? &lt;positive\_number&gt;</math_block></list_item></enumerated_list></block_quote><paragraph>EBNF is used to reduce the number of productions a grammar needs to
specify a language.  However, it does not increase the expressive power of
grammars, that is, any grammatical structure that can be expressed in
EBNF can also be expressed in BNF if one is willing to use more
productions.</paragraph><paragraph>This last problem is about the equivalence between a given BNF grammar (the
same one as in part 4 above) and a smaller EBNF grammar.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP3part5"
    long_name="RP3part5"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>Exercises/PL/RP3part1.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/PL/AV/parseTree3.js</odsascript></raw></section></document>