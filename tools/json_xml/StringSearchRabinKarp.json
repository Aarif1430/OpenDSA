{"document": {"@ids": "rabin-karp-string-search-algorithm-draft", "@names": "rabin-karp\\ string\\ search\\ algorithm\\ [draft]", "@source": "<string>", "@title": "Rabin-Karp String Search Algorithm [Draft]", "title": "Rabin-Karp String Search Algorithm [Draft]", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}, {"@xml:space": "preserve"}, {"@xml:space": "preserve"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "Rabin_Karp_Horner_Slideshow", "@long_name": "Rabin_Karp_Horner_Slideshow", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "Rabin_Karp_Horners_Exercise", "@long_name": "Rabin_Karp_Horners_Exercise", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "Rabin_Karp_Algorithm_Slideshow", "@long_name": "Rabin_Karp_Algorithm_Slideshow", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "Rabin_Karp_Next_Step", "@long_name": "Rabin_Karp_Next_Step", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "paragraph": [{"math": ["C", "S", "s_0,\ns_1, \\ldots s_{n-1}", "c\n\\rightarrow \\hat{c}", "c", "\\hat{c}", "0 \\ldots c - 1"], "#text": "The Rabin-Karp algorithm is based on what could be imagined as a\n\"perfect hash function for strings\".  We will assume that our\nstrings are drawn from an alphabet with  possible\ncharacters. Denote the characters in string  by .  Suppose that we have a mapping  that associates with each character  an\ninteger  in the range .  Then a\n\"perfect hash function for strings\" is:"}, {"math": ["C", "mod"], "#text": "Suppose that we call this a string's \"magic number\".  In effect it\nassociates each string with a unique number in the base \nnumber system.  However, nothing is perfect -- these magic numbers for\nstrings get very big very quickly.  Hence the following sub-algorithm\nof Rabin-Karp to compute a string's magic number (which is itself\nknown as Horner's polynomial evaluation algorithm) takes this into\naccount by using the  operator to avoid an overflow\ncondition."}, "Slideshow for Horner's Method algorithm for computing Rabin-Karp \"magic number\" for a string", "To check your understanding of this \"magic number\" computation try the\nfollowing exercise in using Horner's Method to compute a string's\n\"magic number\" in a simple case", "Because Horner's Method cannot truly compute a magic number that is\nunique for every string, the Rabin-Karp algorithm must allow for two\ndifferent strings having the same magic number.  In effect, such a\nsituation represents a \"false positive\" in which Rabin-Karp thinks it\nhas found a match only to be disappointed.  Watch Rabin-Karp in action\nin the following slideshow.", "Finally try this exercise in tracing one step of the Rabin-Karp\nalgorithm using the modified Horner's algorithm to compute the \"magic\nnumber\" of a string."], "math_block": {"@xml:space": "preserve", "#text": "\\widehat{s_0} \\times C^{n-1} + \\widehat{s_1} \\times C^{n-2} + \\ldots + \\widehat{s_{n-2}} \\times C + \\widehat{s_{n-1}} \\times C^0"}}}