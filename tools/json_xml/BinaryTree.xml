<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="binary-trees" names="binary\ trees" source="&lt;string&gt;" title="Binary Trees"><title>Binary Trees</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Binary/BinExampCON.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Binary/BinDiffCON.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Binary/FullCompCON.css</odsalink></raw><section ids="definitions-and-properties" names="definitions\ and\ properties"><title>Definitions and Properties</title><paragraph>A <title_reference>binary tree</title_reference> is made up of a finite set of elements
called <title_reference>nodes &lt;node&gt;</title_reference>.
This set either is empty or consists of a node called the
<title_reference>root</title_reference> together with two binary trees, called the left and
right
<title_reference>subtrees &lt;subtree&gt;</title_reference>, which are disjoint from each other and
from the root.
(Disjoint means that they have no nodes in common.)
The roots of these subtrees are
<title_reference>children &lt;child&gt;</title_reference> of the root.
There is an <title_reference>edge</title_reference> from a node to each of its children,
and a node is said to be the <title_reference>parent</title_reference> of its children.</paragraph><paragraph>If <title_reference>n_1, n_2, ..., n_k</title_reference>
is a sequence of nodes in the tree such
that <title_reference>n_i</title_reference> is the parent of
<title_reference>n_i+1</title_reference> for <title_reference>1 leq i &lt; k</title_reference>,
then this sequence is called a <title_reference>path</title_reference> from
<title_reference>n_1</title_reference> to <title_reference>n_k</title_reference>.
The <title_reference>length</title_reference> of the path is <title_reference>k-1</title_reference>.
If there is a path from node <title_reference>R</title_reference> to node <title_reference>M</title_reference>,
then <title_reference>R</title_reference> is an <title_reference>ancestor</title_reference> of <title_reference>M</title_reference>, and
<title_reference>M</title_reference> is a <title_reference>descendant</title_reference> of <title_reference>R</title_reference>.
Thus, all nodes in the tree are descendants of the root of the tree,
while the root is the ancestor of all nodes.
The <title_reference>depth</title_reference> of a node <title_reference>M</title_reference> in the tree is the length
of the path from the root of the tree to <title_reference>M</title_reference>.
The <title_reference>height</title_reference> of a tree is one more than the depth of the
deepest node in the tree.
All nodes of depth <title_reference>d</title_reference> are at
<title_reference>level</title_reference> <title_reference>d</title_reference> in the tree.
The root is the only node at level 0, and its depth is 0.
A <title_reference>leaf node</title_reference> is any node that has two empty children.
An <title_reference>internal node</title_reference> is
any node that has at least one non-empty child.</paragraph><target refid="binexample"></target><raw format="xml" ids="binexample" names="binexample" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="BinExampCON"
    long_name="BinExampCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><target refid="bindiff"></target><raw format="xml" ids="bindiff" names="bindiff" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="BinDiffCON"
    long_name="BinDiffCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Figure <title_reference>Figure #BinExample</title_reference> illustrates the various terms used to
identify parts of a binary tree.
Figure <title_reference>Figure #BinDiff</title_reference> illustrates an important point regarding
the structure of binary trees.
Because <emphasis>all</emphasis> binary tree nodes have two children
(one or both of which might be empty), the two binary
trees of Figure <title_reference>Figure #BinDiff</title_reference> are <emphasis>not</emphasis> the same.</paragraph><paragraph>Two restricted forms of binary tree are sufficiently
important to warrant special names.
Each node in a <title_reference>full binary tree &lt;full tree&gt;</title_reference>
is either (1) an internal node with exactly two non-empty children or
(2) a leaf.
A <title_reference>complete binary tree</title_reference> has a restricted shape obtained by
starting at the root and filling the tree by levels from left to
right.
In the complete binary tree of height <title_reference>d</title_reference>, all levels
except possibly level <title_reference>d-1</title_reference> are completely full.
The bottom level has its nodes filled in from the left side.</paragraph><target refid="fullcomplete"></target><raw format="xml" ids="fullcomplete" names="fullcomplete" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="FullCompCON"
    long_name="FullCompCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Figure <title_reference>Figure #FullComplete</title_reference> illustrates the differences between
full and complete binary trees.
There is no particular relationship between these two tree shapes;
that is, the tree of Figure <title_reference>Figure #FullComplete</title_reference> (a) is full
but not complete while the tree of Figure <title_reference>Figure #FullComplete</title_reference>
(b) is
complete but not full.
The <title_reference>heap &lt;heap&gt; &lt;Heaps&gt;</title_reference> data structure is an example
of a complete binary tree.
The <title_reference>Huffman coding tree &lt;Huffman coding tree&gt; &lt;Huffman&gt;</title_reference>
is an example of a full binary tree.</paragraph><footnote auto="1" ids="id1" names="1"><label>1</label><paragraph>While these definitions for full and complete binary tree are
the ones most commonly used, they are not universal.
Because the common meaning of the words "full" and "complete"
are quite similar, there is little that you can do to
distinguish between them other than to memorize the
definitions.
Here is a memory aid that you might find useful:
"Complete" is a wider word than "full", and complete binary
trees tend to be wider than full binary trees because each
level of a complete binary tree is as wide as possible.</paragraph></footnote><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="DefSumm"
    long_name="DefSumm"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="practice-questions" names="practice\ questions"><title>Practice Questions</title><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="Treeprobs"
    long_name="Treeprobs"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/BinExampCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/BinDiffCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/FullCompCON.js</odsascript></raw></section></document>