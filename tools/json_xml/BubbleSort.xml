<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="bubble\ sort" ids="bubble-sort" source="&lt;string&gt;" title="Bubble Sort"><title>Bubble Sort</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><index>null</index></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Sorting/BubbleSortAnalysisCON.css</odsalink></raw><section dupnames="bubble\ sort" ids="id1"><title>Bubble Sort</title><paragraph>Our next sorting algorithm is called <title_reference>Bubble Sort</title_reference>.
Bubble Sort is often taught to novice programmers in
introductory computer science courses.
This is unfortunate, because Bubble Sort has no redeeming features
whatsoever.
It is rather slow, even compared to the other <title_reference>Theta(n^2)</title_reference>
sorts that are commonly known.
It is not particularly intutitive --
nobody is going to come naturally to Bubble Sort as a way to sort
their Bridge hand or their pile of bills like they might with
<title_reference>Insertion Sort &lt;insertion sort&gt; &lt;InsertionSort&gt;</title_reference> or
<title_reference>Selection Sort &lt;selection sort&gt; &lt;SelectionSort&gt;</title_reference>.
However, Bubble Sort can viewed as a close relative of
Selection Sort.</paragraph><paragraph>Like Insertion Sort, Bubble Sort consists of a simple double <literal>for</literal>
loop.
The inner <literal>for</literal> loop moves through the record array from left to
right, comparing adjacent keys.
If a record's key value is greater than the key of its right
neighbor, then the two records are swapped.
Once the record with the largest key value is encountered, this
process will cause it to "bubble" up to the right of the array
(which is where Bubble Sort gets its name).
The second pass through the array repeats this process.
However, because we know that the record with the largest value
already reached the right of the array on the first pass, there is no
need to compare the rightmost two records on the second pass.
Likewise, each succeeding pass through the array compares adjacent
records, looking at one less record toward the end than did the
preceding pass.
Here is an implementation.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="bubblesortS1CON"
    long_name="bubblesortS1CON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Now we continue with the second pass. However, since the largest
record has "bubbled" to the very right, we will not need to look at
it again.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="bubblesortS2CON"
    long_name="bubblesortS2CON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Bubble Sort continues in this way until the entire array is sorted.</paragraph><paragraph>The following visualization shows the complete Bubble Sort.
You can input your own data if you like.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="bubblesortAV"
    long_name="bubblesortAV"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>Now try for yourself to see if you understand how Bubble Sort works.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="BubsortPRO"
    long_name="BubsortPRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="bubble-sort-analysis" names="bubble\ sort\ analysis"><title>Bubble Sort Analysis</title><paragraph>The following visualization illustrates the running time analysis of
Bubble Sort.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="BubbleSortAnalysisCON"
    long_name="BubbleSortAnalysisCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Thus, Bubble Sort's running time is roughly the same
in the best, average, and worst cases.</paragraph><paragraph>The number of swaps required depends on how often a
record's value is less than that of the record immediately preceding
it in the array.
We can expect this to occur for about half the comparisons in the
average case, leading to <title_reference>Theta(n^2)</title_reference> for the
expected number of swaps.
The actual number of swaps performed by Bubble Sort will be identical
to that performed by Insertion Sort.</paragraph><paragraph>Here are some review questions to check your understanding of
Bubble Sort.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="BubsortSumm"
    long_name="BubsortSumm"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Sorting/bubblesortS1CON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Sorting/bubblesortS2CON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Sorting/BubbleSortAnalysisCON.js</odsascript></raw></section></document>