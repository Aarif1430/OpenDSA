{"document": {"@ids": "lambda-calculus", "@names": "lambda\\ calculus", "@source": "<string>", "@title": "Lambda Calculus", "title": "Lambda Calculus", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}, {"@xml:space": "preserve", "#text": "Slideshow for Free/Bound Vars"}, {"@xml:space": "preserve", "#text": "Slideshow for Alpha Conversion"}, {"@xml:space": "preserve", "#text": "Exercise for AlphaConversion"}, {"@xml:space": "preserve", "#text": "Exercise for AlphaConversion"}, {"@xml:space": "preserve", "#text": "A fundamental tool in evaluating expressions in the lambda calculus is"}, {"@xml:space": "preserve", "#text": "the notion of substitution.  For the application of a function to its"}, {"@xml:space": "preserve", "#text": "argument, we need merely substitute the argument for the formal"}, {"@xml:space": "preserve", "#text": "parameter in the expression that defines the function, being careful"}, {"@xml:space": "preserve", "#text": "to first alpha convert if doing this would capture a free variable."}, {"@xml:space": "preserve", "#text": "This is called beta conversion, and"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "FreeBoundCON", "@long_name": "FreeBoundCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "LambdaCalcFree", "@long_name": "LambdaCalcFree", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "LambdaCalcBound", "@long_name": "LambdaCalcBound", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "AlphaConversionCON", "@long_name": "AlphaConversionCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "AlphaConversionChoice", "@long_name": "AlphaConversionChoice", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "AlphaConversionHighlight", "@long_name": "AlphaConversionHighlight", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "paragraph": ["The lambda calculus is a small language defined by the following BNF\ngrammar.", "The above BNF grammar tells us that expressions in the lambda calculus come in one of three flavors:", {"title_reference": ["application", "beta-redex"], "math": ["(y \\; z)", "y", "z"], "literal": "y(z)", "#text": "3. An  (the third production). For example\n.  Think of this as \"the application of  to\n\".  This represents a \"function call\" in the lambda calculus.\nIn JavaScript, such a function call would appear as .  The\nformal name of an application whose first component is a function\nabstraction is a .  We will soon explain why this\nterminology is appropriate in the context of the operations we perform\nto \"evaluate\" expressions in the lambda calculus."}, {"math": ["\\lambda x.x", "y", "(\\lambda x.x \\; y)"], "#text": "For example, to apply the identity function  to the\nvariable , we would write .   In\nJavaScript, this would be:"}, {"math": ["a", "b", "(\\lambda x.x \\; (a \\; b))"], "#text": "The expression that would apply the identity function to the\napplication of  to  would appear as .  Note how essential the parentheses are in this\nnotation.  Every parenthesis means something very specific, so using\ngratuitous extra parentheses  will inevitably result in a lambda calculus expression with a totally different meaning or an expression  that\nviolates the BNF grammar."}, {"title_reference": ["bound", "free"], "math": ["\\lambda", "x"], "#text": "A variable is  in an expression if it refers to the formal\nparameter (the variable immediately following the  symbol) in a\nfunction abstraction.  A variable is  in an expression if it is\nnot bound.  In terms of a more precise recursive definition, a\nvariable  occurs free in expression E if:"}, "To illustrate the difference between free and bound variables.", {"math": ["(\\lambda x.x \\; x)", "x"], "#text": "Note that it is possible for a variable to occur both free and bound\nin the same expression.  Consider .  Here\nthe first occurrence of  is the formal parameter of the\nfunction abstraction, the second occurrence is bound to that formal\nparameter, and the third occurrence is free."}, "Before seeing how lambda calculus expressions are evaluated, we need\nsome practice in identifying free and bound variables.  Try the following two exercises:", {"math": ["(\\lambda x.(x \\; y) \\; z)", "((x \\; y) \\; z)", "(\\lambda x.(x \\; y) \\; z)", "(z \\; y)"], "#text": "How should one evaluate a lambda expression?  We first need to realize\nthat, if by evaluate we mean to \"call a function and see what it\nreturns\", then it only makes sense to evaluate a beta-redex, that is,\nan application in which the first expression is a function\nabstraction.  For instance  is a\nbeta-redex, but  is not.  In the lambda\ncalculus, we evaluate a beta-redex by substituting the second\ncomponent of the application expression for the formal parameter of\nthe function abstraction in the \"body\" of the function, that is, in the expression following the dot that occurs in the syntax of the\nfunction abstraction.  For instance, carrying out this substitution in\n would result in"}, "It is important to realize this idea of substitution makes sense in terms of the way we think about calling functions in everyday programming.   For example, suppose we had the JavaScript function", "and we called it by:", {"math": "z * (x - y)", "#text": "A reasonable way to describe the value returned would be to say \"substitute 8 for x, 6 for y, and 4 for z in the expression ."}, {"title_reference": "beta-reducing", "#text": "The act of doing this substitution is called  the\nlambda expression.   Hence we now see the rationale for the term\nbeta-redex that we introduced earlier.   A beta-redex is the one and\nonly type of lambda expression that can be beta-reduced."}, {"math": ["(\\lambda\nx.\\lambda y.(y \\; x) \\; y)", "\\lambda y.(y \\; y)"], "#text": "What can go wrong when we do this substitution to carry out a\nbeta-reduction in the lambda calculus?  By substituting one\nvariable for another, a variable that was free in an expression may\nbecome bound.  For instance, in the expression , the last occurrence of y in this\napplication is free.  But if we beta-reduce, the result will be\n and the free y that was substituted for the\nformal parameter x is now bound.  This is a result we need to avoid.\nTo see why consider the following simple example:"}, {"math": "(\\lambda x.z \\; x)"}, {"math": ["\\lambda x.z", "z", "x", "z", "x", "z"], "#text": "Here  is the function that always returns\n, which here is a free variable.  If we beta-reduce by\nsubstituting the last free occurrence of  for , the free  is now bound and the function becomes the identity function, which is very different from the function that always returns ,"}, {"title_reference": "alpha-convert", "math": ["y", "\\lambda y.(y \\; x)", "w", "\\lambda w.(w \\; x)", "\\lambda y.(y \\; x)", "\\lambda p.b"], "#text": "To keep from capturing a free variable in this fashion, we must  the expression that would cause\nthe  to become bound.  The intuitive justification of alpha-conversion\nis that we do not change the function abstraction  if we choose a different variable, say , to use as the formal\nparameter for the function.  That is, as a function definition,\n is equivalent to .   To carry out alpha-conversion on a function abstraction like , we\nsimply replace each free occurrence of p (the formal parameter) in b (the \"body\" of the function) by a new variable symbol not occurring anywhere in the body.    To illustrate this, consider:"}, "Practice alpha conversion with the following exercise:", "You can get some more alpha conversion practice with the following exercise:", "The  rule to remember here is that, before substituting in a lambda\nexpression to carry out a beta-reduction, be sure to check whether\nthat substitution will capture any free variable, making it become a\nbound variable.  If it will, alpha-convert the expression before\nbeta-reducing it.", {"title_reference": "beta-normal", "#text": "To fully evaluate a lambda calculus expression, we may have to perform\nmultiple beta reductions.  This must be done until there are no more\nbeta-redexes left in the expression.  At that point, the expression,\nfully evaluated, is said to be in  form.  Since this\ninvolves potentially multiple beta reductions, we have a choice for\nthe order in which the individual beta conversions are performed."}], "math_block": {"@xml:space": "preserve", "#text": "\\begin{eqnarray*}\n<\\mathrm{LambdaExp}> &::=& <\\mathrm{var}>\\\\\n                     &|& \\lambda <\\mathrm{var}> . <\\mathrm{LambdaExp}>\\\\\n                     &|& (<\\mathrm{LambdaExp}> <\\mathrm{LambdaExp}>)\\\\\n\\end{eqnarray*}"}, "enumerated_list": [{"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": {"paragraph": {"title_reference": "variable", "math": "x", "#text": "A  (the first production).   For example ."}}}, {"@enumtype": "arabic", "@prefix": "", "@start": "2", "@suffix": ".", "list_item": {"paragraph": {"title_reference": "function abstraction", "math": ["\\lambda x.y", "x", "y"], "#text": "A  (the second production). For example   .  Think of this as the \"function whose formal   parameter is  and whose return value is \".   The equivalent in JavaScript would be:"}}}], "block_quote": {"paragraph": {"math": "x, y, a_1, b, p_2", "#text": "Typically we will use single letters or letters followed by a digit -  - to represent variables."}}, "literal_block": [{"@xml:space": "preserve", "#text": "function(x){\n  return y;\n}"}, {"@xml:space": "preserve", "#text": "(\nfunction(x){\n  return x;\n}\n)(y)"}, {"@xml:space": "preserve", "#text": "var foobar = function(x,y,z) { return  z * (x - y); }"}, {"@xml:space": "preserve", "#text": "foobar(8,6,4)"}], "bullet_list": {"@bullet": "-", "list_item": [{"paragraph": {"math": "x", "#text": "E is a variable and E is identical to  , or"}}, {"paragraph": {"math": "x", "#text": "E is of the form (E1 E2) and  occurs free in E1 or E2, or"}}, {"paragraph": {"math": ["\\lambda y.E'", "y", "x", "x"], "#text": "E is of the form  where  is different from  and  occurs free in E'."}}]}, "section": [{"@ids": "applicative-order-reduction", "@names": "applicative\\ order\\ reduction", "title": "Applicative Order Reduction", "paragraph": ["The strategy is characterized by first evaluating the beta-redexes\nthat are inside an application expression.  That is, we only perform\nan application when each of the internal beta-redexes has been\nbeta-reduced and there are no beta-redexes left except the topmost\napplication.  If there is more than one internal beta-redex to choose\nfrom, we select the leftmost innermost beta-redex first.  Consider:", "Practice an applicative order reduction in the following exercise:", "For some more practice, try:"], "comment": [{"@xml:space": "preserve", "#text": "Slideshow for Applicative order"}, {"@xml:space": "preserve", "#text": "Exercise for Applicative"}, {"@xml:space": "preserve", "#text": "Exercise for Applicative"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "BetaAppCON", "@long_name": "BetaAppCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "BetaReductionAppNextStep", "@long_name": "BetaReductionAppNextStep", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "BetaReductionAppHighlight", "@long_name": "BetaReductionAppHighlight", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "normal-order-reduction", "@names": "normal\\ order\\ reduction", "title": "Normal Order Reduction", "paragraph": ["This strategy reduces the leftmost outermost beta-redex first before reducing\nthe beta-redexes inside of it and those that follow it.  While\napplicative order proceeds by evaluating the internal beta-redexes and then\napplying the function, normal order evaluation proceeds by applying\nthe function first and then evaluating the internal beta-redexes.  Consider\nthe following example:", "Practice a normal order reduction in the following exercise:", "For some more practice, try:", "As a final test of your proficiency in doing beta reductions, try doing"], "comment": [{"@xml:space": "preserve", "#text": "Slideshow for Normal Order"}, {"@xml:space": "preserve", "#text": "Exercise for Normal"}, {"@xml:space": "preserve", "#text": "Exercise for Applicative"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "BetaNormCON", "@long_name": "BetaNormCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "BetaReductionNormNextStep", "@long_name": "BetaReductionNormNextStep", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "BetaReductionNormHighlight", "@long_name": "BetaReductionNormHighlight", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "BetaAppPro", "@long_name": "BetaAppPro", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "BetaNormPro", "@long_name": "BetaNormPro", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/FreeBoundCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/AlphaConversionCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/BetaAppCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/BetaNormCON.js"}], "enumerated_list": [{"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": {"paragraph": "All the steps in a complete applicative order reduction:"}}, {"@enumtype": "arabic", "@prefix": "", "@start": "2", "@suffix": ".", "list_item": {"paragraph": "All the steps in a complete normal order reduction"}}]}]}}