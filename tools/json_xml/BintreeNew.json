{"document": {"@dupnames": "the\\ bintree", "@ids": "the-bintree", "@source": "<string>", "@title": "The Bintree", "title": "The Bintree", "subtitle": {"@dupnames": "the\\ bintree", "@ids": "id1", "#text": "The Bintree"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Development/bintreeCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "DataStructures/PrQuadAv.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "DataStructures/PrQuadAvC.css"}, {"@format": "xml", "@ids": "bintreefig", "@names": "bintreefig", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "bintreeCONBTEX", "@long_name": "bintreeCONBTEX", "@points": "0", "@required": "True", "@threshold": "1.0"}}], "paragraph": [{"title_reference": ["discriminator", "key-space decomposition", "trie"], "#text": "This module presents a spatial data structure for storing\npoint data in two or more dimensions, called the Bintree.\nThe Bintree is a natural extension of the BST to\nmultiple dimensions.\nThe Bintree differs from the BST in two important ways.\nFirst, being a data structure for multiple dimensions, at each level\nof the tree the Bintree\nmakes branching decisions based on a particular search key associated\nwith that level, called the .\nIts splitting decisions alternate among the key dimensions.\nAnother difference from the BST is that the Bintree uses what is known\nas , and so is a form of .\nA key-space decomposition splits the key space into equal halves,\nrather than splitting at the key value of the object being stored."}, "In theory, the Bintree could be used to unify search across any\narbitrary set of keys such as name and zipcode.\nBut in practice, it is nearly always used to support search on\nmultidimensional coordinates, such as locations in 2D or 3D space.", {"math": ["i", "i \\bmod k", "k", "xy", "k", "x", "y", "x", "y", "N", "x", "x", "y"], "#text": "We define the discriminator at level  to be \nfor  dimensions.\nFor example, assume that we store data organized by \ncoordinates.\nIn this case,  is 2 (there are two dimensions), with the\n coordinate field arbitrarily designated key 0, and the\n coordinate field designated key 1.\nAt each level, the discriminator alternates between  and .\nThus, a node  at level 0 (the root) would split\nthe world in half with a vertical split.\nRecords with  coordinates in the lower half would be on the\nleft side of the dividing line, and thus in the left subtree.\nRecords with  coordinates in the upper half would be on the\nright side of the dividing line, and thus in the right subtree.\nAt this stage, the  coordinate value would play no role."}, {"math": "y", "#text": "At level 1, the  coordinate becomes the descriminator.\nIn other words, the left half of the world will be split horizontally\nin half if necessary."}, "A leaf node in the Bintree can either be empty, or it can contain one\ndata point (in which case it is referred to as being full).\nSplitting takes place whenever a point is to be inserted into a leaf\nnode that already contains a point.", {"math": "xy", "literal": "null", "#text": "Searching a Bintree for the record with a specified \ncoordinate is like searching a BST, except that each level of the\nBintree is associated with a particular discriminator.\nIf the search process reaches a  pointer, then\nthat point is not contained in the tree."}, {"math": ["A", "B", "A", "B", "B", "A", "A", "B"], "#text": "Inserting a new node into the Bintree is similar to\nBST insertion.\nThe Bintree search procedure is followed until a leaf node is found.\nIf the leaf node is empty, then it can store the new point.\nIf the leaf node already contains a point, then some additional work\nneeds to be done.\nCall the point already stored in the Bintree , and the new\nnode that we want to insert .\nWe must split the node containing A into two, replacing it with a new\ninternal node and two leaf children.\nRecord  is then placed in the appropriate child, and we\nrestart the insertion from the new internal node.\nIf  falls within in the newly created empty leaf node, then\nit can be inserted there.\nBut if  falls within the newly created leaf node that just\nreceived , then the splitting process must repeat.\nDepending on how far apart  and  are, it is possible\nthat many splits are required."}, "Deleting from a Bintree requires that sibling leaf nodes be merged\ntogether if they are empty.\nJust like an insert operation can cause many levels of splitting, a\ndelete operation can cause many levels of merging.", {"math": ["d", "P", "P", "d", "N", "\\sqrt{(P_x - N_x)^2 + (P_y - N_y)^2} \\leq d"], "footnote_reference": {"@auto": "1", "@ids": "id2", "@refid": "id3", "#text": "1"}, "#text": "Assume that we want to print out a list of all records that are within\na certain distance  of a given point .\nWe will use Euclidean distance, that is, point  is defined to\nbe within distance  of point  if\n."}, {"math": "d", "#text": "Search proceeds by means of a \"directed\" traversal.\nWhen we visit a node of the tree, we only proceed if\nthe bounding box for the search circle intersects the bounding box for\nthe node.\nIf it does not, we stop and return.\nIf it does intersect an internal node, we visit the node's children.\nIf it is a leaf node, then we ask whether the data point it contains\nis within distance  of the search point.\nIn the average case, the number of nodes that must be visited during a\nrange query is linear on the number of data records that fall within\nthe query circle."}], "target": {"@refid": "bintreefig"}, "section": {"@ids": "implementation-concerns", "@names": "implementation\\ concerns", "title": "Implementation Concerns", "paragraph": [{"title_reference": ["trie", "whether", "where"], "#text": "Let us now consider how the structure of the Bintree affects the\ndesign of its node representation.\nThe Bintree is actually a .\nThis means that decomposition takes place at the mid-points for\ninternal nodes,\nregardless of where the data points actually fall.\nThe placement of the data points does determine  a\ndecomposition for a node takes place, but not  the\ndecomposition for the node takes place.\nInternal nodes of the Bintree are quite different from leaf nodes, in\nthat internal nodes have children (leaf nodes do not) and leaf nodes\nhave data fields (internal nodes do not).\nThus, it is likely to be beneficial to represent internal nodes\ndifferently from leaf nodes.\nFinally, there is the fact that approximately half of the leaf nodes\nwill contain no data field."}, "Another issue to consider is: How does a routine traversing the\nBintree get the coordinates for the rectangle represented by the current\nBintree node?\nOne possibility is to store with each node its spatial description\n(such as upper-left corner and width).\nHowever, this will take a lot of space  perhaps as much as the\nspace needed for the data records, depending on what information is\nbeing stored.", "Another possibility is to pass in the coordinates when the recursive\ncall is made.\nFor example, consider the search process.\nInitially, the search visits the root node of the tree, which has\nupper left corner defined to be (0, 0) and whose width and height is\nthe full size of the space being  covered.\nWhen the appropriate child is visited, it is a simple matter for the\nsearch routine to determine the origin for the child, and the length\nof the descriminator dimention simply becomes\nhalf that of the parent.\nNot only does passing in the size and position information for a node\nsave considerable space, but avoiding storing such information\nin the nodes enables a good design choice for\nempty leaf nodes, as discussed next.", {"literal": ["null", "null"], "#text": "How should we represent empty leaf nodes?\nOn average, half of the leaf nodes in a Bintree are empty\n(i.e., do not store a data point).\nOne implementation option is to use a  pointer in internal\nnodes to represent empty nodes.\nThis will solve the problem of excessive space requirements.\nThere is an unfortunate side effect that using a  pointer\nrequires the Bintree processing methods to understand this convention.\nIn other words, you are breaking encapsulation on the node\nrepresentation because the tree now must know things about how the\nnodes are implemented.\nThis is not too horrible for this particular application, because the\nnode class can be considered private to the tree class, in which case\nthe node implementation is completely invisible to the outside world.\nHowever, it is undesirable if there is another reasonable alternative."}, {"title_reference": "all", "#text": "Fortunately, there is a good alternative.\nIt is called the Flyweight design pattern.\nIn the Bintree, a flyweight is a single empty leaf node that\nis reused in all places where an empty leaf node is needed.\nYou simply have  of the internal nodes with empty leaf\nchildren point to the same node object.\nThis node object is created once at the beginning of the program,\nand is never removed.\nThe node class recognizes from the pointer value that the flyweight is\nbeing accessed, and acts accordingly."}, {"title_reference": ["cannot", "only", "all"], "#text": "Note that when using the Flyweight design pattern, you \nstore coordinates for the node in the node.\nThis is an example of the concept of intrinsic versus extrinsic state.\nIntrinsic state for an object is state information stored in the object.\nIf you stored the coordinates for a node in the node object, those\ncoordinates would be intrinsic state.\nExtrinsic state is state information about an object stored elsewhere\nin the environment, such as in global variables or passed to the\nmethod.\nIf your recursive calls that process the tree pass in the coordinates\nfor the current node, then the coordinates will be extrinsic state.\nA flyweight can have in its intrinsic state \ninformation that is accurate for  instances of the flyweight.\nClearly coordinates do not qualify, because each empty\nleaf node has its own location.\nSo, if you want to use a flyweight, you must pass in coordinates."}, {"title_reference": ["composite design pattern", "Composite"], "#text": "Another design choice is: Who controls the work, the node\nclass or the tree class?\nFor example, on an insert operation, you could have the tree class\ncontrol the flow down the tree, looking at (querying) the nodes to see\ntheir type and reacting accordingly.\nThis is the approach used by the BST implementation in\nModule :numref`BST`.\nAn alternate approach is to have the node class do the work.\nThat is, you have an insert method for the nodes.\nIf the node is internal, it passes the city record to the appropriate\nchild (recursively).\nIf the node is a flyweight, it replaces itself with a new leaf node.\nIf the node is a full node, it replaces itself with a subtree.\nThis is an example of the ,\ndiscussed in Module .\nUse of the composite design would be difficult if null pointers are\nused to represent empty leaf nodes.\nIt turns out that the Bintree insert and delete methods are easier to\nimplement when using the composite design."}, "Below is a visualization of the Bintree. Use this visualization to\nhelp understand how the Bintree data structure works.", "Below is an interactive visualization of the Bintree for practice."], "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "NBintreeAV", "@long_name": "NBintreeAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "ClickableBintree", "@long_name": "ClickableBintree", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/bintreeCON.js"}], "footnote": {"@auto": "1", "@backrefs": "id2", "@ids": "id3", "@names": "1", "label": "1", "paragraph": {"math": "(P_x - N_x)^2 + (P_y - N_y)^2 \\leq d^2", "#text": "A more efficient computation is\n.\nThis avoids performing a square root function."}}}}}