{"document": {"@ids": "binary-trees-chapter-introduction", "@names": "binary\\ trees\\ chapter\\ introduction", "@source": "<string>", "@title": "Binary Trees Chapter Introduction", "title": "Binary Trees Chapter Introduction", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "paragraph": [{"title_reference": ["Tree <tree>", "Binary trees <binary tree>", "prioritizing jobs <priority queue> <Heaps>", "describing mathematical expressions <expression tree> <BinaryTreeImpl>", "data compression algorithms <Huffman codes> <Huffman>"], "#text": "structures enable efficient access and efficient\nupdate to large collections of data.\n in particular are widely used and\nrelatively easy to implement.\nBut binary trees are useful for many things besides searching.\nJust a few examples of applications that trees can speed up include\n,\n\nand the syntactic elements of computer programs,\nor organizing the information needed to drive\n."}, {"title_reference": ["tree traversals <tree traversal>", "nodes <node>"], "#text": "This chapter covers terminology used for discussing binary trees,\n, approaches to implementing\ntree , and various examples of binary trees."}]}}