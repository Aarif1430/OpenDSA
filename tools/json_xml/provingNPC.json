{"document": {"@dupnames": "np-completeness\\ proofs", "@ids": "np-completeness-proofs", "@source": "<string>", "@title": "NP-Completeness Proofs", "title": "NP-Completeness Proofs", "subtitle": {"@dupnames": "np-completeness\\ proofs", "@ids": "id1", "#text": "NP-Completeness Proofs"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@ids": "npcreduction", "@names": "npcreduction", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "NPCProofDiagramCON", "@long_name": "NPCProofDiagramCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/NP/NPCProofDiagramCON.js"}], "paragraph": [{"math": ["H", "X", "H", "X", "X", "H", "H", "X", "X", "H", "X", "X", "H", "H", "X", "X", "H"], "#text": "To start the process of being able to prove problems are NP-complete,\nwe need to prove just one problem  is NP-complete.\nAfter that, to show that any problem  is NP-hard, we just\nneed to reduce  to .\nWhen doing NP-completeness proofs, it is very important not to get\nthis reduction backwards!\nIf we reduce candidate problem  to known hard problem\n, this means that we use  as a step to solving\n.\nAll that means is that we have found a (known) hard way to\nsolve .\nHowever, when we reduce known hard problem  to candidate\nproblem , that means we are using  as a step to\nsolve .\nAnd if we know that  is hard, that means  must also\nbe hard (because if  were not hard, then neither would\n be hard)."}, "So a crucial first step to getting this whole theory off the ground is\nfinding one problem that is NP-hard.\nThe first proof that a problem is NP-hard (and because it is in NP,\ntherefore NP-complete) was done by Stephen Cook.\nFor this feat, Cook won the first Turing award, which is the closest\nComputer Science equivalent to the Nobel Prize.\nThe \"grand-daddy\" NP-complete problem that Cook used is called\nSATISFIABILITY (or SAT for short).", {"title_reference": ["Boolean expression", "literal", "clause", "Conjunctive Normal Form"], "math": ["\\cdot", "+", "x", "\\overline{x}", "E", "x_1, x_2, ..., x_n"], "#text": "A  includes Boolean variables combined\nusing the operators AND (), OR (), and NOT\n(to negate Boolean variable  we write ).\nA  is a Boolean variable or its negation.\nA  is one or more literals OR'ed together.\nLet  be a Boolean expression over variables\n.\nThen we define  (CNF) to be a Boolean\nexpression written as a series of clauses that are AND'ed together.\nFor example,"}, "is in CNF, and has three clauses.\nNow we can define the problem SAT.", {"math": ["F", "L"], "#text": "Cook proved that SAT is NP-hard.\nExplaining Cook's proof is beyond the scope of this course.\nBut we can briefly summarize it as follows.\nAny decision problem  can be recast as some language\nacceptance problem :"}, {"math": ["F", "I", "L", "I'", "I'", "I", "F", "I", "I", "I'", "L"], "#text": "That is, if a decision problem  yields YES on\ninput , then there is a language  containing\nstring  where  is some suitable\ntransformation of input .\nConversely, if  would give answer NO for input ,\nthen  's transformed version  is not in the\nlanguage ."}, {"emphasis": "any", "#text": "Turing machines are a simple model of computation for writing\nprograms that are language acceptors.\nThere is a \"universal\" Turing machine that can take as input a\ndescription for a Turing machine, and an input string, and return the\nexecution of that machine on that string.\nThis Turing machine in turn can be cast as a Boolean expression such\nthat the expression is satisfiable if and only if the Turing machine\nyields ACCEPT for that string.\nCook used Turing machines in his proof because they are simple enough\nthat he could develop this transformation of Turing machines to\nBoolean expressions, but rich enough to be able to compute any\nfunction that a regular computer can compute.\nThe significance of this transformation is that  decision\nproblem that is performable by the Turing machine is transformable to\nSAT.\nThus, SAT is NP-hard."}, {"math": ["X", "X", "X", "X", "A", "I", "A", "I'", "X", "SLN'", "SLN", "SLN", "I"], "emphasis": "arbitrary", "#text": "To show that a decision problem \nis NP-complete, we prove that  is in NP (normally easy, and\nnormally done by giving a suitable polynomial-time, non-deterministic\nalgorithm) and then prove that  is NP-hard.\nTo prove that  is NP-hard, we choose a known NP-complete\nproblem, say .\nWe describe a polynomial-time transformation that takes an\n instance  of  to an instance\n of .\nWe then describe a polynomial-time transformation from\n to  such that  is the solution\nfor ."}, "The following modules show a number of known NP-complete problems, and\nalso some proofs that they are NP-complete.\nThe various proofs will link the problems together as shown here:"], "math_block": [{"@xml:space": "preserve", "#text": "E = (x_5 + x_7 + \\overline{x_8} + x_{10}) \\cdot (\\overline{x_2} + x_3)\n\\cdot (x_1 + \\overline{x_3} + x_6)"}, {"@xml:space": "preserve", "#text": "F(I) = \\mbox{YES} \\Leftrightarrow L(I') = \\mbox{ACCEPT}."}], "topic": {"title": "Problem", "paragraph": ["SATISFIABILITY (SAT)", {"strong": "Input:", "math": ["E", "x_1, x_2, ..."], "#text": "A Boolean expression  over variables\n in Conjunctive Normal Form."}, {"strong": "Output:", "math": "E", "#text": "YES if there is an assignment to the\nvariables that makes  true, NO otherwise."}]}, "target": {"@refid": "npcreduction"}}}