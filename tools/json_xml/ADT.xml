<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="abstract\ data\ types" ids="abstract-data-types" source="&lt;string&gt;" title="Abstract Data Types"><title>Abstract Data Types</title><subtitle dupnames="abstract\ data\ types" ids="id1">Abstract Data Types</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Design/ADTCON.css</odsalink></raw><paragraph>This module presents terminology and definitions related to techniques
for managing the tremendous complexity of computer programs.
It also presents working definitions for the fundamental but somewhat
slippery terms "<title_reference>data item</title_reference>" and "<title_reference>data structure</title_reference>".
We begin with the basic elements on which data structures are built.</paragraph><paragraph>A <title_reference>type</title_reference> is a collection of values.
For example, the Boolean type consists of the values <literal>true</literal> and
<literal>false</literal>.
The integers also form a type.
An integer is a <title_reference>simple type</title_reference>
because its values contain no subparts.
A bank account record will typically contain several pieces of
information such as name, address, account number, and account
balance.
Such a record is an example of an <title_reference>aggregate type</title_reference> or
<title_reference>composite type</title_reference>.
A <title_reference>data item</title_reference> is a piece of information
or a record whose value is drawn from a type.
A data item is said to be a <title_reference>member</title_reference> of a type.</paragraph><paragraph>A <title_reference>data type</title_reference> is a type together with a collection of operations
to manipulate the type.
For example, an integer variable is a member of the integer data
type.
Addition is an example of an operation on the integer data type.</paragraph><paragraph>A distinction should be made between the
logical concept of a data type and its physical implementation in a
computer program.
For example, there are two traditional implementations
for the list data type:
the linked list and the array-based list.
The list data type can therefore be implemented using a linked list or
an array.
But we don't need to know how the list is implemented when we wish to
use a list to help in a more complex design.
For example, a list might be used to help implement a
<title_reference>graph data structure &lt;graph&gt; &lt;GraphImpl&gt;</title_reference>.</paragraph><paragraph>As another example, the term "array" could refer either
to a data type or an implementation.
"Array" is commonly used in computer programming to mean a
contiguous block of memory locations,
where each memory location stores one fixed-length data item.
By this meaning, an array is a physical data structure.
However, array can also mean a logical data type composed of a
(typically homogeneous) collection of data items, with each data item
identified by an index number.
It is possible to implement arrays in many different ways besides as a
block of contiguous memory locations.
The <title_reference>sparse matrix &lt;sparse matrix&gt; &lt;SparseMatrix&gt;</title_reference>
refers to a large, two-dimensional array
that stores only a relatively few non-zero values.
This is often implemented with a linked structure, or possibly using a
<title_reference>hash table &lt;hash table&gt; &lt;HashIntro&gt;</title_reference>.
But it could be implemented with an interface that uses traditional
row and column indices, thus appearing to the user in the same way
that it would if it had been implemented as a block of contiguous
memory locations.</paragraph><paragraph>An <title_reference>abstract data type</title_reference> (ADT) is the specification of a data type
within some language, independent of an implementation.
The interface for the ADT is defined in terms of a type and a set of
operations on that type.
The behavior of each operation is determined by its inputs and outputs.
An ADT does not specify <emphasis>how</emphasis> the data type is implemented.
These implementation details are hidden from the user of the ADT and
protected from outside access, a concept referred to as
<title_reference>encapsulation</title_reference>.</paragraph><paragraph>A <title_reference>data structure</title_reference> is the implementation for an ADT.
In an object-oriented language,
an ADT and its implementation together make up a <title_reference>class</title_reference>.
Each operation associated with the ADT is implemented by a
<title_reference>member function</title_reference> or <title_reference>method</title_reference>.
The variables that define the space required by a data item are
referred to as <title_reference>data members &lt;data member&gt;</title_reference>.
An <title_reference>object</title_reference> is an instance of a class, that is, something that
is created and takes up storage during the execution of a
computer program.</paragraph><paragraph>The term <title_reference>data structure</title_reference> often refers to data
stored in a computer's main memory.
The related term  <title_reference>file structure</title_reference>
often refers to the organization of data on peripheral storage, such
as a disk drive or CD.</paragraph><topic><title>Example</title><paragraph>The mathematical concept of an integer, along with operations
that manipulate integers, form a data type.
The <literal>int</literal> variable type is a physical representation of
the abstract integer.
The <literal>int</literal> variable type, along with the operations that act on an
<literal>int</literal> variable, form an ADT.
Unfortunately, the <literal>int</literal> implementation is not
completely true to the abstract integer, as there are limitations on
the range of values an <literal>int</literal> variable can store.
If these limitations prove unacceptable, then some other
representation for the ADT "integer" must be devised, and a new
implementation must be used for the associated operations.</paragraph></topic><topic><title>Example</title><paragraph>An ADT for a list of integers might specify the following operations:</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Insert a new integer at a particular position in the list.</paragraph></list_item><list_item><paragraph>Return <literal>True</literal> if the list is empty.</paragraph></list_item><list_item><paragraph>Reinitialize the list.</paragraph></list_item><list_item><paragraph>Return the number of integers currently in the list.</paragraph></list_item><list_item><paragraph>Delete the integer at a particular position in the list.</paragraph></list_item></enumerated_list><paragraph>From this description, the input and output of each operation should
be clear, but the implementation for lists has not been
specified.</paragraph></topic><paragraph>One application that makes use of some ADT might use particular
member functions of that ADT more than a second application, or the
two applications might have different time requirements for the
various operations.
These differences in the requirements of applications are the reason
why a given ADT might be supported by more than one implementation.</paragraph><topic><title>Example</title><paragraph>Two popular implementations for large disk-based
database applications are <title_reference>hashing &lt;hashing&gt; &lt;HashIntro&gt;</title_reference>
and the <title_reference>B-tree &lt;B-tree&gt; &lt;BTree&gt;</title_reference>.
Both support efficient insertion and deletion of records, and both
support exact-match queries.
However, hashing is more efficient than the B-tree for
exact-match queries.
On the other hand, the B-tree can perform range queries
efficiently, while hashing is hopelessly inefficient for
range queries.
Thus, if the database application limits searches to exact-match
queries, hashing is preferred.
On the other hand, if the application requires support for range
queries, the B-tree is preferred.
Despite these performance issues, both implementations solve
versions of the same problem: updating and searching a large
collection of records.</paragraph></topic><paragraph>The concept of an ADT can help us to focus on key issues even in
non-computing applications.</paragraph><topic><title>Example</title><paragraph>When operating a car, the primary activities are steering,
accelerating, and braking.
On nearly all passenger cars, you steer by turning the steering
wheel, accelerate by pushing the gas pedal, and brake by pushing
the brake pedal.
This design for cars can be viewed as an ADT with operations
"steer", "accelerate", and "brake".
Two cars might implement these operations in radically different
ways, say with different types of engine, or front- versus
rear-wheel drive.
Yet, most drivers can operate many different cars because the ADT
presents a uniform method of operation that does not require the
driver to understand the specifics of any particular engine or
drive design.
These differences are deliberately hidden.</paragraph></topic><paragraph>The concept of an ADT is one instance of an
important principle that must be understood by any successful
computer scientist: managing complexity through
abstraction.
A central theme of computer science is complexity and
techniques for handling it.
Humans deal with complexity by assigning a label to an assembly of
objects or concepts and then manipulating the label in place of the
assembly.
Cognitive psychologists call such a label a
<title_reference>metaphor</title_reference>.
A particular label might be related to other pieces of information or
other labels.
This collection can in turn be given a label,
forming a hierarchy of concepts and labels.
This hierarchy of labels allows us to focus on
important issues while ignoring unnecessary details.</paragraph><topic><title>Example</title><paragraph>We apply the label "hard drive" to a collection of
hardware that manipulates data on a particular type of
storage device, and we apply the label "CPU" to the hardware that
controls execution of computer instructions.
These and other labels are gathered together under the label
"computer".
Because even the smallest home computers today have millions of
components, some form of abstraction is necessary to comprehend how
a computer operates.</paragraph></topic><paragraph>Consider how you might go about the process of designing a complex
computer program that implements and manipulates an ADT.
The ADT is implemented in one part
of the program by a particular data structure.
While designing those parts of the program that use the ADT,
you can think in terms of operations on the data type without
concern for the data structure's implementation.
Without this ability to simplify your thinking about a complex
program, you would have no hope of understanding or implementing it.</paragraph><topic><title>Example</title><paragraph>Consider the design for a relatively simple database system stored
on disk.
Typically, records on disk in such a program are accessed through a
<title_reference>buffer pool &lt;buffer pool&gt; &lt;BuffPool&gt;</title_reference> rather than directly.
Variable length records might use a
<title_reference>memory manager &lt;memory manager&gt; &lt;MemmanIntro&gt;</title_reference> to find an
appropriate location within the disk file to place the record.
Multiple <title_reference>index structures &lt;indexing&gt; &lt;IndexIntro&gt;</title_reference>
will typically be used to support access to a collection of records
using multiple <title_reference>search keys &lt;search key&gt;</title_reference>.
Thus, we have a chain of classes, each with its own responsibilities
and access privileges.
A database query from a user is implemented by searching an index
structure.
This index requests access to the record by means of a request to
the buffer pool.
If a record is being inserted or deleted, such a request goes
through the memory manager, which in turn interacts with the buffer
pool to gain access to the disk file.
A program such as this is far too complex for nearly any human
programmer to keep all of the details in his or her head at once.
The only way to design and implement such a program is through
proper use of abstraction and metaphors.
In object-oriented programming,
such abstraction is handled using classes.</paragraph></topic><paragraph>Data types have both a <title_reference>logical form</title_reference> and a <title_reference>physical form</title_reference>.
The definition of the data type in terms of an ADT is its logical
form.
The implementation of the data type as a data structure
is its physical form.
Sometimes you might see the term <emphasis>concrete implementation</emphasis>,
but the word concrete is redundant.
The figure below illustrates this relationship between logical
and physical forms for data types.
When you implement an ADT, you are dealing with the physical form of
the associated data type.
When you use an ADT elsewhere in your program, you are concerned with
the associated data type's logical form.
Some sections of this book focus on physical
implementations for a given data structure.
Other sections use the logical ADT for the data structure in the
context of a higher-level task.</paragraph><target refid="datatype"></target><raw format="xml" ids="datatype" names="datatype" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="ADTCON"
    long_name="ADTCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>The ADT defines the logical form of the data type.
The data structure implements the physical form of the data type.
Users of an ADT are typically programmers working in the same language
as the implementer of the ADT.
Typically, these programmers want to use the ADT as a component
in another application.
The interface to an ADT is also commonly referred to as the
Application Programmer Interface, or API, for the ADT.
The interface becomes a form of communication between the two programmers.</paragraph><topic><title>Example</title><paragraph>A particular programming environment might provide a library that
includes a <title_reference>list</title_reference> class.
The logical form of the list is defined by the public
functions, their inputs, and their outputs that define the class.
This might be all that you know about the list class implementation,
and this should be all you need to know.
Within the class, a variety of physical implementations for lists
is possible.</paragraph></topic><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="IntroADTSumm"
    long_name="IntroADTSumm"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Design/ADTCON.js</odsascript></raw></document>