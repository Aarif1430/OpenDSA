{"document": {"@dupnames": "reference\\ parameters", "@ids": "reference-parameters", "@source": "<string>", "@title": "Reference Parameters", "title": "Reference Parameters", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@dupnames": "reference\\ parameters", "@ids": "id1", "title": "Reference Parameters", "paragraph": {"title_reference": ["pass by value", "value parameter", "Pass by reference"], "#text": "In the simplest  or \nscheme, each function has separate, local memory and parameters are\ncopied from the caller to the callee at the moment of the function\ncall.\nBut what about the other direction?\nHow can the callee communicate back to its caller?\nUsing a \"return\" at the end of the callee to copy a result back to the\ncaller works for simple cases, but does not work well for all\nsituations.\nAlso, sometimes copying values back and forth is undesirable.\n parameters solve all of these problems.\nFor the following discussion, the term \"value of interest\" will be a\nvalue that the caller and callee wish to communicate between each\nother.\nA reference parameter passes a pointer to the value of interest\ninstead of a copy of the value of interest.\nThis technique uses the sharing property of pointers so that the\ncaller and callee can share the value of interest."}, "section": [{"@ids": "bill-gates-example", "@names": "bill\\ gates\\ example", "title": "Bill Gates Example", "paragraph": {"literal": ["A()", "B()", "A()", "A()", "B()"], "#text": "Suppose functions  and  both do computations involving Bill Gates' net worth\nmeasured in billions of dollars  the value of interest for this problem.  is the main\nfunction and its stores the initial value (about 55 as of 1998).  calls  which tries to\nadd 1 to the value of interest."}}, {"@ids": "bill-gates-by-value", "@names": "bill\\ gates\\ by\\ value", "title": "Bill Gates By Value", "paragraph": [{"literal": ["A()", "B()"], "#text": "Here is the code and memory drawing for a simple, but incorrect implementation where\n and  use pass by value. Three points in time, T1, T2, and T3 are marked in the\ncode and the state of memory is shown for each state..."}, {"literal": ["B()", "worth", "B()", "worth"], "title_reference": "netWorth", "#text": "adds 1 to its local  copy, but when  exits,  is deallocated, so changing it was useless. The value of interest,\n, rests unchanged the whole time in A()'s local storage. A function can change its local copy of the value of interest,\nbut that change is not reflected back in the original value. This is\nreally just the old \"independence\" property of local storage, but in\nthis case it is not what is wanted."}], "literal_block": {"@xml:space": "preserve", "#text": "void B(int worth) {\n  worth = worth + 1;\n  // T2\n}\n\nvoid A() {\n  int netWorth;\n  netWorth = 55;  // T1\n\n  B(netWorth);\n  // T3 -- B() did not change netWorth\n}"}, "raw": {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}}, {"@ids": "by-reference", "@names": "by\\ reference", "title": "By Reference", "paragraph": [{"literal": ["netWorth", "netWorth", "worth", "netWorth", "netWorth"], "title_reference": ["netWorth", "A()", "B()", "reference parameters"], "#text": "The reference solution to the Bill Gates problem is to use a single\n variable for the value of interest and never copy\nit. Instead, each function can receives a pointer to .\nEach function can see the current value of  by dereferencing its pointer. More importantly, each function can change the net\n   just dereference the pointer to the centralized   and change it directly. Everyone agrees what\nthe current value of   because it exists in only one place  everyone has a pointer to the one master copy. The following memory drawing shows  and \nfunctions changed to use .\nAs before, T1, T2, and T3 correspond to points in the code (below),\nbut you can study the memory structure without looking at the code\nyet."}, {"literal": "B()", "#text": "The reference parameter strategy:  receives a pointer to the value of interest instead of\na copy."}], "raw": {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}}]}, {"@ids": "passing-by-reference", "@names": "passing\\ by\\ reference", "title": "Passing By Reference", "paragraph": "Here are the steps to use in the code to use the pass-by-reference strategy:", "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "Have a single copy of the value of interest.\nThe single \"master\" copy."}, {"paragraph": "Pass pointers to that value to any function which wants to see or\nchange the value."}, {"paragraph": "Functions can dereference their pointer to see or change the value\nof interest."}, {"paragraph": "Functions must remember that they do not have their own local\ncopies. If they dereference their pointer and change the value, they\nreally are changing the master value. If a function wants a local\ncopy to change safely, the function must explicitly allocate and\ninitialize such a local copy."}]}, "section": [{"@ids": "syntax", "@names": "syntax", "title": "Syntax", "paragraph": "The syntax for by reference parameters  in the C language just uses pointer operations on\nthe parameters:", "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"literal": ["int", "float", "struct fraction"], "#text": "Suppose a function wants to communicate about some value of\ninterest   or  or ."}}, {"paragraph": {"literal": ["int*", "float*", "struct fraction*"], "#text": "The function takes as its parameter a pointer to the value of\ninterest  an   or  or .\nSome programmers will add the word \"ref\" to the name of a reference\nparameter as a reminder that it is a reference to the value of\ninterest instead of a copy."}}, {"paragraph": "At the time of the call, the caller computes a pointer to the value\nof interest and passes that pointer. The type of the pointer\n(pointer to the value of interest) will agree with the type in (2)\nabove. If the value of interest is local to the caller, then this\nwill often involve a use of the & operator (Section 1)."}, {"paragraph": {"literal": "*", "#text": "When the callee is running, if it wishes to access the value of\ninterest, it must dereference its pointer to access the actual\nvalue of interest. Typically, this equates to use of the\ndereference operator () in the function to see the value of\ninterest."}}]}}, {"@ids": "bill-gates-by-reference", "@names": "bill\\ gates\\ by\\ reference", "title": "Bill Gates By Reference", "paragraph": "Here is the Bill Gates example written to use reference\nparameters. This code now matches the by-reference memory drawing\nabove.", "literal_block": {"@xml:space": "preserve", "#text": "// B() now uses a reference parameter -- a pointer to\n     // the value of  interest. B() uses a dereference (*) on the\n     // reference parameter to get at the value of interest.\n     void B(int* worthRef) {\n     // reference parameter\n     *worthRef = *worthRef + 1; // use * to get at value of interest\n     // T2\n     }\n\n     void A() {\n     int netWorth;\n     netWorth = 55; // T1 -- the value of interest is local to A()\n     B(&netWorth);  // Pass a pointer to the value of interest.\n                    // In this case using &.\n     // T3 -- B() has used its pointer to change the value of interest\n}"}}, {"@ids": "don-t-make-copies", "@names": "don't\\ make\\ copies", "title": "Don't Make Copies", "paragraph": "Reference parameters enable communication between the callee and its\ncaller.\nAnother reason to use reference parameters is to avoid making\ncopies.\nFor efficiency, making copies may be undesirable if the value of\ninterest is large, such as an array.\nMaking the copy requires extra space for the copy itself and extra\ntime to do the copying.\nFrom a design point of view, making copies may be undesirable because\nas soon as there are two copies, it is unclear which one is the\n\"correct\" one if either is changed.\nProverb: \"A person with one watch always knows what time it is.\nA person with two watches is never sure.\"\nAvoid making copies."}]}, {"@ids": "simple-reference-parameter-example-swap", "@names": "simple\\ reference\\ parameter\\ example:\\ swap()", "title": "Simple Reference Parameter Example: Swap()", "paragraph": {"literal": ["Swap()", "ints"], "#text": "The standard example of reference parameters is a  function\nthat exchanges the values of two .\nIt's a simple function, but it does need to change the caller's memory\nwhich is the key feature of pass by reference."}, "section": [{"@ids": "swap-function", "@names": "swap()\\ function", "title": "Swap() Function", "paragraph": {"literal": ["Swap()", "ints", "Swap()", "ints", "int", "int*", "Swap()", "a", "b", "*", "int"], "#text": "The values of interest for  are two .\nTherefore,  does not take  as its parameters.\nIt takes pointers to   ()'s.\nIn the body of  the parameters,  and , are\ndereferenced with  to get at the actual () values of\ninterest."}, "literal_block": {"@xml:space": "preserve", "#text": "void Swap(int* a, int* b) {\n  int temp;\n\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}"}}, {"@ids": "swap-caller", "@names": "swap()\\ caller", "title": "Swap() Caller", "paragraph": ["To call Swap(), the caller must pass pointers to the values of interest.", {"literal": ["Swap()", "Swap()", "Swap()", "SwapCaller()", "Swap()"], "#text": "The parameters to  are pointers to values of interest which are back in the caller's\nlocals. The  code can dereference the pointers to get back to the caller's memory to\nexchange the values. In this case,  follows the pointers to exchange the values in\nthe variables x and y back in .  will exchange any two ints given\npointers to those two ints."}], "literal_block": {"@xml:space": "preserve", "#text": "void SwapCaller() {\n  int x = 1;\n  int y = 2;\n\n  Swap(&x, &y); // Use & to pass pointers to the int values of interest\n                //  (x and y).\n}"}, "raw": {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}}, {"@ids": "swap-with-arrays", "@names": "swap()\\ with\\ arrays", "title": "Swap() With Arrays", "paragraph": [{"literal": ["Swap()", "int``s in an array. ``Swap()", "int*", "ints", "int", "int"], "#text": "Just to demonstrate that the value of interest does not need to be a simple variable, here's\na call to  to exchange the first and last  takes 's, but\nthe  can be anywhere. An  inside an array is still an ."}, {"literal": ["Swap()", "Swap(scores, scores+9)"], "#text": "The above call to  can be written equivalently as\n due to the array syntax in C. You can"}, "ignore this case if it is not familiar to you\nit's\nnot an important area of the language and both forms compile to the exact same thing anyway."], "literal_block": {"@xml:space": "preserve", "#text": "void SwapCaller2() {\n  int scores[10];\n  scores[0] = 1;\n  scores[9[ = 2;\n  Swap(&(scores[0]), &(scores[9]));// the ints of interest do not need to be\n         // simple variables -- they can be any int. The caller is responsible\n         // for computing a pointer to the int."}}]}, {"@ids": "more-syntax", "@names": "more\\ syntax", "title": "More Syntax", "section": [{"@ids": "is-the-always-necessary", "@names": "is\\ the\\ &\\ always\\ necessary?", "title": "Is The & Always Necessary?", "paragraph": ["When passing by reference, the caller does not always need to use & to compute a new\npointer to the value of interest. Sometimes the caller already has a pointer to the value of\ninterest, and so no new pointer computation is required. The pointer to the value of\ninterest can be passed through unchanged.", "For example, suppose B() is changed so it calls a C() function which adds 2 to the value\nof interest..."], "literal_block": {"@xml:space": "preserve", "#text": "// Takes the value of interest by reference and adds 2.\n    void C(int* worthRef) {\n      *worthRef = *worthRef + 2;\n    }\n\n    // Adds 1 to the value of interest, and calls C().\n    void B(int* worthRef) {\n      *worthRef = *worthRef + 1; // add 1 to value of interest as before\n\n      C(worthRef);    // NOTE no & required. We already have\n                      // a pointer to the value of interest, so\n                      // it can be passed through directly.\n}"}}, {"@ids": "what-about-the-bug-tab", "@names": "what\\ about\\ the\\ &\\ bug\\ tab?", "title": "What About The & Bug TAB?", "paragraph": "All this use of & might make you nervous  are we committing the & bug from Section\n2? No, it turns out the above uses of & are fine. The & bug happens when an & passes a\npointer to local storage from the callee back to its caller. When the callee exits, its local\nmemory is deallocated and so the pointer no longer has a pointee. In the above, correct\ncases, we use & to pass a pointer from the caller to the callee. The pointer remains valid\nfor the callee to use because the caller locals continue to exist while the callee is running.\nThe pointees will remain valid due to the simple constraint that the caller can only exit\nsometime after its callee exits. Using & to pass a pointer to local storage from the caller\nto the callee is fine. The reverse case, from the callee to the caller, is the & bug."}, {"@ids": "the-case", "@names": "the\\ **\\ case", "title": "The ** Case", "paragraph": {"literal": ["int*", "struct fraction*", "int*", "int*", "int**", "struct fraction*", "struct fraction**", "*", "**"], "#text": "What if the value of interest to be shared and changed between the caller and callee is\nalready a pointer, such as an  or a ?\nDoes that change the rules for setting  up reference parameters? No.\nIn that case, there is no change in the rules.\nThey operate just as before. The reference parameter is still a pointer to the value of\ninterest, even if the value of interest is itself a pointer. Suppose the value of interest is\n. This means there is an  value which the caller and callee want to share and change. Then the reference parameter should be an\n. For a   value of interest, the reference parameter is .\nA single dereference () operation on the reference parameter yields the value of interest as it did in the simple cases. Double pointer () parameters are common in linked list or\nother pointer manipulating code were the value of interest to share and change is itself a pointer, such as a linked list head pointer."}}]}, {"@ids": "reference-parameter-summary", "@names": "reference\\ parameter\\ summary", "title": "Reference Parameter Summary", "paragraph": ["Passing by value (copying) does not allow the callee to communicate back to its caller\nand has also has the usual disadvantages of making copies. Pass by reference uses\npointers to avoid copying the value of interest, and allow the callee to communicate back\nto the caller.", {"literal": ["int*", "struct fraction**", "*"], "title_reference": "struct fraction*", "#text": "For pass by reference, there is only one copy of the value of interest, and pointers to that\none copy are passed. So if the value of interest is an int, its reference parameter is an .\nIf the value of interest is a , its reference parameters is a .\nFunctions use the dereference operator () on the reference parameter to see or change the\nvalue of interest."}]}, {"@ids": "reference-parameters-in-java", "@names": "reference\\ parameters\\ in\\ java", "title": "Reference Parameters in Java", "paragraph": {"literal": ["*", "&"], "#text": "Because Java has no / operators, it is not possible to implement reference parameters\nin Java directly. Maybe this is ok  in the OOP paradigm, you should change objects by\nsending them messages which makes the reference parameter concept unnecessary. The caller passes the callee a (shallow) reference to the value of interest (object of interest?),\nand the callee can send it a message to change it. Since all objects are intrinsically\nshallow, any change is communicated back to the caller automatically since the object of\ninterest was never copied."}}, {"@ids": "reference-parameters-in-c", "@names": "reference\\ parameters\\ in\\ c++", "title": "Reference Parameters in C++", "paragraph": [{"literal": ["&", "int", "&", "*", "Swap()", "SwapCaller()"], "title_reference": "int&", "#text": "Reference parameters are such a common programming task that they have been added as\nan official feature to the C++ language. So programming reference parameters in C++ is\nsimpler than in C. All the programmer needs to do is syntactically indicate that they wish\nfor a particular parameter to be passed by reference, and the compiler takes care of it. The\nsyntax is to append a single  to right hand side of the parameter type. So an  \nparameter passes an integer by value, but an  parameter passes an integer value by\nreference. The key is that the compiler takes care of it. In the source code, there's no\nadditional fiddling around with 's or 's. So  and  written with C++\nlook simpler than in C, even though they accomplish the same thing.."}, {"literal": "int", "#text": "The types of the various variables and parameters operate simply as they are declared\n( in this case). The complicating layer of pointers required to implement the\nreference parameters is hidden. The compiler takes care of it without allowing the\ncomplication to disturb the types in the source code."}], "literal_block": {"@xml:space": "preserve", "#text": "void Swap(int& a, int& b) {\n  // The & declares pass by reference\n  int temp;\n  temp = a;\n  // No *'s required -- the compiler takes care of it\n  a = b;\n  b = temp;\n}\n\nvoid SwapCaller() {\n  int x = 1;\n  int y = 2;\n  Swap(x, y);\n  // No &'s required -- the compiler takes care of it\n}"}}]}}