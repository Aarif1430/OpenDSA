{"document": {"@dupnames": "2-3\\ trees", "@ids": "trees", "@source": "<string>", "@title": "2-3 Trees", "title": "2-3 Trees", "subtitle": {"@dupnames": "2-3\\ trees", "@ids": "id1", "#text": "2-3 Trees"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Indexing/twoThreeTreeCON.css"}, {"@format": "xml", "@ids": "ttexamp", "@names": "ttexamp", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "twoThreedgmCON", "@long_name": "twoThreedgmCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@ids": "tteasyin", "@names": "tteasyin", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "simpleInsertCON", "@long_name": "simpleInsertCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@ids": "ttpromote", "@names": "ttpromote", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "promoteCON", "@long_name": "promoteCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@ids": "ttsplit", "@names": "ttsplit", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "splitCON", "@long_name": "splitCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "html", "@xml:space": "preserve", "#text": "<center>\n<iframe id=\"BT_iframe\"\n     src=\"//www.cs.usfca.edu/~galles/visualization/BTree.html\"\n     width=\"1100\" height=\"800\"\n     frameborder=\"1\" marginwidth=\"0\" marginheight=\"0\"\n     scrolling=\"no\">\n</iframe>\n</center>"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Indexing/twoThreeTreeCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Indexing/twoThreedgmCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Indexing/simpleInsertCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Indexing/promoteCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Indexing/splitCON.js"}], "paragraph": ["This section presents a data structure called the 2-3 tree.\nThe 2-3 tree is not a binary tree, but instead its shape\nobeys the following definition:", "In addition to these shape properties, the 2-3 tree has a search tree\nproperty analogous to that of a BST.\nFor every node, the values of all descendants in the left subtree are\nless than the value of the first key, while values in the center\nsubtree are greater than or equal to the value of the first key.\nIf there is a right subtree (equivalently, if the node stores two\nkeys), then the values of all descendants in the center subtree are\nless than the value of the second key, while values in the right\nsubtree are greater than or equal to the value of the second key.\nTo maintain these shape and search properties requires that special\naction be taken when nodes are inserted and deleted.\nThe 2-3 tree has the advantage over the BST in that the 2-3 tree can\nbe kept height balanced at relatively low cost.\nHere is an example 2-3 tree.", "Nodes are shown as rectangular boxes with two key fields.\n(These nodes actually would contain complete records or pointers to\ncomplete records, but the figures will show only the keys.)\nInternal nodes with only two children have an empty right key field.\nLeaf nodes might contain either one or two keys.\nHere is an implementation for the 2-3 tree node class.", {"title_reference": "class hierarcy <class hierarchy> <BinaryTreeImpl>", "#text": "Note that this sample declaration does not distinguish\nbetween leaf and internal nodes and so is space inefficient, because\nleaf nodes store three pointers each.\nWe can use a \nto implement separate internal and leaf node types."}, {"math": ["k", "2^{k-1}", "k", "3^{k-1}"], "#text": "From the defining rules for 2-3 trees we can derive relationships\nbetween the number of nodes in the tree and the depth of the tree.\nA 2-3 tree of height  has at least  leaves,\nbecause if every internal node has two children it degenerates to the\nshape of a complete binary tree.\nA 2-3 tree of height  has at most  leaves,\nbecause each internal node can have at most three children."}, {"math": ["K", "K"], "title_reference": "Figure #TTexamp", "#text": "Searching for a value in a 2-3 tree is similar to searching in a BST.\nSearch begins at the root.\nIf the root does not contain the search key , then the search\nprogresses to the only subtree that can possibly contain .\nThe value(s) stored in the root node determine which is the correct\nsubtree.\nFor example, if searching for the value 30 in the tree of\nFigure , we begin with the root node.\nBecause 30 is between 18 and 33, it can only be in the middle\nsubtree.\nSearching the middle child of the root node yields the desired\nrecord.\nIf searching for 15, then the first step is again to search the root\nnode.\nBecause 15 is less than 18, the first (left) branch is taken.\nAt the next level, we take the second branch to the leaf node\ncontaining 15.\nIf the search key were 16, then upon encountering the leaf\ncontaining 15 we would find that the search key is not in the tree.\nHere is an implementation for the 2-3 tree search method."}, "Insertion into a 2-3 tree is similar to insertion into a BST to the\nextent that the new record is placed in the appropriate leaf node.\nUnlike BST insertion, a new child is not created to hold the record\nbeing inserted, that is, the 2-3 tree does not grow downward.\nThe first step is to find the leaf node that would contain the record\nif it were in the tree.\nIf this leaf node contains only one value, then the new record can be\nadded to that node with no further modification to the tree, as\nillustrated in the following visualization.", {"math": ["L", "L", "L", "L", "L'", "L", "L'", "L'", "L'"], "title_reference": "promotion", "#text": "If we insert the new record into a leaf node  that already\ncontains two records, then more space must be created.\nConsider the two records of node  and the record to be\ninserted without further concern for which two\nwere already in  and which is the new record.\nThe first step is to split  into two nodes.\nThus, a new node  call it   must be created from\nfree store.\n receives the record with the least of the three key values.\n receives the greatest of the three.\nThe record with the middle of the three key value is passed up to the\nparent node along with a pointer to .\nThis is called a .\nThe promoted key is then inserted into the parent.\nIf the parent currently contains only one record (and thus has only\ntwo children), then the promoted record and the pointer to\n are simply added to the parent node.\nIf the parent is full, then the split-and-promote process is repeated.\nHere is an example of a a simple promotion."}, "Here is an illustration for what happens when promotions\nrequire the root to split, adding a new level to the tree.\nNote that all leaf nodes continue to have equal depth.", "Here is an implementation for the insertion process.", {"literal": ["inserthelp", "rt", "inserthelp", "rt", "rt", "rt"], "#text": "Note that  takes three parameters.\nThe first is a pointer to the root of the current subtree, named\n.\nThe second is the key for the record to be\ninserted, and the third is the record itself.\nThe return value for  is a pointer to a 2-3 tree node.\nIf  is unchanged, then a pointer to  is returned.\nIf  is changed (due to the insertion causing the node to\nsplit), then a pointer to the new subtree root is returned, with the\nkey value and record value in the leftmost fields, and a pointer to\nthe (single) subtree in the center pointer field.\nThis revised node will then be added to the parent as illustrated by\nthe splitting visualization above."}, "When deleting a record from the 2-3 tree, there are three cases to\nconsider.\nThe simplest occurs when the record is to be removed from a leaf node\ncontaining two records.\nIn this case, the record is simply removed, and no other nodes are\naffected.\nThe second case occurs when the only record in a leaf node is to be\nremoved.\nThe third case occurs when a record is to be removed from an internal\nnode.\nIn both the second and the third cases, the deleted record is replaced\nwith another that can take its place while maintaining the correct\norder, similar to removing a node from a BST.\nIf the tree is sparse enough, there is no such record available that\nwill allow all nodes to still maintain at least one record.\nIn this situation, sibling nodes are merged together.\nThe delete operation for the 2-3 tree is excessively complex and\nwill not be described further.\nInstead, a complete discussion of deletion will be postponed until the\nnext section, where it can be generalized for a particular variant of\nthe B-tree.", {"title_reference": "height balanced", "math": ["\\log n", "\\Theta(\\log n)"], "#text": "The 2-3 tree insert and delete routines do not add new nodes at the\nbottom of the tree.\nInstead they cause leaf nodes to split or merge, possibly causing a\nripple effect moving up the tree to the root.\nIf necessary the root will split, causing a new root node to be\ncreated and making the tree one level deeper.\nOn deletion, if the last two children of the root merge,\nthen the root node is removed and the tree will lose a level.\nIn either case, all leaf nodes are always at the same level.\nWhen all leaf nodes are at the same level, we say that a tree is\n.\nBecause the 2-3 tree is height balanced, and every internal node has\nat least two children, we know that the maximum depth of the tree\nis .\nThus, all 2-3 tree insert, find, and delete operations require\n time."}, "Here is a visualization for the 2-3 tree.\nActually, the visualization is more general than just a 2-3 tree.\nTo see how a 2-3 would behave, be sure to use the \"Max Degree = 3\"\nsetting.", {"raw": {"@format": "html", "@xml:space": "preserve", "#text": "<a href=\"http://www.cs.usfca.edu/~galles/visualization/Algorithms.html\" target=\"_blank\">Data Structure Visualizations</a>"}, "#text": "This visualization was written by David Galles of the University of\nSan Francisco as part of his  package."}], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "A node contains one or two keys."}, {"paragraph": "Every internal node has either two children (if it contains one key)\nor three children (if it contains two keys).  Hence the name."}, {"paragraph": "All leaves are at the same level in the tree, so\nthe tree is always height balanced."}]}, "target": [{"@refid": "ttexamp"}, {"@refid": "tteasyin"}, {"@refid": "ttpromote"}, {"@refid": "ttsplit"}], "substitution_definition": {"@names": "external_link", "raw": {"@format": "html", "@xml:space": "preserve", "#text": "<a href=\"http://www.cs.usfca.edu/~galles/visualization/Algorithms.html\" target=\"_blank\">Data Structure Visualizations</a>"}}}}