<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="analyzing-search-in-unsorted-lists" names="analyzing\ search\ in\ unsorted\ lists" source="&lt;string&gt;" title="Analyzing Search in Unsorted Lists"><title>Analyzing Search in Unsorted Lists</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><section ids="analysis" names="analysis"><title>Analysis</title><paragraph>You already know the simplest form of search:
the sequential search algorithm.
Sequential search on an unsorted list requires <math>\Theta(n)</math> time
in the worst case.</paragraph><paragraph>How many comparisons does linear search do on average?
A major consideration is whether <math>K</math> is in list <strong>L</strong> at
all.
We can simplify our analysis by ignoring everything about the input
except the position of <math>K</math> if it is found in <strong>L</strong>.
Thus, we have <math>n+1</math> distinct possible events:
That <math>K</math> is in one of positions 0 to <math>n-1</math> in <strong>L</strong>
(each position having its own probability), or that it is not in
<math>L</math> at all.
We can express the probability that <math>K</math> is not in <strong>L</strong> as</paragraph><math_block xml:space="preserve">\mathbf{P}(K \notin \mathbf{L}) =
1 - \sum_{i=1}^n \mathbf{P}(K = \mathbf{L}[i])</math_block><paragraph>where <math>\mathbf{P}(x)</math> is the probability of event
<math>x</math>.</paragraph><paragraph>Let <math>p_i</math> be the probability that <math>K</math> is in position
<math>i</math> of <strong>L</strong> (indexed from 0 to <math>n-1</math>.
For any position <math>i</math> in the list, we must look at <math>i+1</math>
records to reach it.
So we say that the cost when <math>K</math> is in position <math>i</math> is
<math>i+1</math>.
When <math>K</math> is not in <strong>L</strong>, sequential search will require
<math>n</math> comparisons.
Let <math>p_n</math> be the probability that <math>K</math> is not in <strong>L</strong>.
Then the average cost <math>\mathbf{T}(n)</math> will be</paragraph><math_block xml:space="preserve">\mathbf{T}(n) = n p_n + \sum_{i=0}^{n-1} (i+1) p_i.</math_block><paragraph>What happens to the equation if we assume all the <math>p_i</math> 's
are equal (except <math>p_n</math>)?</paragraph><math_block xml:space="preserve">\mathbf{T}(n) &amp;=&amp; p_n n + \sum_{i=0}^{n-1} (i+1) p\\
&amp;=&amp; p_n n + p\sum_{i=1}^n i\\
&amp;=&amp; p_n n + p\frac{n(n+1)}{2}\\
&amp;=&amp; p_n n + \frac{1 - p_n}{n}\frac{n(n+1)}{2}\\
&amp;=&amp; \frac{n + 1 + p_n(n-1)}{2}</math_block><paragraph>Depending on the value of <math>p_n</math>,
<math>\frac{n+1}{2} \leq \mathbf{T}(n) \leq n</math>.</paragraph></section><section ids="lower-bounds-proofs" names="lower\ bounds\ proofs"><title>Lower Bounds Proofs</title><paragraph>Given an (unsorted) list <strong>L</strong> of <math>n</math> elements and
a search key <math>K</math>, we seek to identify one element in <strong>L</strong>
which has key value <math>k</math>, if any exists.
For the rest of this discussion, we will assume that the key values
for the elements in <strong>L</strong> are unique, that the set of all possible
keys is totally ordered (that is, the operations
<math>&lt;</math>, <math>=</math>, and <math>&gt;</math> are defined for all pairs of key
values),
and that comparison is our only way to find the relative ordering of
two keys.
Our goal is to solve the problem using the minimum number of
comparisons.</paragraph><paragraph>Given this definition for searching, we can easily come up with the
standard sequential search algorithm, and we can also see that the
lower bound for this problem is "obviously" <math>n</math> comparisons.
(Keep in mind that the key <math>K</math> might not actually appear in the
list.)
However, lower bounds proofs are a bit slippery, and it is instructive
to see how they can go wrong.</paragraph><topic><title>Theorem</title><paragraph>The lower bound for the problem of searching in an unsorted list is
<math>n</math> comparisons.</paragraph></topic><paragraph>Here is our first attempt at proving the theorem.</paragraph><topic><title>Proof 1</title><paragraph>We will try a proof by contradiction.
Assume an algorithm <math>A</math> exists that requires only <math>n-1</math>
(or less) comparisons of <math>K</math> with elements of <strong>L</strong>.
Because there are <math>n</math> elements of <strong>L</strong>, <math>A</math> must have
avoided comparing <math>K</math> with <strong>L</strong> [<math>n</math>].
We can feed the algorithm an input with <math>K</math> in position
<math>n</math>.
Such an input is legal in our model, so the algorithm is
incorrect.</paragraph></topic><paragraph>Is this proof correct? Hopefully it is reasonably obvious to you that
not all algorithms must search through the list in a specific order,
so not all algorithms have to look at position <strong>L</strong> [<math>n</math>] last.</paragraph><paragraph>OK, so we can try to dress up the proof by making the process a bit more
flexible.</paragraph><topic><title>Proof 2</title><paragraph>We will try a proof by contradiction.
Assume an algorithm <math>A</math> exists that requires only <math>n-1</math>
(or less) comparisons of <math>K</math> with elements of <strong>L</strong>.
Because there are <math>n</math> elements of <strong>L</strong>, <math>A</math> must have
avoided comparing <math>K</math> with <strong>L</strong> [<math>i</math>] for some value
<math>i</math>.
We can feed the algorithm an input with <math>K</math> in position
<math>i</math>.
Such an input is legal in our model, so the algorithm is
incorrect.</paragraph></topic><paragraph>Is this proof correct? Still, no.
First of all, any given algorithm need not necessarily consistently
skip any given position <math>i</math> in its <math>n-1</math> searches.
For example, it is not necessary that all algorithms search the list
from left to right.
It is not even necessary that all algorithms search the same
<math>n-1</math> positions first each time through the list.
Perhaps it picks them at random.</paragraph><paragraph>Again, we can try to dress up the proof as follows.</paragraph><topic><title>Proof 3</title><paragraph>On any given run of the algorithm,
if <math>n-1</math> elements are compared against <math>K</math>, then
<emphasis>some</emphasis> element position (call it position <math>i</math>) gets skipped.
It is possible that <math>K</math> is in position <math>i</math> at that
time, and will not be found.
Therefore, <math>n</math> comparisons are required.</paragraph></topic><paragraph>Unfortunately, there is another error that needs to be fixed.
It is not true that all algorithms for solving the problem must work
by comparing elements of <strong>L</strong> against <math>K</math>.
An algorithm might make useful progress by comparing elements of
<strong>L</strong> against each other.
For example, if we compare two elements of <strong>L</strong>, then compare the
greater against <math>K</math> and find that this element is less than
<math>K</math>, we know that the other element is also less than
<math>K</math>.
It seems intuitively obvious that such comparisons won't actually lead
to a faster algorithm, but how do we know for sure?
We somehow need to generalize the proof to account for this approach.</paragraph><paragraph>We will now present a useful abstraction for expressing the state of
knowledge for the value relationships among a set of objects.
A <title_reference>total order</title_reference> defines relationships within a
collection of objects such that for every pair of objects, one is
greater than the other.
A <title_reference>partially ordered set</title_reference> or <title_reference>poset</title_reference> is a set on which
only a partial order is defined.
That is, there can be pairs of elements for which we cannot decide
which is "greater".
For our purpose here, the partial order is the state of our current
knowledge about the objects,
such that zero or more of the order relations between pairs of
elements are known.
We can represent this knowledge by drawing directed acyclic graphs
(DAGs) showing the known relationships, as illustrated by
Figure <title_reference>Figure #Poset</title_reference>.</paragraph><target refid="poset"></target><raw format="xml" ids="poset" names="poset" xml:space="preserve"><odsafig>null</odsafig></raw><topic><title>Proof 4</title><paragraph>Initially, we know nothing about the relative order of the
elements in <strong>L</strong>, or their relationship to <math>K</math>.
So initially, we can view the <math>n</math> elements in <strong>L</strong> as being
in <math>n</math> separate partial orders.
Any comparison between two elements in <strong>L</strong> can affect the
structure of the partial orders.</paragraph><paragraph>Now, every comparison between elements in <strong>L</strong> can at best combine
two of the partial orders together.
Any comparison between <math>K</math> and an element, say <math>A</math>, in
<strong>L</strong> can at best eliminate the partial order that contains
<math>A</math>.
Thus, if we spend <math>m</math> comparisons comparing elements in <strong>L</strong>
we have at least <math>n-m</math> partial orders.
Every such partial order needs at least one comparison against
<math>K</math> to make sure that <math>K</math> is not somewhere in that
partial order.
Thus, any algorithm must make at least <math>n</math> comparisons in the
worst case.</paragraph></topic></section></document>