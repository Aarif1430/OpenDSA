{"document": {"@dupnames": "introduction", "@ids": "introduction", "@source": "<string>", "@title": "Introduction", "title": "Introduction", "subtitle": {"@dupnames": "introduction", "@ids": "id1", "#text": "Introduction"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/RecurTutor/recurIntroCON.css"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "recurIntroDelegateCON", "@long_name": "recurIntroDelegateCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "recurIntroDetailsCON", "@long_name": "recurIntroDetailsCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/RecurTutor/recurIntroDelegateCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/RecurTutor/recurIntroDetailsCON.js"}], "paragraph": [{"title_reference": ["algorithm", "recursive <recursion>"], "#text": "An  (or a function in a computer program) is\n if it invokes itself to do part of its\nwork.\nRecursion makes it possible to solve complex problems using programs\nthat are concise, easily understood, and algorithmically efficient.\nRecursion is the process of solving a large problem by reducing it to\none or more sub-problems which are identical in structure to the\noriginal problem and somewhat simpler to solve.\nOnce the original subdivision has been made, the sub-problems\ndivided into new ones which are even less complex.\nEventually, the sub-problems become so simple that they can be then\nsolved without further subdivision.\nUltimately, the complete solution is obtained by reassembling the\nsolved components."}, "For a recursive approach to be successful, the recursive\n\"call to itself\" must be on a smaller problem than the one originally\nattempted.\nIn general, a recursive algorithm must have two parts:", "Recursion has no counterpart in everyday, physical-world problem solving.\nThe concept can be difficult to grasp because it requires you to think\nabout problems in a new way.\nWhen first learning recursion, it is common for people to think a lot\nabout the recursive process.\nWe will spend some time in these modules going over the details for\nhow recursion works.\nBut when writing recursive functions, it is best to\nstop thinking about how the recursion works beyond the recursive\ncall.\nYou should adopt the attitude that the sub-problems will take care of\nthemselves, that when you call the function recursively it will return\nthe right answer.\nYou just worry about the base cases and how to recombine the\nsub-problems.", "Newcomers who are unfamiliar with recursion often find it hard to\naccept that it is used primarily as a tool for simplifying the design\nand description of algorithms.\nA recursive algorithm does not always yield the most efficient\ncomputer program for solving the problem because recursion\ninvolves function calls, which are typically more expensive than other\nalternatives such as a while loop.\nHowever, the recursive approach usually provides an algorithm that is\nreasonably efficient.\nIf necessary, the clear, recursive solution can later be modified to\nyield a faster implementation.", "Imagine that someone in a movie theater asks you what row you're\nsitting in.\nYou don't want to count, so you ask the person in front of you what\nrow they are sitting in, knowing that they will tell you a number one\nless than your row number.\nThe person in front could ask the person in front of them.\nThis will keep happening until word reaches the front row and it\nis easy to respond: \"I'm in row 1!\"\nFrom there, the correct message (incremented by one each row)\nwill eventually make it's way back to the person who asked.", {"title_reference": "delegate <delegation mental model for recursion>", "#text": "Imagine that you have a big task.\nYou could just do a small piece of it,\nand then \nthe rest to some helper, as in this example."}, "Let's look deeper into the details of what your friend does when\nyou delegate the work.\n(Note that we show  you this process once now,\nand once again when we look at some recursive functions.\nBut when you are writing your own recursive functions,\nyou shouldn't worry about all of these details.)", "In order to understand recursion, you need to be able to do two\nthings.\nFirst, you have to understand how to read a recursive function.\nSecond, you have to understand how to write a recursive function.\nBoth of these skills require a lot of practice.\nSo we will give you a lot of exercises to do later on."], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"title_reference": "base case", "#text": "The , which handles a simple input that can be\nsolved without resorting to a recursive call, and"}}, {"paragraph": "The recursive part which contains one or more recursive calls to the\nalgorithm.\nIn every recursive call, the parameters must be in some sense \"closer\"\nto the base case than those of the original call."}]}}}