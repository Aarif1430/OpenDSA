{"document": {"@dupnames": "alpha-conversion", "@ids": "id1 alpha-conversion", "@names": "alpha-conversion", "@source": "<string>", "@title": "Alpha-Conversion", "title": "Alpha-Conversion", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "target": {"@refid": "alpha-conversion"}, "section": [{"@ids": "alpha-conversion-rule", "@names": "alpha-conversion\\ rule", "title": "Alpha-Conversion Rule", "paragraph": [{"title_reference": "free-and-bound-variables", "#text": "We now turn our attention back to the semantics of the lambda calculus\nby focusing on how  in lambda\nexpressions impact their meaning. Let us first consider bound variable\noccurrences first."}, {"title_reference": ["x", "x", "x"], "#text": "When a variable occurrence  is bound to a binding occurrence,\nthe meaning of  depends on the fact that it appears inside\nthe body of a function and is the name of its parameter. Therefore,\nthe value of  is completely determined by and will be equal\nto whatever argument is passed into the function when it is called. In\nother words, when a variable occurrence is bound in a given\nexpression, its meaning is well defined within this expression. In the\nfollowing JavaScript function, for example:"}, {"title_reference": "x", "#text": "the value of  is not known until the function is called, but\nat run time, say when we run the following program:"}, {"title_reference": ["x", "y", "f", "y", "f"], "#text": "the meaning of  is unambiguous: its value is 12. In contrast,\nthe meaning of  is not well-defined within , because\nthe occurrence of  in the body of  is free. This\nexample illustrates the crucial difference between free and bound\nvariables in terms of semantics."}, {"title_reference": ["time", "t"], "#text": "Now, the name of a function's parameter is chosen by the programmer to\nbe short but evocative of the value that it stands for. So, in the\nexample above, the programmer could have chosen to call the parameter\n or , yielding two other versions of this\nfunction:"}, {"title_reference": "f", "#text": "The key point is that all three versions of the function \nbehave identically. They have the same meaning. A bound variable is\njust a placeholder for a value. The name of the placeholder does not\nmatter as long as it is used consistently throughout the body of the\nfunction. The fact that bound variables can be renamed without\nchanging the meaning of the function is embodied in the following rule\nof the lambda calculus."}, "For example, consider the identity function:", {"title_reference": ["alpha", "y"], "#text": "We can -convert this function using the variable\n to yield the semantically identical function:"}, {"title_reference": ["alpha", "z"], "#text": "Of course, in this case, we could have -converted\nusing any other variable, say :"}, {"title_reference": ["alpha", "alpha", "alpha"], "emphasis": "any", "#text": "However, it is important to keep in mind that\n-conversion must not change the meaning of the function\nit operates on. In particular, all free variables inside the function\nmust remain free after -conversion. This means that we\nare not always allowed to pick just  variable when\n-converting a lambda abstraction. Consider the following example:"}, {"title_reference": ["y", "x", "alpha", "alpha", "alpha", "z"], "#text": "This expression is a function application in which the constant\nfunction that always returns  (a free variable) is called on\n (also a free variable). Can we -convert this\nexpression?  No, because it is a function application. However, we can\n-convert its first component, since it is a lambda\nabstraction. Let's do so. Which variable can we choose? First, we will\n-convert with the variable , yielding:"}, {"title_reference": ["y", "y"], "#text": "This is perfectly acceptable. The meaning has not changed. In both\nthis version and the original version of the application, the final\nvalue of the application will be , since the function being\ncalled ignores its argument and always returns ."}, {"title_reference": ["alpha", "y"], "#text": "However, if we -convert the lambda abstraction with the\nvariable , we get:"}, {"title_reference": ["x", "y", "y", "x", "x", "y"], "#text": "This is not acceptable. The meaning has changed. In this version, the\nidentity function is being applied to and will return ,\ninstead of .  Recall that, in the original application, both\n (the body of the function) and  (the argument of\nthe function call) are free variables, which means that their meaning\nis not specified in this code fragment but must be provided by the\ncontext, that is, the larger program in which this application is\nembedded. In this larger program,  and  may well be\nbound to different values. Therefore, they do not have the same\nmeaning and cannot be interchanged."}, {"title_reference": ["alpha", "lambda x.y", "y", "lambda y.y", "y", "y", "variable capture"], "emphasis": "captured", "#text": "So what went wrong when we -converted the expression\n using the variable  to yield\n? The variable  in the body of the\nabstraction went from being free to being bound. We say that \nunderwent  or, more simply, that it was\n."}, "Since variable captures alter the meaning of lambda expressions, we\nmust avoid them at all costs. Fortunately, this is easy to achieve,\nusing the following rule:"], "literal_block": [{"@classes": "code", "@xml:space": "preserve", "#text": "function f(x) {\n     return 2 + x - y * x;\n}"}, {"@classes": "code", "@xml:space": "preserve", "#text": "f(12);"}, {"@classes": "code", "@xml:space": "preserve", "#text": "function f(time) {                                  function f(t) {\n     return 2 + time - y * time;                         return 2 + t - y * t;\n}                                                   }"}], "block_quote": [{"raw": {"@format": "xml", "@xml:space": "preserve", "index": "null"}, "paragraph": {"title_reference": ["alpha", "alpha", "alpha"], "#text": "-conversion (where  is the lowercase\nGreek letter ) is the process of renaming the parameter\nin a function abstraction."}}, {"paragraph": {"title_reference": ["alpha", "alpha"], "emphasis": "new", "#text": "When -converting a lambda abstraction, always choose\na  variable, that is, a variable that does not occur in the body\nof the function being -converted."}}], "math_block": [{"@xml:space": "preserve", "#text": "\\lambda x.x"}, {"@xml:space": "preserve", "#text": "\\lambda y.y"}, {"@xml:space": "preserve", "#text": "\\lambda z.z"}, {"@xml:space": "preserve", "#text": "(\\lambda x.y\\ x)"}, {"@xml:space": "preserve", "#text": "(\\lambda z.y\\ x)"}, {"@xml:space": "preserve", "#text": "(\\lambda y.y\\ x)"}]}, {"@ids": "rp-15-part-1", "@names": "rp\\ 15\\ part\\ 1", "title": "RP 15 part 1", "paragraph": [{"title_reference": "alpha", "#text": "To practice the process of -conversion, complete the\nfollowing exercise. To earn credit for it, you will have to solve it\ncorrectly three times in a row."}, {"title_reference": ["alpha", "alpha"], "#text": "In conclusion, -conversion simply replaces the name of a\nfunction parameter with a completely new name in order to avoid\nvariable captures. -conversion will be quite useful to\nus in the next section where we describe the main algorithm for\ndetermining the meaning of a lambda calculus program, namely the\nprocess of substitution."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP15part1", "@long_name": "RP15part1", "@points": "1.0", "@required": "True", "@threshold": "5"}}}]}}