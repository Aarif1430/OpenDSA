<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="topological\ sort" ids="topological-sort" source="&lt;string&gt;" title="Topological Sort"><title>Topological Sort</title><subtitle dupnames="topological\ sort" ids="id1">Topological Sort</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>Assume that we need to schedule a series of tasks, such as classes or
construction jobs, where we cannot start one task until after its
prerequisites are completed.
We wish to organize the tasks into a linear order that allows us to
complete them one at a time without violating any prerequisites.
We can model the problem using a DAG.
The graph is directed because one task is a prerequisite of
another -- the vertices have a directed relationship.
It is acyclic because a cycle would indicate a conflicting series of
prerequisites that could not be completed without violating at least
one prerequisite.
The process of laying out the vertices of a DAG in a linear order to
meet the prerequisite rules is called a <title_reference>topological sort</title_reference>.</paragraph><target refid="topsort"></target><raw format="xml" ids="topsort" names="topsort" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="topsortCON"
    long_name="topsortCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>Figure <title_reference>Figure #TopSort</title_reference> illustrates the problem.
An acceptable topological sort for this example is J1,
J2, J3, J4, J5, J6, J7. However, other orders are also acceptable,
such as J1, J3, J2, J6, J4, J5, J7.</paragraph><section ids="depth-first-solution" names="depth-first\ solution"><title>Depth-first solution</title><paragraph>A topological sort may be found by performing a DFS on the graph.
When a vertex is visited, no action is taken (i.e., function
<literal>PreVisit</literal> does nothing).
When the recursion pops back to that vertex, function
<literal>PostVisit</literal> prints the vertex.
This yields a topological sort in reverse order.
It does not matter where the sort starts, as long as all vertices
are visited in the end.
Here is implementation for the DFS-based algorithm.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>Using this algorithm starting at J1 and visiting adjacent
neighbors in alphabetic order, vertices of the graph in
Figure <title_reference>Figure #TopSort</title_reference> are printed out in the order J7,
J5, J4, J6, J2, J3, J1.
Reversing this yields the topological sort
J1, J3, J2, J6, J4, J5, J7.</paragraph><paragraph>Here is another example.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="topSort"
    long_name="topSort"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw></section><section ids="queue-based-solution" names="queue-based\ solution"><title>Queue-based Solution</title><paragraph>We can implement topological sort using a queue
instead of recursion, as follows.</paragraph><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>First visit all edges, counting the number of
edges that lead to each vertex (i.e., count the number of
prerequisites for each vertex).
All vertices with no prerequisites are placed on the queue.
We then begin processing the queue.
When Vertex <title_reference>v</title_reference> is taken off of the queue, it is printed, and all
neighbors of <title_reference>v</title_reference> (that is, all vertices that have <title_reference>v</title_reference> as a
prerequisite) have their counts decremented by one.
Place on the queue any neighbor whose count becomes zero.
If the queue becomes empty without printing all of the vertices, then
the graph contains a cycle (i.e., there is no possible ordering
for the tasks that does not violate some prerequisite).
The printed order for the vertices of the graph in
Applying the queue version of topological sort to the graph of
Figure <title_reference>Figure #TopSort</title_reference> produces J1, J2, J3, J6, J4, J5, J7.
Here is an implementation for the algorithm.</paragraph><paragraph>Here is the code to implement the queue-based topological sort:</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="qTopSort"
    long_name="qTopSort"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Graph/topsortCON.js</odsascript></raw></section></document>