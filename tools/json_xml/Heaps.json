{"document": {"@dupnames": "heaps\\ and\\ priority\\ queues", "@ids": "heaps-and-priority-queues", "@source": "<string>", "@title": "Heaps and Priority Queues", "title": "Heaps and Priority Queues", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Binary/heapbuildProofCON.css"}], "section": [{"@dupnames": "heaps\\ and\\ priority\\ queues", "@ids": "id1", "title": "Heaps and Priority Queues", "paragraph": [{"title_reference": ["jobs <job>", "priority"], "#text": "There are many situations, both in real life and in computing\napplications, where we wish to choose the next \"most important\"\nfrom a collection of people, tasks, or objects.\nFor example, doctors in a hospital emergency room often choose to see\nnext the \"most critical\" patient rather than the one who arrived\nfirst.\nWhen scheduling programs for execution in a multitasking\noperating system, at any given moment there might be several programs\n(usually called ) ready to run.\nThe next job selected is the one with the highest\n.\nPriority is indicated by a particular value associated with the job\n(and might change while the job remains in the wait list)."}, {"title_reference": "priority queue", "math": ["\\Theta(n)", "\\Theta(n)", "n", "n", "\\Theta(n \\log n)"], "#text": "When a collection of objects is organized by importance or priority,\nwe call this a .\nA normal queue data structure will not implement a priority queue\nefficiently because search for the element with highest priority will\ntake  time.\nA list, whether sorted or not, will also require \ntime for either insertion or removal.\nA BST that organizes records by priority could be used, with the total\nof  inserts and  remove operations\nrequiring  time in the average case.\nHowever, there is always the possibility that the BST will become\nunbalanced, leading to bad performance.\nInstead, we would like to find a data structure that is guaranteed to\nhave good performance for this special application."}, {"title_reference": ["heap", "array representation for complete binary trees <complete binary tree> <CompleteTree>", "partially ordered <partial order>"], "footnote_reference": {"@auto": "1", "@ids": "id2", "@refid": "id3", "#text": "1"}, "#text": "This section presents the  data structure. \nA heap is defined by two properties.\nFirst, it is a complete binary tree,\nso heaps are nearly always implemented using the\n.\nSecond, the values stored in a heap are\n.\nThis means that there is a relationship between the value stored at\nany node and the values of its children.\nThere are two variants of the heap, depending on the definition of\nthis relationship."}, {"title_reference": "max heap", "emphasis": "greater", "#text": "A  has the property that every node stores a\nvalue that is  than or equal to the value of either of\nits children.\nBecause the root has a value greater than or equal to its children,\nwhich in turn have values greater than or equal to their children, the\nroot stores the maximum of all values in the tree."}, {"title_reference": "min heap", "emphasis": "less", "#text": "A  has the property that every node stores a\nvalue that is  than or equal to that of its children.\nBecause the root has a value less than or equal to its children, which\nin turn have values less than or equal to their children, the root\nstores the minimum of all values in the tree."}, {"title_reference": "total order", "emphasis": "only", "#text": "Note that there is no necessary relationship between the value of a\nnode and that of its sibling in either the min heap or the max heap.\nFor example, it is possible that the values for all nodes in the left\nsubtree of the root are greater than the values for every node of the\nright subtree.\nWe can contrast BSTs and heaps by the strength of their ordering\nrelationships.\nA BST defines a  on its nodes in that,\ngiven the positions for any two nodes in the tree, the one to the\n\"left\" (equivalently, the one appearing earlier in an inorder\ntraversal) has a smaller key value than the one to the \"right\".\nIn contrast, a heap implements a partial order.\nGiven their positions, we can determine the relative order for the\nkey values of two nodes in the heap  if one is a\ndescendant of the other."}, "Min heaps and max heaps both have their uses.\nFor example, the Heapsort uses the max heap,\nwhile the Replacement Selection algorithm used for external sorting\nuses a min heap.\nThe examples in the rest of this section will use a max heap.", "Be sure not to confuse the logical representation of a heap\nwith its physical implementation by means of the array-based complete\nbinary tree.\nThe two are not synonymous because the logical view of the heap is\nactually a tree structure, while the typical physical implementation\nuses an array.", "Here is an implementation for max heaps.\nThe class uses records that support the Comparable interface to\nprovide flexibility.", "This class definition makes two concessions to the fact that an\narray-based implementation is used.\nFirst, heap nodes are indicated by their logical position within the\nheap rather than by a pointer to the node.\nIn practice, the logical heap position corresponds to the identically\nnumbered physical position in the array.\nSecond, the constructor takes as input a pointer to the array to be\nused.\nThis approach provides the greatest flexibility for using the heap\nbecause all data values can be loaded into the array directly\nby the client.\nThe advantage of this comes during the heap construction phase,\nas explained below.\nThe constructor also takes an integer parameter indicating the initial\nsize of the heap (based on the number of elements initially loaded\ninto the array) and a second integer parameter indicating the maximum\nsize allowed for the heap (the size of the array).", {"literal": ["heapsize", "H.isLeaf(pos)", "pos", "H", "leftchild", "rightchild", "parent"], "#text": "Method  returns the current size of the heap.\n returns TRUE if position\n is a leaf in heap , and FALSE otherwise.\nMembers , ,\nand  return the position (actually, the array index)\nfor the left child, right child, and parent of the position passed,\nrespectively."}, {"literal": "insert", "math": "V", "#text": "One way to build a heap is to insert the elements one at a time.\nMethod  will insert a new element  into\nthe heap."}, {"math": ["n", "n+1", "V", "n", "V", "V", "V", "V", "V", "V"], "literal": ["insert", "insert"], "#text": "You might expect the heap insertion process to be similar to the\ninsert function for a BST, starting at the root and working down\nthrough the heap.\nHowever, this approach is not likely to work because the heap must\nmaintain the shape of a complete binary tree.\nEquivalently, if the heap takes up the first\n positions of its array prior to the call to\n,\nit must take up the first  positions after.\nTo accomplish this,  first places  at\nposition  of the array.\nOf course,  is unlikely to be in the correct position.\nTo move  to the right place, it is compared to its\nparent's value.\nIf the value of  is less than or equal to the value of its\nparent, then it is in the correct place and the insert routine is\nfinished.\nIf the value of  is greater than that of its parent, then\nthe two elements swap positions.\nFrom here, the process of comparing  to its (current)\nparent continues until  reaches its correct position."}, {"math": ["n", "\\Theta(\\log n)", "i", "2^i", "i", "2^{i+1}-1", "\\log n", "n", "n", "\\lceil \\log n + 1 \\rceil"], "#text": "Since the heap is a complete binary tree, its height is guaranteed to\nbe the minimum possible.\nIn particular, a heap containing  nodes will have a height of\n.\nIntuitively, we can see that this must be true because each level that\nwe add will slightly more than double the number of nodes in the tree\n(the  th level has  nodes,\nand the sum of the first  levels is ).\nStarting at 1, we can double only  times to reach a\nvalue of .\nTo be precise, the height of a heap with  nodes is\n."}, {"literal": "insert", "math": ["\\Theta(\\log n)", "n", "\\Theta(n \\log n)"], "#text": "Each call to  takes  time in the\nworst case, because the value being inserted can move at most the\ndistance from the bottom of the tree to the top of the tree.\nThus, to insert  values into the heap, if we insert them\none at a time, will take  time in the\nworst case."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "heapinsertCON", "@long_name": "heapinsertCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "heapinsertPRO", "@long_name": "heapinsertPRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}], "footnote": {"@auto": "1", "@backrefs": "id2", "@ids": "id3", "@names": "1", "label": "1", "paragraph": {"title_reference": "free store", "#text": "Note that the term \"heap\" is also sometimes used to refer to\n."}}}, {"@ids": "building-a-heap", "@names": "building\\ a\\ heap", "title": "Building a Heap", "paragraph": [{"math": "n", "#text": "If all  values are available at the beginning of the\nbuilding process, we can build the heap faster than just\ninserting the values into the heap one by one.\nConsider this example, with two possible ways to heapify an initial\nset of values in an array."}, "From this example, it is clear that the heap for any given\nset of numbers is not unique, and we see that some rearrangements of\nthe input values require fewer exchanges than others to build the\nheap.\nSo, how do we pick the best rearrangement?", {"math": "R", "#text": "One good algorithm stems from induction.\nSuppose that the left and right subtrees of the root are already\nheaps, and  is the name of the element at the root.\nThis situation is illustrated by this figure:"}, "In this case there are two possibilities.", {"math": ["R", "R", "R"], "literal": "siftdown", "#text": "should be exchanged with the child that has\ngreater value.\nThe result will be a heap, except that \nmight still be less than one or both of its (new) children.\nIn this case, we simply continue the process of \"pushing down\"\n until it reaches a level where it is greater than its\nchildren, or is a leaf node.\nThis process is implemented by the private method\n."}, {"emphasis": "before", "#text": "This approach assumes that the subtrees are already heaps,\nsuggesting that a complete algorithm can be obtained by visiting\nthe nodes in some order such that the children of a node are\nvisited  the node itself.\nOne simple way to do this is simply to work from the high index of\nthe array to the low index.\nActually, the build process need not visit the leaf nodes\n(they can never move down because they are already at the bottom), so\nthe building algorithm can start in the middle of the array, with the\nfirst internal node."}, "Here is a visualization of the heap build process.", {"literal": "buildHeap", "#text": "Method  implements the building algorithm."}, {"literal": ["buildHeap", "siftdown", "siftdown"], "#text": "What is the cost of ?\nClearly it is the sum of the costs for the calls to .\nEach  operation can cost at most the number of\nlevels it takes for the node being sifted to reach the bottom of the\ntree.\nIn any complete tree, approximately half of the nodes are leaves\nand so cannot be moved downward at all.\nOne quarter of the nodes are one level above the leaves, and so their\nelements can move down at most one level.\nAt each step up the tree we get half the number of nodes as were at\nthe previous level, and an additional height of one.\nThe maximum sum of total distances that elements can go is\ntherefore"}, {"title_reference": "summation is known <summation> <Summations>", "math": ["\\Theta(n)", "\\Theta(n \\log n)", "\\Theta(n \\log n)", "\\Theta(n^2)"], "#text": "This \nto have a closed-form solution of approximately 2,\nso this algorithm takes  time in the worst case.\nThis is far better than building the heap one element at a time,\nwhich would cost  in the worst case.\nIt is also faster than the  average-case\ntime and  worst-case time required to build the\nBST."}], "target": [{"@refid": "heapbuild"}, {"@refid": "heapinduct"}], "raw": [{"@format": "xml", "@ids": "heapbuild", "@names": "heapbuild", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "heapinduct", "@names": "heapinduct", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "heapbuildCON", "@long_name": "heapbuildCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "heapbuildPRO", "@long_name": "heapbuildPRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "heapbuildProofCON", "@long_name": "heapbuildProofCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}], "enumerated_list": {"@enumtype": "arabic", "@prefix": "(", "@suffix": ")", "list_item": [{"paragraph": {"math": "R", "#text": "has a value greater than or equal to its two\nchildren. In this case, construction is complete."}}, {"paragraph": {"math": "R", "#text": "has a value less than one or both of its children."}}]}, "math_block": {"@xml:space": "preserve", "#text": "\\sum_{i=1}^{\\log n} (i-1)\\frac{n}{2^i}\n= \\frac{n}{2}\\sum_{i=1}^{\\log n} \\frac{i-1}{2^{i-1}}."}}, {"@ids": "removing-from-the-heap", "@names": "removing\\ from\\ the\\ heap", "title": "Removing from the heap", "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "heapmaxCON", "@long_name": "heapmaxCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "heapremovePRO", "@long_name": "heapremovePRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "heapremoveCON", "@long_name": "heapremoveCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}], "paragraph": {"math": ["\\log n", "\\Theta(\\log n)"], "#text": "Because the heap is  levels deep, the cost of deleting\nthe maximum element is  in the average and worst\ncases."}, "line_block": {"line": null}}, {"@ids": "priority-queues", "@names": "priority\\ queues", "title": "Priority Queues", "paragraph": [{"literal": "removemax", "#text": "The heap is a natural implementation for the priority queue discussed\nat the beginning of this section.\nJobs can be added to the heap (using their priority value as the\nordering key) when needed.\nMethod  can be called whenever a new job is to be\nexecuted."}, {"literal": "remove", "title_reference": ["single-source shortest paths <single-source shortest paths problem> <GraphShortest>", "minimal-cost spanning tree <minimal-cost spanning tree> <MCST>"], "#text": "Some applications of priority queues require the ability to change the\npriority of an object already stored in the queue.\nThis might require that the object's position in the heap representation\nbe updated.\nUnfortunately, a max heap is not efficient when searching for an\narbitrary value; it is only good for finding the maximum value.\nHowever, if we already know the index for an object within the heap,\nit is a simple matter to update its priority (including changing its\nposition to maintain the heap property) or remove it.\nThe  method takes as input the position of the\nnode to be removed from the heap.\nA typical implementation for priority queues requiring updating of\npriorities will need to use an auxiliary data structure that supports\nefficient search for objects (such as a BST).\nRecords in the auxiliary data structure will store\nthe object's heap index, so that the object can be\ndeleted from the heap and reinserted with its new priority.\nPriority queues can be helpful for solving graph problems such as\n\nand\n."}, {"raw": {"@format": "html", "@xml:space": "preserve", "#text": "<a href=\"http://computationaltales.blogspot.com/2011/04/stacks-queues-priority-queues-and.html\" target=\"_blank\">Computational Fairy Tales: Stacks, Queues, Priority Queues, and the Prince's Complaint Line</a>"}, "#text": "For a story about Priority Queues and dragons, see ."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "HeapSumm", "@long_name": "HeapSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "DataStructures/binaryheap.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/heapinsertCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/heapbuildCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/heapbuildProofCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/heapmaxCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/heapremoveCON.js"}], "substitution_definition": {"@names": "external_link", "raw": {"@format": "html", "@xml:space": "preserve", "#text": "<a href=\"http://computationaltales.blogspot.com/2011/04/stacks-queues-priority-queues-and.html\" target=\"_blank\">Computational Fairy Tales: Stacks, Queues, Priority Queues, and the Prince's Complaint Line</a>"}}}]}}