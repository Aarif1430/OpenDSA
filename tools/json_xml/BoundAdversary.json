{"document": {"@ids": "adversarial-lower-bounds-proofs", "@names": "adversarial\\ lower\\ bounds\\ proofs", "@source": "<string>", "@title": "Adversarial Lower Bounds Proofs", "title": "Adversarial Lower Bounds Proofs", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@ids": "binomialtree", "@names": "binomialtree", "@xml:space": "preserve", "odsafig": "null"}], "paragraph": ["Our next problem will be finding the second largest in a\ncollection of objects.\nConsider what happens in a standard single-elimination tournament.\nEven if we assume that the \"best\" team wins in every game,\nis the second best the one that loses in the finals?\nNot necessarily.\nWe might expect that the second best must lose to the best,\nbut they might meet at any time.", {"title_reference": ["n-1", "n-2", "2n-3"], "#text": "Let us go through our standard \"algorithm for finding algorithms\" by\nfirst proposing an algorithm, then a lower bound, and seeing if they\nmatch.\nUnlike our analysis for most problems, this time we are going to count\nthe exact number of comparisons involved and attempt to minimize this\ncount.\nA simple algorithm for finding the second largest is to first find the\nmaximum (in  comparisons), discard it, and then find the\nmaximum of the remaining elements (in  comparisons) for a total\ncost of  comparisons.\nIs this optimal?\nThat seems doubtful, but let us now proceed to the step of attempting\nto prove a lower bound."}, {"title_reference": "necessary fallacy", "#text": "This proof is wrong.\nIt exhibits the :\n\"Our algorithm does something, therefore all algorithms solving\nthe problem must do the same.\""}, {"title_reference": ["n-1", "largest", "n-1", "lceil 3n/2rceil - 2", "lceil 5n/4rceil", "lceil 9n/8rceil"], "literal": "largest", "#text": "This leaves us with our best lower bounds argument at the moment\nbeing that finding the second largest must cost at least as much as\nfinding the largest, or .\nLet us take another try at finding a better algorithm by adopting a\nstrategy of divide and conquer.\nWhat if we break the list into halves, and run  on each\nhalf?\nWe can then compare the two winners (we have now used a total of\n comparisons), and remove the winner from its half.\nAnother call to  on the winner's half yields its second\nbest.\nA final comparison against the winner of the other half gives us the\ntrue second place winner.\nThe total cost is .\nIs this optimal?\nWhat if we break the list into four pieces?\nThe best would be .\nWhat if we break the list into eight pieces?\nThen the cost would be about .\nNotice that as we break the list into more parts,\ncomparisons among the winners of the parts becomes a larger concern."}, {"title_reference": ["m", "2^m", "m=0", "m-1", "Figure #BinomialTree"], "#text": "Looking at this another way, the only candidates for second place\nare losers to the eventual winner, and our goal is to have as few of\nthese as possible.\nSo we need to keep track of the set of elements that have lost\nin direct comparison to the (eventual) winner.\nWe also observe that we learn the most from a comparison when both\ncompetitors are known to be larger than the same number of other\nvalues.\nSo we would like to arrange our comparisons to be against\n\"equally strong\" competitors.\nWe can do all of this with a defit{binomial tree}.\nA binomial tree of height  has  nodes.\nEither it is a single node (if ), or else it is\ntwo height  binomial trees with one tree's root becoming\na child of the other.\nFigure  illustrates how a binomial tree\nwith eight nodes would be constructed."}, {"title_reference": ["n", "lceil log nrceil", "2^k", "2^k+1", "2^{k+1}"], "#text": "The resulting algorithm is simple in principle:\nBuild the binomial tree for all  elements, and then compare\nthe  children of the root to find second\nplace.\nWe could store the binomial tree as an explicit tree structure, and\neasily build it in time linear on the number of comparisons as each\ncomparison requires one link be added.\nBecause the shape of a binomial tree is heavily constrained,\nwe can also store the binomial tree implicitly in an array, much as we\ndo for a heap.\nAssume that two trees, each with  nodes, are in the array.\nThe first tree is in positions 1 to :math`2^k`.\nThe second tree is in positions  to .\nThe root of each subtree is in the final array position for that\nsubtree."}, {"title_reference": "O(n log n)", "#text": "To join two trees, we simply\ncompare the roots of the subtrees.\nIf necessary, swap the subtrees so that tree with the the larger root\nelement becomes the second subtree.\nThis trades space (we only need space for the data values, no node\npointers) for time (in the worst case, all of the data swapping might\ncost , though this does not affect the number of\ncomparisons required).\nNote that for some applications, this is an important observation that\nthe array's data swapping requires no comparisons.\nIf a comparison is simply a check between two integers, then of course\nmoving half the values within the array is too expensive.\nBut if a comparison requires that a competition be held between two\nsports teams, then the cost of a little bit (or even a lot) of book\nkeeping becomes irrelevent."}, {"title_reference": ["log n", "n-1", "n + lceil log n rceil - 2"], "#text": "Because the binomial tree's root has  children,\nand building the tree requires  comparisons,\nthe number of comparisons required by this algorithm is\n.\nThis is clearly better than our previous algorithm.\nIs it optimal?"}, {"title_reference": "adversary", "#text": "We now go back to trying to improve the lower bounds proof.\nTo do this, we introduce the concept of an .\nThe adversary's job is to make an algorithm's cost as high as\npossible.\nImagine that the adversary keeps a list of all possible inputs.\nWe view the algorithm as asking the adversary for information about\nthe algorithm's input.\nThe adversary may never lie, in that its answer must be consistent\nwith the previous answers.\nBut it is permitted to \"rearrange\" the input as it sees fit in order\nto drive the total cost for the algorithm as high as possible.\nIn particular, when the algorithm asks a question, the adversary\nmust answer in a way that is consistent with at least one remaining\ninput.\nThe adversary then crosses out all remaining inputs inconsistent with\nthat answer.\nKeep in mind that there is not really an entity within the computer\nprogram that is the adversary, and we don't actually modify the\nprogram.\nThe adversary operates merely as an analysis device, to help us reason\nabout the program."}, "As an example of the adversary concept, consider the standard game of\nHangman.\nPlayer A picks a word and tells player B how many\nletters the word has.\nPlayer B guesses various letters.\nIf B guesses a letter in the word, then A will indicate\nwhich position(s) in the word have the letter.\nPlayer B is permitted to make only so many guesses of letters\nnot in the word before losing.", "In the Hangman game example, the adversary is imagined to hold a\ndictionary of words of some selected length.\nEach time the player guesses a letter, the adversary consults the\ndictionary and decides if more words will be eliminated by accepting\nthe letter (and indicating which positions it holds) or saying that\nits not in the word.\nThe adversary can make any decision it chooses, so long as at least\none word in the dictionary is consistent with all of the decisions.\nIn this way, the adversary can hope to make the player guess as many\nletters as possible.", {"title_reference": ["n-1", "n-1", "k-1", "k", "n + k - 2", "k"], "#text": "Before explaining how the adversary plays a role in our lower bounds\nproof, first observe that at least  values must lose at\nleast once.\nThis requires at least  compares.\nIn addition, at least  values must lose to the second\nlargest value.\nThat is,  direct losers to the winner must be compared.\nThere must be at least  comparisons.\nThe question is: How low can we make ?"}, {"strong": "strength", "literal": ["A[i]", "A[i]", "A[i]", "A[j]"], "title_reference": ["a", "b", "a + b + 1"], "#text": "Call the  of element  the number of\nelements that  is (known to be) bigger than.\nIf  has strength , and  has\nstrength , then the winner has strength .\nThe algorithm gets to know the (current) strengths for each element,\nand it gets to pick which two elements are compared next.\nThe adversary gets to decide who wins any given comparison.\nWhat strategy by the adversary would cause the algorithm to learn the\nleast from any given comparison?\nIt should minimize the rate at which any element improves it strength.\nIt can do this by making the element with the greater strength win at\nevery comparison.\nThis is a \"fair\" use of an adversary in that it represents the\nresults of providing a worst-case input for that given algorithm."}, {"title_reference": ["a = b", "a", "b", "k", "2^{k-1} < n leq 2^k", "n + lceil log nrceil - 2"], "#text": "To minimize the effects of worst-case behavior, the algorithm's best\nstrategy is to maximize the minimum improvement in strength by\nbalancing the strengths of any two competitors.\nFrom the algorithm's point of view, the best outcome is that an\nelement doubles in strength.\nThis happens whenever , where  and  are\nthe strengths of the two elements being compared.\nAll strengths begin at zero, so the winner must make at least\n comparisons when .\nThus, there must be at least \ncomparisons.\nSo our algorithm is optimal."}], "topic": [{"title": "Theorem", "paragraph": {"title_reference": "2n-3", "#text": "The lower bound for finding the second largest value is ."}}, {"title": "Proof", "paragraph": {"literal": "largest", "title_reference": ["n-1", "n-2"], "#text": "Any element that loses to anything other than the maximum cannot be\nsecond.\nSo, the only candidates for second place are those that lost to the\nmaximum.\nFunction  might compare the maximum element  to\n others.\nThus, we might need  additional comparisons to find the\nsecond largest."}}], "target": {"@refid": "binomialtree"}}}