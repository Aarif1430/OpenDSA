<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.2a -->
<document dupnames="mergesort\ concepts" ids="mergesort-concepts" source="&lt;string&gt;" title="Mergesort Concepts"><title>Mergesort Concepts</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Sorting/mergeCON.css</odsalink></raw><raw format="xml" xml:space="preserve"><index>null</index></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Development/MergeSortAnalysisCON.css</odsalink></raw><section dupnames="mergesort\ concepts" ids="id1"><title>Mergesort Concepts</title><paragraph>A natural approach to problem solving is divide and conquer.
To use divide and conquer when sorting, we might consider breaking the
list to be sorted into pieces, process the pieces, and then put them
back together somehow.
A simple way to do this would be to split the list in half, sort
the halves, and then merge the sorted halves together.
This is the idea behind <title_reference>Mergesort</title_reference>.</paragraph><paragraph>Mergesort is one of the simplest sorting algorithms conceptually,
and has good performance both in the asymptotic
sense and in empirical running time.
Unfortunately, even though it is based on a simple concept,
it is relatively difficult to implement in practice.
Here is a pseudocode sketch of Mergesort:</paragraph><literal_block xml:space="preserve">List mergesort(List inlist) {
  if (inlist.length() &lt;= 1) return inlist;;
  List L1 = half of the items from inlist;
  List L2 = other half of the items from inlist;
  return merge(mergesort(L1), mergesort(L2));
}</literal_block><paragraph>Here is a visualization that illustrates how Mergesort works.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="mergesortAV"
    long_name="mergesortAV"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>The hardest step to understand about Mergesort is the merge function.
The merge function starts by examining the first record of each
sublist and picks the smaller value as the smallest record overall.
This smaller value is removed from its sublist and placed into the
output list.
Merging continues in this way, comparing the front
records of the sublists and continually appending the smaller to the
output list until no more input records remain.</paragraph><paragraph>Here is pseudocode for merge on lists:</paragraph><literal_block xml:space="preserve">List merge(List L1, List L2) {
  List answer = new List();
  while (L1 != NULL || L2 != NULL) {
    if (L1 == NULL) { // Done L1
      answer.append(L2);
      L2 = NULL;
    }
    else if (L2 == NULL) { // Done L2
      answer.append(L1);
      L1 = NULL;
    }
    else if (L1.value() &lt;= L2.value()) {
      answer.append(L1.value());
      L1 = L1.next();
    }
    else {
      answer.append(L2.value());
      L2 = L2.next();
    }
  }
  return answer;
}</literal_block><paragraph>Here is a visualization for the merge operation.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="mergesortCON"
    long_name="mergesortCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Here is a mergesort warmup exercise to practice merging.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="MergesortMergePRO"
    long_name="MergesortMergePRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="mergsort-practice-exercise" names="mergsort\ practice\ exercise"><title>Mergsort Practice Exercise</title><paragraph>Now here is a full proficiency exercise to put it all together.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="mergesortPRO"
    long_name="mergesortPRO"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw><paragraph>This visualization provides a running time analysis for Merge Sort.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="MergeSortAnalysisCON"
    long_name="MergeSortAnalysisCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Sorting/mergesortCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Development/MergeSortAnalysisCON.js</odsascript></raw></section></document>