{"document": {"@dupnames": "data\\ structures\\ and\\ algorithms", "@ids": "data-structures-and-algorithms", "@source": "<string>", "@title": "Data Structures and Algorithms", "title": "Data Structures and Algorithms", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@dupnames": "data\\ structures\\ and\\ algorithms", "@ids": "id1", "title": "Data Structures and Algorithms", "section": [{"@ids": "introduction", "@names": "introduction", "title": "Introduction", "paragraph": ["How many cities with more than 250,000 people lie within 500 miles of\nDallas, Texas?\nHow many people in my company make over $100,000 per year?\nCan we connect all of our telephone customers with less than 1,000\nmiles of cable?\nTo answer questions like these, it is not enough to have the\nnecessary information.\nWe must organize that information in a way that allows us to find the\nanswers in time to satisfy our needs.", "Representing information is fundamental to computer science.\nThe primary purpose of most computer programs is not to\nperform calculations, but to store and retrieve information\nusually as fast as possible.\nFor this reason, the study of data structures and the algorithms that\nmanipulate them is at the heart of computer science.\nAnd that is what this book is about  helping you to understand\nhow to structure information to support efficient processing.", "Any course on Data Structures and Algorithms will try to teach you\nabout three things:", "There are often many approaches to solving a problem.\nHow do we choose between them?\nAt the heart of computer program design are two (sometimes conflicting)\ngoals:", "Ideally, the resulting program is true to both of these goals.\nWe might say that such a program is \"elegant.\"\nWhile the algorithms and program code examples presented here\nattempt to be elegant in this sense, it is not the purpose of this\nbook to explicitly treat issues related to goal (1).\nThese are primarily concerns for the discipline of\nSoftware Engineering.\nRather, we mostly focus on issues relating to goal (2).", {"title_reference": "asymptotic analysis", "#text": "How do we measure efficiency?\nOur method for evaluating the efficiency of an algorithm or computer\nprogram is called .\nAsymptotic analysis also gives a way to define the inherent difficulty\nof a problem.\nThroughout the book we use asymptotic analysis techniques to\nestimate the time cost for every algorithm presented.\nThis allows you to see how each algorithm compares to other\nalgorithms for solving the same problem in terms of its\nefficiency."}], "enumerated_list": [{"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "It will present a collection of commonly used data structures and\nalgorithms.\nThese form a programmer's basic \"toolkit\".\nFor many problems, some data structure or algorithm in the toolkit\nwill provide a good solution.\nWe focus on data structures and algorithms that have proven over\ntime to be most useful."}, {"paragraph": "It will introduce the idea of tradeoffs, and reinforce the concept\nthat there are costs and benefits associated with every data\nstructure or algorithm.\nThis is done by describing, for each data structure,\nthe amount of space and time required for typical operations.\nFor each algorithm, we examine the time required for key input\ntypes."}, {"paragraph": "It will teach you how to measure the effectiveness of a data\nstructure or algorithm.\nOnly through such measurement can you determine which data\nstructure in your toolkit is most appropriate for a new problem.\nThe techniques presented also allow you to judge the merits of\nnew data structures that you or others might invent."}]}, {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "To design an algorithm that is easy to understand, code, and debug."}, {"paragraph": "To design an algorithm that makes efficient use of the computer's\nresources."}]}]}, {"@ids": "a-philosophy-of-data-structures", "@names": "a\\ philosophy\\ of\\ data\\ structures", "title": "A Philosophy of Data Structures", "paragraph": ["You might think that with ever more powerful computers,\nprogram efficiency is becoming less important.\nAfter all, processor speed and memory size still continue to improve.\nWon't today's efficiency problem be solved by tomorrow's hardware?", "As we develop more powerful computers,\nour history so far has always been to use that additional computing\npower to tackle more complex problems, be it in the form of more\nsophisticated user interfaces, bigger problem sizes, or new problems\npreviously deemed computationally infeasible.\nMore complex problems demand more computation, making the need for\nefficient programs even greater.\nUnfortunately, as tasks become more complex, they become less like\nour everyday experience.\nSo today's computer scientists must be trained to have a thorough\nunderstanding of the principles behind efficient program design,\nbecause their ordinary life experiences often do not apply when\ndesigning computer programs.", {"title_reference": ["data structure", "Abstract Data Types <abstract data type> <ADT>"], "#text": "In the most general sense, a  is any data\nrepresentation and its associated operations.\nEven an integer or floating point number stored on the computer can be\nviewed as a simple data structure.\nMore commonly, people use the term \"data structure\" to mean\nan organization or structuring for a collection of data items.\nA sorted list of integers stored in an array is an\nexample of such a structuring.\nThese ideas are explored further in a discussion of\n."}, {"title_reference": ["data items <data item>", "hash table"], "#text": "Given sufficient space to store a collection of\n,\nit is always possible to search for specified items within the\ncollection, print or otherwise process the data items in any desired\norder, or modify the value of any particular data item.\nThe most obvious example is an unsorted array containing all of the\ndata items.\nIt is possible to perform all necessary operations on an unsorted\narray.\nHowever, using the proper data structure can make the difference\nbetween a program running in a few seconds and one requiring many\ndays.\nFor example, searching for a given record in a  is\nmuch faster than searching for it in an unsorted array."}, {"title_reference": ["efficient", "resource constraints", "cost"], "#text": "A solution is said to be \nif it solves the problem within the required\n.\nExamples of resource constraints include the total space available to\nstore the data  possibly divided into separate main memory and disk\nspace constraints  and the time allowed to perform each subtask.\nA solution is sometimes said to be\nefficient if it requires fewer resources than known alternatives,\nregardless of whether it meets any particular requirements.\nThe  of a solution is the\namount of resources that the solution consumes.\nMost often, cost is measured in terms of one key resource such as\ntime, with the implied assumption that the solution meets the other\nresource constraints."}]}, {"@ids": "selecting-a-data-structure", "@names": "selecting\\ a\\ data\\ structure", "title": "Selecting a Data Structure", "raw": {"@format": "xml", "@xml:space": "preserve", "index": "null"}, "paragraph": [{"title_reference": ["data structure", "problem"], "#text": "It should go without saying that people write programs to\nsolve problems.\nHowever, sometimes programmers forget this.\nSo it is crucial to keep this truism in mind when selecting a\n to solve a particular .\nOnly by first analyzing the problem to determine the performance\ngoals that must be achieved can there be any hope of selecting the\nright data structure for the job.\nPoor program designers ignore this analysis step\nand apply a data structure that they are familiar with but which is\ninappropriate to the problem.\nThe result is typically a slow program.\nConversely, there is no sense in adopting a complex representation to\n\"improve\" a program that can meet its performance goals when\nimplemented using a simpler design."}, "When selecting a data structure to solve a problem, you should follow\nthese steps.", "This three-step approach to selecting a data structure operationalizes\na data-centered view of the design process.\nThe first concern is for the data and the operations to be performed\non them, the next concern is the representation for those data, and\nthe final concern is the implementation of that representation.", "Resource constraints on certain key operations, such as search,\ninserting data records, and deleting data records, normally drive\nthe data structure selection process.\nMany issues relating to the relative importance of these operations\nare addressed by the following three questions, which you should ask\nyourself whenever you must choose a data structure.", "Each data structure has associated costs and benefits.\nIn practice, it is hardly ever true that one data structure is\nbetter than another for use in all situations.\nIf one data structure or algorithm is superior to another in all\nrespects, the inferior one will usually have long been forgotten.\nFor nearly every data structure and algorithm presented in this\nbook, you will see examples of where it is the best choice.\nSome of the examples might surprise you.", "A data structure requires a certain amount of\nspace for each data item it stores,\na certain amount of time to perform a single basic\noperation, and a certain amount of programming effort.\nEach problem has constraints on available space and time.\nEach solution to a problem makes use of the basic operations in some\nrelative proportion, and the data structure selection process\nmust account for this.\nOnly after a careful analysis of your problem's characteristics can\nyou determine the best data structure for the task."], "enumerated_list": [{"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"title_reference": "basic operations <basic operation>", "#text": "Analyze your problem to determine the\n that\nmust be supported.\nExamples of basic operations include inserting a data\nitem into the data structure, deleting a data item from the\ndata structure, and finding a specified data item."}}, {"paragraph": "Quantify the resource constraints for each operation."}, {"paragraph": "Select the data structure that best meets these requirements."}]}, {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Are all data items inserted into the data structure at\nthe beginning, or are insertions interspersed with other operations?\nStatic applications (where the data are loaded at the beginning and\nnever change) typically get by with simpler data structures to get an\nefficient implementation, while dynamic applications often require\nsomething more complicated."}, {"paragraph": "Can data items be deleted?\nIf so, this will probably make the implementation more complicated."}, {"paragraph": "Are all data items processed in some well-defined order,\nor is search for specific data items allowed?\n\"Random access\" search generally requires more complex data\nstructures."}]}], "topic": [{"title": "Example", "paragraph": ["A bank must support many types of transactions with its customers, but\nwe will examine a simple model where customers wish to open accounts,\nclose accounts, and add money or withdraw money from accounts.\nWe can consider this problem at two distinct levels:\n(1) the requirements for the physical infrastructure and workflow\nprocess that the bank uses in its interactions with its customers,\nand (2) the requirements for the database system that manages the\naccounts.", "The typical customer opens and closes accounts far less often than he\nor she accesses the account.\nCustomers are willing to spend many minutes during the process of\nopening or closing the account, but are typically not willing to\nwait more than a brief time for individual account transactions\nsuch as a deposit or withdrawal.\nThese observations can be considered as informal specifications for\nthe time constraints on the problem.", "It is common practice for banks to provide two tiers of service.\nHuman tellers or automated teller machines (ATMs) support customer\naccess to account balances and updates such as deposits and\nwithdrawals.\nSpecial service representatives are typically provided (during\nrestricted hours) to handle opening and closing accounts.\nTeller and ATM transactions are expected to take little time.\nOpening or closing an account can take much longer (perhaps up to an\nhour from the customer's perspective).", "From a database perspective, we see that\nATM transactions do not modify the database significantly.\nFor simplicity, assume that if money is added or removed, this\ntransaction simply changes the value stored in an account record.\nAdding a new account to the database is allowed to take several\nminutes.\nDeleting an account need have no time constraint, because from the\ncustomer's point of view all that matters is that all the money be\nreturned (equivalent to a withdrawal).\nFrom the bank's point of view, the account record might be removed\nfrom the database system after business hours, or at the end of the\nmonthly account cycle.", {"title_reference": ["exact-match query", "hash table <hash table> <HashIntro>"], "#text": "When considering the choice of data structure to use in the database\nsystem that manages customer accounts, we see that\na data structure that has little concern for the cost of deletion,\nbut is highly efficient for search and moderately efficient for\ninsertion, should meet the resource constraints imposed by this\nproblem.\nRecords are accessible by unique account number (sometimes called\nan ).\nOne data structure that meets these requirements is the\n.\nHash tables allow for extremely fast exact-match search.\nA record can be modified quickly when the modification does not\naffect its space requirements.\nHash tables also support efficient insertion of new records.\nWhile deletions can also be supported efficiently, too many deletions\nlead to some degradation in performance for the remaining operations.\nHowever, the hash table can be reorganized periodically to restore\nthe system to peak efficiency.\nSuch reorganization can occur offline so as not to affect ATM\ntransactions."}]}, {"title": "Example", "paragraph": [{"title_reference": "range query", "#text": "A company is developing a database system containing information\nabout cities and towns in the United States.\nThere are many thousands of cities and towns, and the database\nprogram should allow users to find information about a particular\nplace by name (another example of an exact-match query).\nUsers should also be able to find all places that match a\nparticular value or range of values for attributes such as location\nor population size.\nThis is known as a ."}, "A reasonable database system must answer queries quickly enough to\nsatisfy the patience of a typical user.\nFor an exact-match query, a few seconds is satisfactory.\nIf the database is meant to support range queries that can return many\ncities that match the query specification,\nthe user might tolerate the entire operation to take longer,\nperhaps on the order of a minute.\nTo meet this requirement, it will be necessary to support operations\nthat process range queries efficiently by processing all cities in the\nrange as a batch, rather than as a series of operations on individual\ncities.", {"title_reference": ["B$^+$-tree <B$^+$-tree> <BTree>", "linear index <linear index> <LinearIndexing>"], "#text": "The hash table suggested in the previous example is inappropriate\nfor implementing our city database, because it cannot perform\nefficient range queries.\nThe  supports large databases,\ninsertion and deletion of data records, and range queries.\nHowever, a simple\n would be\nmore appropriate if the database is created once, and then never\nchanged, such as an atlas distributed on a CD or accessed from a\nwebsite."}]}]}, {"@ids": "introduction-summary-questions", "@names": "introduction\\ summary\\ questions", "title": "Introduction Summary Questions", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "IntroSumm", "@long_name": "IntroSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}}]}, {"@ids": "some-software-engineering-topics", "@names": "some\\ software\\ engineering\\ topics", "title": "Some Software Engineering Topics", "paragraph": {"emphasis": "is", "#text": "While the main focus of this course  data structures and algorithms,\nthis course will also cover some additional topics which are not standard fare\nin a data structures course:"}, "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "An introduction to object orientation and the Unified Modeling Language (UML)."}, {"paragraph": "An introduction to software design patterns."}, {"paragraph": "An introduction to software development processes."}]}}]}}