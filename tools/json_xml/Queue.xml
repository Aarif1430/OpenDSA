<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="queues" names="queues" source="&lt;string&gt;" title="Queues"><title>Queues</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/List/aqueueCON.css</odsalink></raw><section ids="queue-terminology" names="queue\ terminology"><title>Queue Terminology</title><paragraph>Like the stack, the <title_reference>queue</title_reference> is a list-like structure that
provides restricted access to its elements.
Queue elements may only be inserted at the back (called an
<title_reference>enqueue</title_reference> operation) and removed from the
front (called a <title_reference>dequeue</title_reference> operation).
Queues operate like standing in line at a movie theater ticket
counter.
If nobody cheats, then newcomers go to the back of the line.
The person at the front of the line is the next to be served.
Thus, queues release their elements in order of arrival.
In Britain, a line of people is called a "queue",
and getting into line to wait for service is called "queuing up".
Accountants have used queues since long before the
existence of computers.
They call a queue a "FIFO" list, which stands for
"First-In, First-Out".
Here is a sample queue ADT.
This section presents two implementations for queues:
the array-based queue and the linked queue.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw></section><section ids="array-based-queues" names="array-based\ queues"><title>Array-Based Queues</title><paragraph>The array-based queue is somewhat tricky to implement effectively.
A simple conversion of the array-based list implementation is not
efficient.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="aqueueFirstCON"
    long_name="aqueueFirstCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="aqueueDriftCON"
    long_name="aqueueDriftCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="aqueueBadCON"
    long_name="aqueueBadCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><section ids="the-circular-queue" names="the\ circular\ queue"><title>The Circular Queue</title><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="aqueueCircularCON"
    long_name="aqueueCircularCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="aqueueEmptyCON"
    long_name="aqueueEmptyCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>If the value of <literal>front</literal> is fixed, then <math>n+1</math> different
values for <literal>rear</literal> are needed to distinguish among the <math>n+1</math>
states.
However, there are only <math>n</math> possible values for <literal>rear</literal> unless
we invent a special case for, say, empty queues.
This is an example of the <title_reference>Pigeonhole Principle</title_reference>.
The Pigeonhole Principle states that, given <math>n</math> pigeonholes
and <math>n+1</math> pigeons, when all of the pigeons go into the holes we
can be sure that at least one hole contains more than one pigeon.
In similar manner, we can be sure that two of the <math>n+1</math> states
are indistinguishable by the <math>n</math> relative values of <literal>front</literal>
and <literal>rear</literal>.
We must seek some other way to distinguish full from empty queues.</paragraph><paragraph>One obvious solution is to keep an explicit count of the number of
elements in the queue, or at least a Boolean variable that indicates
whether the queue is empty or not.
Another solution is to make the array be of size <math>n+1</math>,
and only allow <math>n</math> elements to be stored.
Which of these solutions to adopt is purely a matter of the
implementor's taste in such affairs.
Our choice here is to use an array of size <math>n+1</math>.</paragraph><paragraph>Here is an array-based queue implementation.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw></section></section><section ids="array-based-queue-implementation" names="array-based\ queue\ implementation"><title>Array-based Queue Implementation</title><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="aqueueVarCON"
    long_name="aqueueVarCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>In this implementation, the front of the queue is defined to be toward
the lower numbered positions in the array (in the counter-clockwise
direction in the circular array), and the rear is
defined to be toward the higher-numbered positions.
Thus, <literal>enqueue</literal> increments the rear pointer (modulus <literal>maxSize</literal>),
and <literal>dequeue</literal> increments the front pointer.
Implementation of all member functions is straightforward.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="AqueueEnqueuePRO"
    long_name="AqueueEnqueuePRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="array-based-dequeue-practice" names="array-based\ dequeue\ practice"><title>Array-based Dequeue Practice</title><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="AqueueDequeuePRO"
    long_name="AqueueDequeuePRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>DataStructures/CircularQueue.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/aqueueFirstCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/aqueueDriftCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/aqueueBadCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/aqueueCircularCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/aqueueEmptyCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/List/aqueueVarCON.js</odsascript></raw></section></document>