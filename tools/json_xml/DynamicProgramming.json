{"document": {"@ids": "dynamic-programming", "@names": "dynamic\\ programming", "@source": "<string>", "@title": "Dynamic Programming", "title": "Dynamic Programming", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@ids": "computing-fibonnaci-numbers", "@names": "computing\\ fibonnaci\\ numbers", "title": "Computing Fibonnaci Numbers", "paragraph": [{"title_reference": "n", "#text": "Consider the recursive function for computing the 'th\nFibonacci number."}, {"title_reference": ["n", "1.62^n"], "#text": "The cost of this algorithm (in terms of function calls) is the size of\nthe 'th Fibonacci number itself, which our analysis of\nModule :ref`summation <summation> <Summation>` showed to be exponential\n(approximately  ).\nWhy is this so expensive?\nPrimarily because two recursive calls are made by the\nfunction, and the work that they do is largely redundant.\nThat is, each of the two calls is recomputing most of the series, as\nis each sub-call, and so on.\nThus, the smaller values of the function are being recomputed a huge\nnumber of times.\nIf we could eliminate this redundancy, the cost would be greatly\nreduced.\nThe approach that we will use can also improve any algorithm that\nspends most of its time recomputing common subproblems."}, "One way to accomplish this goal is to keep a table of values, and\nfirst check the table to see if the computation can be avoided.\nHere is a straightforward example of doing so.", {"title_reference": ["n", "n"], "#text": "This version of the algorithm will not compute a value more than once,\nso its cost should be linear.\nOf course, we didn't actually need to use a table storing all of the\nvalues, since future computations do not need access to all prior\nsubproblems.\nInstead, we could build the value by working from 0 and 1 up to\n rather than backwards from  down to 0 and 1.\nGoing up from the bottom we only need to store the previous two values\nof the function, as is done by our iterative version."}, {"literal": "fibi", "#text": "Recomputing of subproblems comes up in many algorithms.\nIt is not so common that we can store only a few prior results as we\ndid for .\nThus, there are many times where storing a complete table of\nsubresults will be useful."}, {"title_reference": "dynamic programming", "#text": "This approach to designing an algorithm that works by storing a table\nof results for subproblems is called .\nThe name is somewhat arcane, because it doesn't bear much obvious\nsimilarity to the process that is taking place when storing subproblems\nin a table.\nHowever, it comes originally from the field of dynamic control\nsystems, which got its start before what we think of as computer\nprogramming.\nThe act of storing precomputed values in a table for later reuse is\nreferred to as \"programming\" in that field."}, {"literal": ["fibrt", "fibi", "fibrt"], "#text": "Dynamic programming is a powerful alternative to the standard\nprinciple of divide and conquer.\nIn divide and conquer, a problem is split into subproblems, the\nsubproblems are solved (independently), and then recombined into a\nsolution for the problem being solved.\nDynamic programming is appropriate whenever\n(1) subproblems are solved repeatedly,\nand (2) we can find a suitable way of doing the necessary\nbookkeeping.\nDynamic programming algorithms are usually not implemented by simply\nusing a table to store subproblems for recursive calls (i.e., going\nbackwards as is done by ).\nInstead, such algorithms are typically implemented by building the\ntable of subproblems from the bottom up.\nThus,  better represents the most common form of dynamic\nprogramming than does , even though it doesn't use the\ncomplete table."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}]}, {"@ids": "the-knapsack-problem", "@names": "the\\ knapsack\\ problem", "title": "The Knapsack Problem", "paragraph": ["We will next consider a problem that appears with many variations in a\nvariety of commercial settings.\nMany businesses need to package items with the greatest efficiency.\nOne way to describe this basic idea is in terms of packing items into\na knapsack, and so we will refer to this as the Knapsack Problem.\nWe will first define a particular formulation of the knapsack problem,\nand then we will discuss an algorithm to solve it based on dynamic\nprogramming.\nThere are many other versions for the problem", {"title_reference": ["K", "n", "i", "k_i", "n", "K", "K = 5", "k_1 = 2", "k_2 = 4", "k_3 = 1", "S subset {1, 2, ..., n}"], "#text": "Assume that we have a knapsack with a certain amount of space that we\nwill define using integer value .\nWe also have  items each with a certain size such that\nthat item  has integer size .\nThe problem is to find a subset of the  items whose sizes\nexactly sum to , if one exists.\nFor example, if our knapsack has capacity  and the two\nitems are of size  and ,\nthen no such subset exists.\nBut if we add a third item of size ,\nthen we can fill the knapsack exactly with the second and third\nitems.\nWe can define the problem more formally as:\nFind  such that"}, {"title_reference": ["K", "n"], "#text": "If you tried solving these examples, you probably found yourself doing\na lot of trial-and-error and a lot of backtracking.\nTo come up with an algorithm, we want an organized way to go through\nthe possible subsets.\nIs there a way to make the problem smaller, so that we can apply\ndivide and conquer?\nWe essentially have two parts to the input: The knapsack size\n and the  items.\nIt probably will not do us much good to try and break the knapsack\ninto pieces and solve the sub-pieces (since we already saw that\nknowing the answer for a knapsack of size 163 did nothing to help us\nsolve the problem for a knapsack of size 164)."}, {"title_reference": ["n", "n", "n-1", "n", "n", "n-1", "K - k_n", "n", "k_n"], "#text": "So, what can we say about solving the problem with or without the\n'th item?\nThis seems to lead to a way to break down the problem.\nIf the 'th item is not needed for a solution (that is, if we\ncan solve the problem with the first  items) then we can\nalso solve the problem when the 'th item is available\n(we just ignore it).\nOn the other hand, if we do include the 'th item as a member\nof the solution subset, then we now would need to solve the problem\nwith the first  items and a knapsack of size\n (since the 'th\nitem is taking up  space in the knapsack)."}, {"title_reference": ["K", "n", "P(n, K)", "P(n, K)", "P(n-1, K)", "P(n-1, K-k_n)", "P(n, K)", "n"], "#text": "To organize this process, we can define the problem in terms of\ntwo parameters: the knapsack size  and the number of items\n.\nDenote a given instance of the problem as .\nNow we can say that  has a solution if and only if\nthere exists a solution for either  or\n.\nThat is, we can solve  only if we can solve one of the\nsub problems where we use or do not use the  th item.\nOf course, the ordering of the items is arbitrary.\nWe just need to give them some order to keep things straight."}, {"title_reference": ["n-1", "n-2", "mathbf{T}(n) = 2mathbf{T}(n-1) + c = Theta(2^n)"], "#text": "Continuing this idea, to solve any subproblem of size ,\nwe need only to solve two subproblems of size .\nAnd so on, until we are down to only one item that either fills the\nknapsack or not.\nThis naturally leads to a cost expressed by the recurrence relation\n.\nThat can be pretty expensive!"}, {"title_reference": ["n(K+1)", "n times K+1", "P(i, k), 1 leq i leq n, 0 leq k leq K"], "#text": "But... we should quickly realize that there are only \nsubproblems to solve!\nClearly, there is the possibility that many subproblems are being\nsolved repeatedly.\nThis is a natural opportunity to apply dynamic programming.\nWe simply build an array of size  to contain the\nsolutions for all subproblems\n."}, {"title_reference": ["P(n, K)", "k_1", "i=2", "n"], "#text": "There are two approaches to actually solving the problem.\nOne is to start with our problem of size  and make\nrecursive calls to solve the subproblems, each time checking the array\nto see if a subproblem has been solved, and filling in the\ncorresponding cell in the array whenever we get a new subproblem\nsolution.\nThe other is to start filling the array for row 1 (which indicates a\nsuccessful solution only for a knapsack of size ).\nWe then fill in the succeeding rows\nfrom  to , left to right, as follows."}, {"title_reference": "Theta(nK)", "#text": "In other words, a new slot in the array gets its solution by looking\nat two slots in the preceding row.\nSince filling each slot in the array takes constant time, the total\ncost of the algorithm is ."}], "math_block": {"@xml:space": "preserve", "#text": "\\sum_{i \\in S} k_i = K."}, "topic": [{"title": "Example", "paragraph": [{"title_reference": "K = 163", "#text": "Assume that we are given a knapsack of size  and\n10 items of sizes 4, 9, 15, 19, 27, 44, 54, 68, 73, 101.\nCan we find a subset of the items that exactly fills the knapsack?\nYou should take a few minutes and try to do this before reading on\nand looking at the answer."}, "One solution to the problem is: 19, 27, 44, 73."]}, {"title": "Example", "paragraph": ["Having solved the previous example for knapsack of size 163, how\nhard is it now to solve for a knapsack of size 164?\nTry it.", "Unfortunately, knowing the answer for 163 is of almost no use at\nall when solving for 164.\nOne solution is: 9, 54, 101."]}, {"title": "Example", "paragraph": [{"title_reference": "K = 10", "#text": "Solve the Knapsack Problem for  and five items with\nsizes 9, 2, 7, 4, 1.\nWe do this by building the following array."}, {"title_reference": ["P(3, 9)", "P(2, 9)", "P(2,2) = P(2, 9-7)", "P(5, 10)", "P(4, 9)", "P(3, 9)"], "#text": "For example,  stores value I/O.\nIt contains O because  has a solution.\nIt contains I because  has a solution.\nSince  is marked with an I, it has a solution.\nWe can determine what that solution actually is by recognizing that\nit includes the 5th item (of size 1), which then leads us to look at\nthe solution for .\nThis in turn has a solution that omits the 4th item,\nleading us to .\nAt this point, we can either use the third item or not.\nWe can find a solution by taking one branch.\nWe can find all solutions by following all branches when there is a\nchoice."}], "math_block": {"@xml:space": "preserve", "#text": "\\begin{array}{l|ccccccccccc}\n&0&1&2&3&4&5&6&7&8&9&10\\\\\n\\hline\nk_1\\!=\\!9&O&-&-&-&-&-&-&-&-&I&-\\\\\nk_2\\!=\\!2&O&-&I&-&-&-&-&-&-&O&-\\\\\nk_3\\!=\\!7&O&-&O&-&-&-&-&I&-&I/O&-\\\\\nk_4\\!=\\!4&O&-&O&-&I&-&I&O&-&O&-\\\\\nk_5\\!=\\!1&O&I&O&I&O&I&O&I/O&I&O&I\n\\end{array}"}, "line_block": {"line": "Key:", "line_block": {"line": [{"title_reference": "P(i, k)", "#text": "-:  No solution for ."}, {"title_reference": ["P(i, k)", "i"], "#text": "O: Solution(s) for  with  omitted."}, {"title_reference": ["P(i, k)", "i"], "#text": "I: Solution(s) for  with  included."}, {"title_reference": ["P(i, k)", "i"], "#text": "I/O: Solutions for  with  included AND omitted."}]}}}], "line_block": {"line": {"strong": "if", "title_reference": "P(n-1, K)", "#text": "has a solution,"}, "line_block": {"line": [{"strong": "then", "title_reference": "P(n, K)", "#text": "has a solution"}, {"strong": "else if", "title_reference": "P(n-1, K-k_n)", "#text": "has a solution"}], "line_block": {"line": [{"strong": "then", "title_reference": "P(n, K)", "#text": "has a solution"}, {"strong": "else", "title_reference": "P(n, K)", "#text": "has no solution."}]}}}}]}}