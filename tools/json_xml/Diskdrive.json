{"document": {"@dupnames": "disk\\ drives", "@ids": "disk-drives", "@source": "<string>", "@title": "Disk Drives", "title": "Disk Drives", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Development/sectorLayoutCON.css"}], "section": [{"@dupnames": "disk\\ drives", "@ids": "id1", "title": "Disk Drives", "paragraph": [{"title_reference": ["random access", "disk <disk drive>", "logical file", "physical file", "file manager"], "#text": "A programmer typically views a  file stored on\n as a contiguous series of bytes, with those\nbytes possibly combining to form data records.\nThis is called the .\nThe  actually stored on disk is\nusually not a contiguous series of\nbytes.\nIt could well be in pieces spread all over the disk.\nThe , a part of the operating\nsystem,\nis responsible for taking requests for data from a logical\nfile and mapping those requests to the physical location of the data\non disk.\nLikewise, when writing to a particular logical byte position\nwith respect to the beginning of the file, this position must be\nconverted by the file manager into the corresponding physical\nlocation on the disk.\nTo gain some appreciation for the the approximate time costs for these\noperations, you need to understand the physical structure and basic\nworkings of a disk drive."}, {"title_reference": ["direct access", "sequential access"], "#text": "Disk drives are often referred to as\n storage devices.\nThis means that it takes roughly equal time to access any record in\nthe file.\nThis is in contrast to  storage devices\nsuch as tape drives, which require the tape reader to\nprocess data from the beginning of the tape until the desired position\nhas been reached.\nAs you will see, the disk drive is only approximately direct access:\nAt any given time, some records are more quickly accessible than\nothers."}]}, {"@ids": "disk-drive-architecture", "@names": "disk\\ drive\\ architecture", "title": "Disk Drive Architecture", "paragraph": [{"title_reference": ["platters <platter>", "spindle", "read/write head", "I/O head"], "#text": "A hard disk drive is composed of one or more round\n,\nstacked one on top of another and attached to a central\n.\nPlatters spin continuously at a constant rate.\nEach usable surface of each platter is assigned a\n or  through which data are\nread or written, somewhat like the arrangement of a phonograph\nplayer's arm \"reading\" sound from a phonograph record.\nUnlike a phonograph needle, the disk read/write head does not actually\ntouch the surface of a hard disk.\nInstead, it remains slightly above the surface, and any contact during\nnormal operation would damage the disk.\nThis distance is very small, much smaller than the height of a dust\nparticle.\nIt can be likened to a 5000-kilometer airplane trip across the United\nStates, with the plane flying at a height of one meter!"}, {"title_reference": ["Figure #Platters", "arm", "boom", "track", "Figure #Platters", "cylinder"], "footnote_reference": {"@auto": "1", "@ids": "id2", "@refid": "id3", "#text": "1"}, "#text": "A hard disk drive typically has several platters and\nseveral read/write heads, as shown in\nFigure  (a).\nEach head is  attached to an , which connects to the\n. \nThe boom moves all of the heads in or out together.\nWhen the heads are in some position over the platters, there are data\non each platter directly accessible to each head.\nThe data on a single platter that are accessible to any one position\nof the head for that platter are collectively called a ,\nthat is, all data on a platter that are a fixed distance from the\nspindle, as shown in Figure  (b).\nThe collection of all tracks that are a fixed distance from the\nspindle is called a .\nThus, a cylinder is all of the data that can be read when the arms\nare in a particular position."}, {"title_reference": ["sectors <sector>", "inter-sector gaps <inter-sector gap>", "Figure #Diskfig", "zones <zone>", "Figure #Diskfig"], "#text": "Each track is subdivided into .\nBetween each sector there are\n\nin which no data are stored.\nThese gaps allow the read head to recognize the end of a sector.\nNote that each sector contains the same amount of data.\nBecause the outer tracks have greater length, they contain fewer\nbits per inch than do the inner tracks.\nThus, about half of the potential storage space is wasted, because\nonly the innermost tracks are stored at the highest possible data\ndensity.\nThis arrangement is illustrated by\nFigure  (a).\nDisk drives today actually group tracks into\n such that the tracks in the innermost zone adjust\ntheir data density going out to maintain the same radial data density,\nthen the tracks of the next zone reset the data density to make better\nuse of their storage ability, and so on.\nThis arrangement is shown in Figure  (b)."}, "In contrast to the physical layout of a hard disk, a CD-ROM consists\nof a single spiral track.\nBits of information along the track are equally spaced, so the\ninformation density is the same at both the outer and inner portions\nof the track.\nTo keep the information flow at a constant rate along the spiral, the\ndrive must speed up the rate of disk spin as the I/O head moves\ntoward the center of the disk.\nThis makes for a more complicated and slower mechanism.", {"title_reference": ["seek", "rotational delay", "rotational latency"], "#text": "Three separate steps take place when reading a particular byte or\nseries of bytes of data from a hard disk.\nFirst, the I/O head moves so that it is positioned over the track\ncontaining the data.\nThis movement is called a .\nSecond, the sector containing the data rotates to come under the\nhead.\nWhen in use the disk is always spinning.\nAt the time of this writing, typical disk spin rates are\n7200 rotations per minute (rpm).\nThe time spent waiting for the desired sector to come under\nthe I/O head is called  or\n.\nThe third step is the actual transfer (i.e., reading or writing) of\ndata.\nIt takes relatively little time to read information once the first\nbyte is positioned under the I/O head, simply the amount of time\nrequired for it all to move under the head.\nIn fact, disk drives are designed not to read one byte of data, but\nrather to read an entire sector of data at each request.\nThus, a sector is the minimum amount of data that can be read or\nwritten at one time."}, "In general, it is desirable to keep all sectors for a file together on\nas few tracks as possible.\nThis desire stems from two assumptions:", {"title_reference": "locality of reference", "#text": "Assumption (2) is called\n,\na concept that comes up frequently in computer applications."}, {"title_reference": "cluster", "#text": "Contiguous sectors are often grouped to form a\n.\nA cluster is the smallest unit of allocation for a file,\nso all files are a multiple of the cluster size.\nThe cluster size is determined by the operating\nsystem.\nThe file manager keeps track of which clusters make up each file."}, {"title_reference": ["File Allocation Table", "block", "inodes <inode>"], "#text": "In Microsoft Windows systems, there is a\ndesignated portion of the disk called the\n,\nwhich stores information about which sectors belong to which file.\nIn contrast, Unix does not use clusters.\nThe smallest unit of file allocation and the smallest unit that can be\nread/written is a sector, which in Unix terminology is called\na .\nUnix maintains information about file organization in certain disk\nblocks called ."}, {"title_reference": "extent", "#text": "A group of physically contiguous clusters from the same file is called\nan .\nIdeally, all clusters making up a file will be contiguous on the disk\n(i.e., the file will consist of one extent),\nso as to minimize seek time required to access different portions of\nthe file.\nIf the disk is nearly full when a file is created, there might not be\nan extent available that is large enough to hold the new file.\nFurthermore, if a file grows, there might not be free space physically\nadjacent.\nThus, a file might consist of several extents widely spaced on the\ndisk.\nThe fuller the disk, and the more that files on the disk change, the\nworse this file fragmentation (and the resulting seek time) becomes.\nFile fragmentation leads to a noticeable degradation in performance as\nadditional seeks are required to access data."}, {"title_reference": "internal fragmentation", "#text": "Another type of problem arises when the file's logical record size\ndoes not match the sector size.\nIf the sector size is not a multiple of the record size\n(or vice versa), records will not fit evenly within a sector.\nFor example, a sector might be 2048 bytes long, and a logical record\n100 bytes.\nThis leaves room to store 20 records with 48 bytes left over.\nEither the extra space is wasted, or else records\nare allowed to cross sector boundaries.\nIf a record crosses a sector boundary, two disk accesses might be\nrequired to read it.\nIf the space is left empty instead, such wasted space is called\n."}, "A second example of internal fragmentation occurs at cluster\nboundaries.\nFiles whose size is not an even multiple of the cluster size must\nwaste some space at the end of the last cluster.\nThe worst case will occur when file size modulo cluster size is one\n(for example, a file of 4097 bytes and a cluster of 4096 bytes).\nThus, cluster size is a tradeoff between large files\nprocessed sequentially (where a large cluster size is desirable to\nminimize seeks) and small files (where small clusters are desirable to\nminimize wasted storage).", {"title_reference": ["Figure #Layout", "sector headers <sector header>"], "#text": "Every disk drive organization requires that some disk space be used\nto organize the sectors, clusters, and so forth.\nThe layout of sectors within a track is illustrated by\nFigure .\nTypical information that must be stored on the disk itself includes\nthe File Allocation Table, \nthat contain address\nmarks and information about the condition (whether usable or not) for\neach sector, and gaps between sectors.\nThe sector header also contains error detection codes to help verify\nthat the data have not been corrupted.\nThis is why most disk drives have a \"nominal\" size that is greater\nthan the actual amount of user data that can be stored on the drive.\nThe difference is the amount of space required to organize the\ninformation on the disk.\nEven more space will be lost due to\nfragmentation."}], "target": [{"@refid": "platters"}, {"@refid": "diskfig"}, {"@refid": "layout"}], "raw": [{"@format": "xml", "@ids": "platters", "@names": "platters", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "diskfig", "@names": "diskfig", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "layout", "@names": "layout", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "diskSector", "@long_name": "diskSector", "@points": "0", "@required": "True", "@threshold": "1.0"}}], "enumerated_list": [{"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": {"paragraph": "Seek time is slow (it is typically the most expensive part of\nan I/O operation), and"}}, {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": {"paragraph": "If one sector of the file is read, the next sector will\nprobably soon be read."}}]}, {"@ids": "disk-access-costs", "@names": "disk\\ access\\ costs", "title": "Disk Access Costs", "paragraph": ["When a seek is required, it is usually\nthe primary cost when accessing information on disk.\nThis assumes of course that a seek is necessary.\nWhen reading a file in sequential order (if the sectors comprising the\nfile are contiguous on disk), little seeking is necessary.\nHowever, when accessing a random disk sector, seek time becomes the\ndominant cost for the data access.\nWhile the actual seek time is highly variable, depending on the\ndistance between the track where the I/O head currently is and the\ntrack where the head is moving to, we will consider only two numbers.\nOne is the track-to-track cost, or the minimum time necessary to move\nfrom a track to an adjacent track.\nThis is appropriate when you want to analyze access times for files\nthat are well placed on the disk.\nThe second number is the average seek time for a random access.\nThese two numbers are often provided by disk manufacturers.\nA typical example is the Western Digital Caviar serial ATA drive.\nThe manufacturer's specifications indicate that the track-to-track\ntime is 2.0 ms and the average seek time is 9.0 ms.\nIn 2008 a typical drive in this line might be 120GB in size.\nIn 2011, that same line of drives had sizes of up to 2 or 3TB.\nIn both years, the advertised track-to-track and average seek times\nwere identical.", "For many years, typical rotation speed for disk drives was 3600 rpm,\nor one rotation every 16.7 ms.\nMost disk drives in 2011 had a rotation speed of 7200 rpm, or 8.3 ms\nper rotation.\nWhen reading a sector at random, you can expect that the disk will\nneed to rotate halfway around to bring the desired sector\nunder the I/O head, or 4.2 ms for a 7200-rpm disk drive.", "Once under the I/O head, a sector of data can be transferred as\nfast as that sector rotates under the head.\nIf an entire track is to be read, then it will require one rotation\n(8.3 ms at 7200 rpm) to move the full track under the head.\nIf only part of the track is to be read, then proportionately less\ntime will be required.\nFor example, if there are 16,000 sectors on the track and one sector\nis to be read, this will require a trivial amount of time\n(1/16,000 of a rotation)."], "target": {"@refid": "diskexamp"}, "topic": {"@ids": "diskexamp", "@names": "diskexamp", "title": "Example", "paragraph": ["Assume that an older disk drive has a total (nominal) capacity of\n16.8GB spread among 10 platters, yielding 1.68GB/platter.\nEach platter contains 13,085 tracks and each track contains (after\nformatting) 256 sectors of 512 bytes/sector.\nTrack-to-track seek time is 2.2 ms and average seek time for random\naccess is 9.5 ms.\nAssume the operating system maintains a cluster size\nof 8 sectors per cluster (4KB), yielding 32 clusters per track.\nThe disk rotation rate is 5400 rpm (11.1 ms per rotation).\nBased on this information we can estimate\nthe cost for various file processing operations.", "How much time is required to read the track?\nOn average, it will require half a rotation to bring the first sector\nof the track under the I/O head, and then one complete rotation to\nread the track.", "How long will it take to read a file of 1MB divided into\n2048 sector-sized (512 byte) records?\nThis file will be stored in 256 clusters, because  each cluster holds\n8 sectors.\nThe answer to the question depends largely on how the file\nis stored on the disk, that is, whether it is all together or broken\ninto multiple extents.\nWe will calculate both cases to see how much difference this makes.", "If the file is stored so as to fill all of the sectors of eight\nadjacent tracks, then the cost to read the first sector will be the\ntime to seek to the first track (assuming this requires a random\nseek), then a wait for the initial rotational delay,\nand then the time to read (which is the same as the time to rotate the\ndisk again).\nThis requires", "In this equation, 9.5ms. is the average seek time for a (random)\ntrack on the disk. 11.1ms. is the time for one rotation of a disk\nspinning at 5400RPM.\nSince we need to wait for rotational delay (one half rotation) and\nthen read all of the contents of the track (one full rotation), we\nmultiply 11.1ms. by 1.5.\nThus, the total time to read a random track from the disk is 26.2ms.", "After reading the first track, we can then assume that the next\nseven tracks require only a track-to-track seek because they are\nadjacent.\nTherefore, each requires", "Here, 2.2ms. is the time to seek to an adjacent track.\nAgain we must wait for rotational delay (one half rotation)\nfollowed by a full rotation to read the track, so we multiply the\nrotation time (11.1ms.) times 1.5 for the disk rotation.\nThus, we get a total of 18.9ms. to read the data from an adjacent\ntrack.", "The total time required to read all 8 adjacent tracks is therefore", "In contrast, what would the time be if the file's clusters are\nspread randomly across the disk?\nThen we must perform a seek for each cluster, followed by the\ntime for rotational delay.\nOnce the first sector of the cluster comes under the I/O head, very\nlittle time is needed to read the cluster because only 8/256 of the\ntrack needs to rotate under the head, for a total time of about\n5.9 ms for latency and read time.\nThus, the total time required is about", "or close to 4 seconds.\nThis is much longer than the time required when the file is all\ntogether on disk!\nThat is, 256 times we must perform a seek to a random track\n(9.5ms.).\nThen we wait on average one half of a disk rotation\nfollowed by reading the actual data which requires a further 8/256\nof a rotation, for a total of 5.9ms.", "This example illustrates why it is important to keep disk files from\nbecoming fragmented,\nand why so-called \"disk defragmenters\" can speed up file\nprocessing time.\nFile fragmentation happens most commonly when the disk is nearly full\nand the file manager must search for free space\nwhenever a file is created or changed."], "math_block": [{"@xml:space": "preserve", "#text": "9.5\\mathrm{ms.} + 11.1\\mathrm{ms.} \\times 1.5 = 26.2 \\mathrm{ms.}"}, {"@xml:space": "preserve", "#text": "2.2\\mathrm{ms.} + 11.1\\mathrm{ms.} \\times 1.5 = 18.9 \\mathrm{ms.}"}, {"@xml:space": "preserve", "#text": "26.2 \\mathrm{ms} + 7 \\times 18.9 \\mathrm{ms} = 158.5 \\mathrm{ms}."}, {"@xml:space": "preserve", "#text": "256 (9.5\\mathrm{ms.} + 5.9\\mathrm{ms.}) \\approx 3942 \\mathrm{ms}"}]}}, {"@ids": "notes", "@names": "notes", "title": "Notes", "footnote": {"@auto": "1", "@backrefs": "id2", "@ids": "id3", "@names": "1", "label": "1", "paragraph": ["This arrangement, while typical, is not necessarily true for\nall disk drives.\nNearly everything said here about the physical arrangement of\ndisk drives represents a typical engineering compromise, not a\nfundamental design principle.\nThere are many ways to design disk drives, and the engineering\ncompromises change over time.\nIn addition, most of the description given here for disk drives\nis a simplified version of the reality.\nBut this is a useful working model to understand what is going\non.", "To complicate matters further, Solid State Drives (SSD) work\nrather differently."]}, "raw": {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Files/diskSectorCON.js"}}]}}