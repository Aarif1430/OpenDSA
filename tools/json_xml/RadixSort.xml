<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="radix\ sort" ids="radix-sort" source="&lt;string&gt;" title="Radix Sort"><title>Radix Sort</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><index>null</index></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Development/RadixSortAnalysisCON.css</odsalink></raw><section dupnames="radix\ sort" ids="id1"><title>Radix Sort</title><paragraph>The major problem with Binsort is that it does not work so well for a
large key range.
Fortunately, there is a way to keep the number of bins small and the
related processing relatively cheap while still using the idea of
binning records that have similar key values.
Consider a sequence of records with keys in the range 0 to 99.
If we have ten bins available, we can first assign records to bins by
taking their key value modulo 10.
Thus, every key will be assigned to the
bin matching its rightmost decimal digit.
We can then take these records from the bins <strong>in order</strong>,
and reassign them to the bins
on the basis of their leftmost (10's place) digit.
We will define values in the range 0 to 9 to have a leftmost digit of
0.
In other words, assign the <math>i</math>'th record from array <literal>A</literal> to
a bin using the formula <literal>A[i]/10</literal>.
If we now gather the values from
the bins <strong>in order</strong>, the result is a sorted list.
We can see this process in the following visualization.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="radixLinkAV"
    long_name="radixLinkAV"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>In this example, we have <math>r=10</math> bins and key values in
the range 0 to <math>r^2-1</math>.
The total computation is <math>\Theta(n)</math>, because we look at each
record and each bin a constant number of times.
This is a great improvement over the simple Binsort where the number
of bins must be as large as the key range.
Note that the example uses <math>r = 10</math> so as
to make the bin computations easy to visualize:
Records were placed into bins based on the value of first the
rightmost and then the leftmost decimal digits.
Any number of bins would have worked if we interpret the key values in
terms of the corresponding base.
This is an example of a <title_reference>Radix Sort</title_reference>, so called because the
bin computations are based on the <title_reference>radix</title_reference> or the
<title_reference>base</title_reference> of the key values.
This sorting algorithm can be extended to any number of
keys in any key range.
We simply assign records to bins based on the
keys' digit values working from the rightmost digit to the leftmost.
If there are <math>k</math> digits, then this requires that we assign keys to
bins <math>k</math> times.</paragraph><paragraph>Here is a practice exercise for placing keys into bins.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RadixsortPRO"
    long_name="RadixsortPRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="array-based-radix-sort" names="array-based\ radix\ sort"><title>Array-based Radix Sort</title><paragraph>As with Mergesort, an efficient implementation of Radix Sort is
somewhat difficult to achieve.
In particular, we would prefer to sort an array of values and avoid
processing linked lists.
If we knew how  many values would be in each bin, then an auxiliary
array of size <math>r</math> can be used to define these lengths and guide
us to were each one starts in the output array.
For example, if during the first pass the 0 bin will receive three
records and the 1 bin will receive five records, then we could simply
reserve the first three array positions for the 0 bin and the next
five array positions for the 1 bin.
Exactly this approach is taken by the following implementation.
At the end of each pass, the records are copied back to the original
array.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>The first inner <literal>for</literal> loop initializes array <literal>cnt</literal>.
The second loop counts the number of records to be assigned to each
bin.
The third loop sets the values in <literal>cnt</literal> to their proper
indices within array <literal>B</literal>.
Note that the index stored in <literal>cnt[j]</literal>
is the <emphasis>last</emphasis> index for bin <literal>j</literal>; bins are filled
from high index to low index.
The fourth loop assigns the records to the bins (within
array <literal>B</literal>).
The final loop simply copies the records back to
array <literal>A</literal> to be ready for the next pass.
Variable <literal>rtoi</literal> stores <math>r^i</math> for use in bin computation
on the <math>i</math>'th iteration.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="radixArrayAV"
    long_name="radixArrayAV"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><section ids="radix-sort-analysis" names="radix\ sort\ analysis"><title>Radix Sort Analysis</title><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="RadixSortAnalysisCON"
    long_name="RadixSortAnalysisCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph><strong>Is it really a reasonable assumption to treat</strong> <math>k</math> <strong>as a
constant?</strong>
Or is there some relationship between <math>k</math> and <math>n</math>?
If the key range is limited and duplicate key values are common,
there might be no relationship between <math>k</math> and <math>n</math>.
To make this distinction more clear, use <math>N</math> to denote the
number of distinct key values used by the <math>n</math> records.
Thus, <math>N \leq n</math>.
Because it takes a minimum of <math>\log_r N</math> base <math>r</math> digits
to represent <math>N</math> distinct key values, we know that
<math>k \geq \log_r N</math>.</paragraph><paragraph>Now, consider the situation in which no keys are duplicated.
If there are <math>n</math> unique keys then <math>n = N</math>.
It would require <math>n</math> distinct values to represent them.
So now it takes a minimum of <math>\log_r n</math> base <math>r</math> digits to
represent the <math>n</math> distinct key values.
This means that <math>k \geq \log_r n</math>.
Because it requires <emphasis>at least</emphasis> <math>\log n</math> digits
to distinguish between the <math>n</math> distinct keys
(within a constant factor  meaning, the number of digits is
<math>\Omega(\log n)</math>),
<math>k</math> is in <math>\Omega(\log n)</math>.
<strong>This means that Radix Sort requires</strong>
<math>\Omega(n \log n)</math>
<strong>time to process</strong> <math>n</math> <strong>distinct key values.</strong></paragraph><paragraph>Of course the key range could be much bigger
<math>\log_r n</math> bits is merely the best case possible for <math>n</math>
distinct values.
Thus, the <math>\log_r n</math> estimate for <math>k</math> could be overly
optimistic.
The bottom line of this analysis is that, for the general case of
<math>n</math> distinct key values, Radix Sort is at best a
<math>\Omega(n \log n)</math> sorting algorithm.</paragraph><paragraph>Radix Sort's running time can be much improved (by a constant factor)
if we make base <math>r</math> be as large as possible.
This is simplest if we think about integer key values.
Set <math>r = 2^i</math> for some <math>i</math>.
In other words, the value of <math>r</math> is related to the
number of bits of the key processed on each pass.
Each time the number of bits is doubled, the number of passes is cut
in half.
When processing an integer key value, setting <math>r = 256</math> allows
the key to be processed one byte at a time.
Processing a 32-bit integer key requires only four passes.
It is not unreasonable on most computers to use
<math>r = 2^{16} = 64\mbox{K}</math>, resulting in only two passes for a
32-bit key.
Of course, this requires a <literal>cnt</literal> array of size 64K.
Performance will be good
only if the number of records is about 64K or greater.
In other words, the number of records must be large compared to the
key size for Radix Sort to be efficient.
In many sorting applications, Radix Sort can be tuned in this way to
give better performance.</paragraph><paragraph>Radix Sort depends on the ability to make a fixed number of multiway
choices based on a digit value, as well as random access to the bins.
Thus, Radix Sort might be difficult to implement for certain key
types.
For example, if the keys are real numbers or arbitrary length strings,
then some care will be necessary in implementation.
In particular, Radix Sort will need to be careful about deciding when
the "last digit" has been found to distinguish among real numbers,
or the last character in variable length strings.
Implementing the concept of Radix Sort with the
<title_reference>alphabet trie &lt;alphabet trie&gt; &lt;Trie&gt;</title_reference> data structure is most
appropriate for these situations.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RadixSortSumm"
    long_name="RadixSortSumm"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Development/RadixSortAnalysisCON.js</odsascript></raw></section></section></document>