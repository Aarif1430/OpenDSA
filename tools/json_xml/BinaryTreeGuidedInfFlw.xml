<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="binary\ tree\ guided\ information\ flow" ids="binary-tree-guided-information-flow" source="&lt;string&gt;" title="Binary Tree Guided Information Flow"><title>Binary Tree Guided Information Flow</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><section dupnames="binary\ tree\ guided\ information\ flow" ids="id1"><title>Binary Tree Guided Information Flow</title><paragraph>When writing a recursive method to solve a problem that requires
traversing a binary tree, we want to make sure that we are visiting
the required nodes (no more and no less).</paragraph><paragraph>So far, we have seen several tree traversals that visited every node
of the tree.
We also saw the BST search, insert, and remove routines, that each go
down a single path of the tree.
<title_reference>Guided traversal</title_reference> refers to a problem that does not require
visiting every node in the tree, though it typically requires looking
at more than one path through the tree.
This means that the recursive function is making some decision at each
node that sometimes lets it avoid visiting one or both of its
children.
The decision is typically based on the value of the current node.
Many problems that require information flow on binary search
trees are "guided" in this way.</paragraph><topic><title>Example:</title><paragraph>An extreme example is finding the minimum value in a BST.
A bad solution to this problem would visit every node of the tree.
However, we can take advantage of the BST property to
avoid visiting most nods in the tree.
You know that the values greater than the root are always in the right
subtree, and those values less than the root are in the left subtree.
Thus, at each node we need only visit the left subtree until we reach
a leaf node.</paragraph></topic><paragraph>Here is a problem that typically needs to visit more
than just a single path, but not all of the nodes.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="IneffBinaryTreeRangeCON"
    long_name="IneffBinaryTreeRangeCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></section><section ids="binary-search-tree-small-count-exercise" names="binary\ search\ tree\ small\ count\ exercise"><title>Binary Search Tree Small Count Exercise</title><raw format="xml" xml:space="preserve"><extertool
    resource_name='Binary Search Tree Small Count Exercise'
    resource_type="external_assignment"
    learning_tool="code-workout"
    points="2.0">
</extertool>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/BTRecurTutor/IneffBinaryTreeRangeCON.js</odsascript></raw></section></document>