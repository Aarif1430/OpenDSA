{"document": {"@ids": "basic-pointers", "@names": "basic\\ pointers", "@source": "<string>", "@title": "Basic Pointers", "title": "Basic Pointers", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@ids": "what-is-a-pointer", "@names": "what\\ is\\ a\\ pointer?", "title": "What is a pointer?", "paragraph": ["There's a lot of nice, tidy code you can write without knowing about pointers. But once\nyou learn to use the power of pointers, you can never go back. There are too many things\nthat can only be done with pointers. But with increased power comes increased\nresponsibility. Pointers allow new and more ugly types of bugs, and pointer bugs can\ncrash in random ways which makes them more difficult to debug. Nonetheless, even with\ntheir problems, pointers are an irresistibly powerful programming construct. (The\nfollowing explanation uses the C language syntax where a syntax is required; there is a\ndiscussion of Java at the section.)", "Pointers solve two common software problems. First, pointers allow different sections of\ncode to share information easily. You can get the same effect by copying information\nback and forth, but pointers solve the problem better. Second, pointers enable complex\nlinked data structures like linked lists and binary trees.", {"literal": ["int", "float", "int", "int"], "#text": "Simple  and  variables operate pretty intuitively. An\n variable is like a box which can store a single  value such\nas 42. In a drawing, a simple variable is a box with its current value\ndrawn inside."}, {"title_reference": ["reference", "pointee"], "#text": "A pointer works a little differently, it does not store\na simple value directly. Instead, a pointer stores a  to another value.\nThe variable the pointer refers to is sometimes known as its .\nIn a drawing, a pointer is a box which contains the beginning of an arrow which leads\nto its pointee. (There is no single, official, word for\nthe concept of a pointee  pointee is just the word used in these\nexplanations.)"}, {"literal": ["num", "numPtr", "num", "numPtr", "num", "numPtr", "int", "int"], "#text": "The following drawing shows two variables:  and . The simple variable \ncontains the value 42 in the usual way. The variable numPtr is a pointer which contains\na reference to the variable num. The  variable is the pointer and  is its\npointee. What is stored inside of ? Its value is not an . Its value is a\nreference to an ."}], "target": [{"@refid": "num42fig"}, {"@refid": "numnumptrfig"}], "raw": [{"@format": "xml", "@ids": "num42fig", "@names": "num42fig", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "numnumptrfig", "@names": "numnumptrfig", "@xml:space": "preserve", "odsafig": "null"}]}, {"@ids": "pointer-reference-and-dereference", "@names": "pointer\\ reference\\ and\\ dereference", "title": "Pointer Reference and Dereference", "paragraph": [{"title_reference": "dereference", "literal": "numPtr", "#text": "The  operation follows a pointer's reference to get\nthe value of its pointee.\nThe value of the dereference of  above is 42. When the dereference operation is\nused correctly, it's simple. It just accesses the value of the pointee. The only restriction is\nthat the pointer must have a pointee for the dereference to access. Almost all bugs in\npointer code involve violating that one restriction. A pointer must be assigned a pointee\nbefore dereference operations will work."}, "The constant NULL is a special pointer value which encodes the idea of\n\"points to nothing\".\nIt turns out to be convenient to have a well defined pointer value\nwhich represents the idea that a pointer does not have a pointee.\nIt is a runtime error to dereference a NULL pointer.\nIn drawings, the value NULL is usually drawn as a diagonal\nline between the corners of the pointer variable's box.", "The C language uses the symbol NULL for this purpose.\nNULL is equal to the integer constant 0, so NULL can play the role of a boolean\nfalse. Official C++ no longer uses the NULL symbolic constant  use the integer constant 0 directly.\nJava uses the symbol null."], "target": {"@refid": "numptrnullfig"}, "raw": {"@format": "xml", "@ids": "numptrnullfig", "@names": "numptrnullfig", "@xml:space": "preserve", "odsafig": "null"}}, {"@ids": "pointer-assignment", "@names": "pointer\\ assignment", "title": "Pointer Assignment", "paragraph": [{"literal": ["=", "second", "second = numPtr;", "num"], "#text": "The assignment operation () between two pointers makes them point to the same\npointee. It's a simple rule for a potentially complex situation, so it is worth repeating:\nassigning one pointer to another makes them point to the same thing. The example below\nadds a second pointer, , assigned with the statement .\nThe result is that second points to the same pointee as numPtr. In the drawing, this\nmeans that the second and numPtr boxes both contain arrows pointing to .\nAssignment between pointers does not change or even touch the pointees. It just changes\nwhich pointee a pointer refers to."}, {"literal": ["==", "(second==numPtr)"], "#text": "After assignment, the  test comparing the two pointers will return true. For example\n above is true. The assignment operation also works with the\nNULL value. An assignment operation with a NULL pointer copies the NULL value\nfrom one pointer to another."}, "Memory drawings are the key to thinking about pointer code.\nWhen you are looking at code, thinking about how it will use memory at\nrun time, then make a quick drawing to work out your ideas.\nThis tutorial certainly uses drawings to show how pointers work.\nThat's the way to do it."], "target": {"@refid": "numptrsecondlfig"}, "raw": {"@format": "xml", "@ids": "numptrsecondlfig", "@names": "numptrsecondlfig", "@xml:space": "preserve", "odsafig": "null"}, "section": [{"@ids": "sharing", "@names": "sharing", "title": "Sharing", "paragraph": "Two pointers which both refer to a single pointee are said to be\n\"sharing\".\nThat two or more entities can cooperatively share a single memory\nstructure is a key advantage of pointers in all computer\nlanguages.\nPointer manipulation is just technique  sharing is\noften the real goal.\nLater we will see how sharing can be used to provide efficient\ncommunication between parts of a program."}, {"@ids": "shallow-and-deep-copying", "@names": "shallow\\ and\\ deep\\ copying", "title": "Shallow and Deep Copying", "paragraph": [{"title_reference": ["shallow copy", "deep copy"], "#text": "In particular, sharing can enable communication between two functions. One function\npasses a pointer to the value of interest to another function. Both functions can access the\nvalue of interest, but the value of interest itself is not copied.\nThis communication is called  since instead of\nmaking and sending a (large) copy of the value of\ninterest, a (small) pointer is sent and the value of interest is shared. The recipient needs to\nunderstand that they have a shallow copy, so they know not to change or delete it since it\nis shared. The alternative where a complete copy is made and sent is\nknown as a .\nDeep copies are simpler in a way, since each function can change their copy\nwithout interfering with the other copy, but deep copies run slower because of all the\ncopying.\nThe drawing below shows shallow and deep copying between two functions, A() and B().\nIn the shallow case, the smiley face is shared by passing a pointer between the two. In the\ndeep case, the smiley face is copied, and each function gets their own."}, "The next module will explain the above sharing technique in detail."], "target": {"@refid": "shallowdeepfig"}, "raw": {"@format": "xml", "@ids": "shallowdeepfig", "@names": "shallowdeepfig", "@xml:space": "preserve", "odsafig": "null"}}]}, {"@ids": "bad-pointers", "@names": "bad\\ pointers", "title": "Bad Pointers", "paragraph": [{"title_reference": "uninitialized", "#text": "When a pointer is first allocated, it does not have a pointee.\nThe pointer is  or simply \"bad\".\nA dereference operation on a bad pointer is a serious runtime error.\nIf you are lucky, the dereference operation will crash or halt\nimmediately (Java behaves this way).\nIf you are unlucky, the bad pointer dereference will corrupt a random\narea of memory, slightly altering the operation of the program so that\nit goes wrong some indefinite time later.\nEach pointer must be assigned a pointee before it can support\ndereference operations. Before that, the pointer is bad and must not\nbe used.\nIn our memory drawings, the bad pointer value is shown with an XXX\nvalue."}, {"strong": "every pointer starts out with a bad value", "#text": "Bad pointers are very common. In fact,  .\nCorrect code overwrites the bad value with a correct reference to a pointee, and thereafter\nthe pointer works fine. There is nothing automatic that gives a pointer a valid pointee."}, "Quite the opposite  most languages make it easy to omit this important step. You just\nhave to program carefully. If your code is crashing, a bad pointer should be your first\nsuspicion.\nPointers in dynamic languages such as Perl, LISP, and Java work a little differently. The\nrun-time system sets each pointer to NULL when it is allocated and checks it each time it\nis dereferenced. So code can still exhibit pointer bugs, but they will halt politely on the\noffending line instead of crashing haphazardly like C. As a result, it is much easier to\nlocate and fix pointer bugs in dynamic languages. The run-time checks are also a reason\nwhy such languages always run at least a little slower than a compiled language like C or\nC++.", {"strong": "both", "#text": "One way to think about pointer code is that operates at two levels  pointer level and\npointee level. The trick is that  levels need to be initialized and connected for things\nto work. (1) the pointer must be allocated, (1) the pointee must be allocated, and (3) the\npointer must be assigned to point to the pointee. It's rare to forget step (1). But forget (2)\nor (3), and the whole thing will blow up at the first dereference. Remember to account for\nboth levels  make a memory drawing during your design to make sure it's right."}], "target": {"@refid": "numptrxxxfig"}, "raw": {"@format": "xml", "@ids": "numptrxxxfig", "@names": "numptrxxxfig", "@xml:space": "preserve", "odsafig": "null"}}, {"@ids": "syntax", "@names": "syntax", "title": "Syntax", "paragraph": "The above basic features of pointers, pointees, dereferencing, and\nassigning are the only concepts you need to build pointer code.\nHowever, in order to talk about pointer code, we need to use a known\nsyntax which is about as interesting as... a syntax.\nWe will use the Java language syntax which has the advantage that it\nhas influenced the syntaxes of several languages.", "section": [{"@ids": "pointer-type-syntax", "@names": "pointer\\ type\\ syntax", "title": "Pointer Type Syntax", "paragraph": ["A pointer type in C is just the pointee type followed by an asterisk (*).", {"literal": ["int*", "int"], "#text": "type: pointer to"}, {"literal": ["float*", "float"], "#text": "type: pointer to"}, {"literal": ["struct fraction*", "struct fraction"], "#text": "type: pointer to"}, {"literal": ["struct fraction**", "pointer to struct fraction*"], "#text": "type:"}]}, {"@ids": "pointer-variables", "@names": "pointer\\ variables", "title": "Pointer Variables", "paragraph": "Pointer variables are declared just like any other variable.\nThe declaration gives the type and name of the new variable and\nreserves memory to hold its value.\nThe declaration does not assign a pointee for the pointer  the\npointer starts out with a bad value.", "literal_block": {"@xml:space": "preserve", "#text": "int* numPtr; // Declare the int* (pointer to int) variable numPtr.\n             // This allocates space for the pointer, but not the pointee.\n             // The pointer starts out \"bad\""}}, {"@ids": "the-operator-reference-to", "@names": "the\\ &\\ operator\\ reference\\ to", "title": "The & Operator  Reference To", "paragraph": [{"literal": "num/numPtr", "#text": "There are several ways to compute a reference to a pointee suitable\nfor storing in a pointer.\nThe simplest way is the & operator.\nThe & operator can go to the left of any variable,\nand it computes a reference to that variable.\nThe code below uses a pointer and\nan & to produce the earlier  example."}, "It is possible to use & in a way which compiles fine but which creates\nproblems at run time.\nThe full discussion of how to correctly use & is in the next module.\nFor now we will just use & in a simple way."], "raw": {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}, "literal_block": {"@xml:space": "preserve", "#text": "void NumPtrExample() {\n  int num;\n  int* numPtr;\n  num = 42;\n  numPtr = &num;\n  // Compute a reference to num, and store it in numPtr\n  // At this point, memory looks like drawing above\n }"}}, {"@ids": "the-operator-dereference", "@names": "the\\ *\\ operator\\ dereference", "title": "The * Operator  Dereference", "paragraph": "The star operator (*) dereferences a pointer.\nThe * is a unary operator which goes to the left of the pointer\nit dereferences. The pointer must have a pointee, or it's a runtime error."}]}, {"@ids": "example-pointer-code", "@names": "example\\ pointer\\ code", "title": "Example Pointer Code", "paragraph": "With the syntax defined, we can now write some pointer code that\ndemonstrates all the pointer rules.", "literal_block": [{"@xml:space": "preserve", "#text": "void PointerTest() {\n  // allocate three integers and two pointers\n  int a = 1;\n  int b = 2;\n  int c = 3;\n  int* p;\n  int* q;\n  // Here is the state of memory at this point.\n  // T1 -- Notice that the pointers start out bad."}, {"@xml:space": "preserve", "#text": "p = &a;\n// set p to refer to a\nq = &b;\n// set q to refer to b\n// T2 -- The pointers now have pointees"}, {"@xml:space": "preserve", "#text": "// Now we mix things up a bit\nc = *p;\n// retrieve p's pointee value (1) and put it in c\np = q;\n// change p to share with q (p's pointee is now b)\n*p = 13;\n// dereference p to set its pointee (b) to 13 (*q is now 13)\n// T3 -- Dereferences and assignments mix things up"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}], "section": {"@ids": "bad-pointer-example", "@names": "bad\\ pointer\\ example", "title": "Bad Pointer Example", "paragraph": {"strong": "look", "#text": "Code with the most common sort of pointer bug will  like the\nabove correct code, but without the middle step where the pointers are\nassigned pointees.\nThe bad code will compile fine, but at run-time, each dereference with\na bad pointer will corrupt memory in some way.\nThe program will crash sooner or later.\nIt is up to the programmer to ensure that each pointer is assigned a\npointee before it is used.\nThe following example shows a simple example of the bad code and a\ndrawing of how memory is likely to react."}, "literal_block": {"@xml:space": "preserve", "#text": "void BadPointer() {\n  int* p;\n  // allocate the pointer, but not the pointee\n  *p = 42;\n  // this dereference is a serious runtime error\n }\n// What happens at runtime when the bad pointer is dereferenced?"}, "raw": {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}}}, {"@ids": "pointer-rules-summary", "@names": "pointer\\ rules\\ summary", "title": "Pointer Rules Summary", "paragraph": "No matter how complex a pointer structure gets, the list of rules remains short.", "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "A pointer stores a reference to its pointee. The pointee, in turn,\nstores something useful."}, {"paragraph": "The dereference operation on a pointer accesses its pointee. A\npointer may only be dereferenced after it has been assigned to refer\nto a pointee. Most pointer bugs involve violating this one rule."}, {"paragraph": "Allocating a pointer does not automatically assign it to refer to a\npointee. Assigning the pointer to refer to a specific pointee is a\nseparate operation which is easy to forget."}, {"paragraph": "Assignment between two pointers makes them refer to the same pointee\nwhich introduces sharing."}]}}, {"@ids": "how-do-pointers-work-in-java", "@names": "how\\ do\\ pointers\\ work\\ in\\ java?", "title": "How Do Pointers Work In Java?", "paragraph": [{"literal": ["*", "&", "int", "char", "a=b;", "*", "&"], "#text": "Java has pointers, but they are not manipulated with explicit operators such as  and .\nIn Java, simple data types such as  and  operate just as in C. More complex types\nsuch as arrays and objects are automatically implemented using pointers. The language\nautomatically uses pointers behind the scenes for such complex types, and no pointer\nspecific syntax is required. The programmer just needs to realize that operations like\n will automatically be implemented with pointers if a and b are arrays or objects. Or\nput another way, the programmer needs to remember that assignments and parameters\nwith arrays and objects are intrinsically shallow or shared  see the Deep vs. Shallow\nmaterial above. The following code shows some Java object references. Notice that there\nare no 's or 's in the code to create pointers. The code\nintrinsically uses pointers.\nAlso, the garbage collector takes care of the deallocation\nautomatically at the end of the function."}, "The Java approach has two main features."], "literal_block": {"@xml:space": "preserve", "#text": "public void JavaShallow() {\n  Foo a = new Foo();\n  // Create a Foo object (no * in the declaration)\n  Foo b = new Foo();\n  // Create another Foo object\n  b=a;\n  // This is automatically a shallow assignment --\n  // a and b now refer to the same object.\n  a.Bar();\n  // This could just as well be written b.Bar();\n  // There is no memory leak here -- the garbage collector\n  // will automatically recycle the memory for the two objects.\n}"}, "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "Fewer bugs. Because the language implements the pointer manipulation\naccurately and automatically, the most common pointer bug  are no\nlonger possible, Yay! Also, the Java runtime system checks each\npointer value every time it is used,  so NULL pointer dereferences\nare caught immediately on the line where they occur. This can make a\nprogrammer much more productive."}, {"paragraph": "Slower. Because the language takes responsibility for implementing\nso much pointer machinery at runtime, Java code runs slower than the\nequivalent C code. (There are other reasons for Java to run slowly\nas well. There is active research in making Java faser in\ninteresting ways  the Sun \"Hot Spot\" project.) In any case, the\nappeal of increased programmer efficiency and fewer bugs makes the\nslowness worthwhile for some  applications."}]}}, {"@ids": "how-are-pointers-implemented-in-the-machine", "@names": "how\\ are\\ pointers\\ implemented\\ in\\ the\\ machine?", "title": "How Are Pointers Implemented In The Machine?", "paragraph": {"literal": ["int", "int"], "#text": "How are pointers implemented?\nThe short explanation is that every area of memory in the\nmachine has a numeric address like 1000 or 20452.\nA pointer to an area of memory is really just an integer which is\nstoring the address of that area of memory. The dereference\noperation looks at the address, and goes to that area of memory to retrieve the pointee\nstored there. Pointer assignment just copies the numeric address from one pointer to\nanother. The NULL value is generally just the numeric address 0  the computer just\nnever allocates a pointee at 0 so that address can be used to represent NULL. A bad\npointer is really just a pointer which contains a random address  just like an\nuninitialized  variable which starts out with a random  value. The pointer has not\nyet been assigned the specific address of a valid pointee. This is why dereference operations with bad pointers are so unpredictable. They operate on whatever random area\nof memory they happen to have the address of."}}, {"@ids": "the-term-reference", "@names": "the\\ term\\ 'reference'", "title": "The Term 'Reference'", "paragraph": {"title_reference": ["reference", "reference parameter"], "#text": "The word  means almost the same thing as the word\n\"pointer\".\nThe difference is that \"reference\" tends to be used in a discussion of\npointer issues which is not specific to any particular language or\nimplementation.\nThe word \"pointer\" connotes the common C/C++ implementation of\npointers as addresses.\nThe word \"reference\" is also used in the phrase\n\nwhich is a technique that uses pointer parameters for two-way\ncommunication between functions.\nThis technique is the subject of a later module."}}, {"@ids": "why-are-bad-pointer-bugs-so-common", "@names": "why\\ are\\ bad\\ pointer\\ bugs\\ so\\ common?", "title": "Why Are Bad Pointer Bugs So Common?", "paragraph": {"literal": ["int", "int", "char"], "#text": "Why is it so often the case that programmers will allocate a pointer,\nbut forget to set it to refer to a pointee?\nThe rules for pointers don't seem that complex, yet every programmer\nmakes this error repeatedly.\nWhy?\nThe problem is that we are trained by the tools we use.\nSimple variables don't require any extra setup.\nYou can allocate a simple variable, such as \n, and use it immediately. All that , , struct fraction code you have written has trained you, quite reasonably,\nthat a variable may be used once it is declared. Unfortunately, pointers look like simple variables but they require the extra initialization\nbefore use. It's unfortunate, in a way, that pointers happen look like other variables, since\nit makes it easy to forget that the rules for their use are very different. Oh well. Try to\nremember to assign your pointers to refer to pointees. Don't be surprised when you forget."}}]}}