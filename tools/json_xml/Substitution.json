{"document": {"@ids": "the-substitution-based-model-of-evaluation", "@names": "the\\ substitution-based\\ model\\ of\\ evaluation", "@source": "<string>", "@title": "The Substitution-Based Model of Evaluation", "title": "The Substitution-Based Model of Evaluation", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/PL/main.css"}], "section": [{"@ids": "substitution-algorithm", "@names": "substitution\\ algorithm", "title": "Substitution Algorithm", "paragraph": [{"title_reference": ["semantics-of-the-lambda-calculus", "free-and-bound-variables", "alpha-conversion"], "#text": "In this section, we continue our investigation of the semantics of the\nlambda calculus. Now that we understand the meaning of each one of the\nthree types of lambda expressions (see\n), the meaning of free and\nbound variables (see ) and how bound\nvariables can be systematically renamed (see ),\nwe have all of the tools we need to explain the meaning of function\ncalls in the lambda calculus. Note that, since functions are the only\nentities in the lambda calculus, interpreting a lambda calculus\nprogram boils down to executing function calls."}, "First, consider how you would execute the following function call in\nyour head:", {"title_reference": "f", "#text": "You would first look up the definition of the function , say:"}, {"title_reference": ["f(8)", "f", "8", "x", "2*8 - 5 = 11"], "emphasis": "substitution-based model of interpretation", "#text": "Then you could compute the value of  by computing the\nvalue of the body of  after substituting  for\n in it, yielding . This intuitive\napproach to evaluating function calls naturally leads to a\n. In this section, we\ndiscuss a well-known algorithm for performing substitutions in the\nlambda calculus."}, {"title_reference": ["a", "p", "b", "a", "p", "b", "a", "p", "b"], "#text": "Since both the body of a function and the argument of a function call\ncan be arbitrary lambda expressions, we need an algorithm that can\nsubstitute any lambda expression  (the argument) for the\nvariable  (the parameter of the function) in the lambda\nexpression  (the body of the function). In this section, we\nforget about the interpretation of ,  and \nas components of a function call. Instead, we describe the algorithm\nin general terms, that is, as an algorithm to substitute  for\n in , which we denote by:"}, {"title_reference": ["a", "b", "p"], "#text": "where  and  are arbitrary lambda expressions and\n is any variable."}, {"title_reference": ["subst(a, p, b)", "a", "p", "b", "p", "a", "b", "b", "p", "b", "a", "b"], "#text": "Note that  means \"substitute  for\n in \" or equivalently, \"replace  by\n in . Whichever way you choose to phrase it,\n is always the expression inside which we are performing the\nsubstitution,  is always the expression that gets taken out\nof  and  is always the expression that gets\ninserted into ."}, {"title_reference": ["b", "lambda calculus <lambda calculus> <Semantics>", "b"], "#text": "Now, back to the substitution algorithm. Since  is an\narbitrary lambda expression, looking back at the BNF grammar for the\n,\nwe see that we must\nconsider three cases for , namely a variable, a lambda\nabstraction or an application expression. Therefore, our description\nof the algorithm is broken down into three numbered cases."}, {"strong": ["Case 1:", "Case 1a", "Case 1b"], "title_reference": ["b", "x", "subst(a, p, b)", "subst(a, p,x)", "p", "x", "p", "x", "v", "subst(a,p,x)", "subst(a,v,v)", "a", "v", "a", "p", "x", "subst(a,p,x)", "x", "p", "x"], "#text": "If  is a variable, say , then\n becomes . Recall that\n and  are generic variables. So we need to\ndistinguish two subcases. First, if  and  are the\nsame variable, say , then  is really\n, whose value is , because that is what\nwe get when we replace  by . We call this part of the\nalgorithm . Second, if  and  are two\ndifferent variables, then  is equal to ,\nbecause the variable  does not occur in  and no\nsubstitutions are needed or possible. We call this part of the\nalgorithm"}, {"title_reference": ["subst(lambda x.x, u, v)", "v", "u", "v", "subst(lambda y.(yx), u, u)", "p", "b", "u", "lambda y.(yx)"], "#text": "Let's look at two examples of substitutions that belong to\nCase 1. First, in ,  is a\nvariable that is different from . Therefore, this example\nmatches Case 1b, and the output of the algorithm is . On the\nother hand,  falls into Case 1a,\nsince both  and  are equal to the same variable\n. So, the algorithm returns ."}, {"strong": "Case 2:", "#text": "To be completed"}, {"strong": "Case 3:", "title_reference": ["b", "(e_1e_2)", "e_1", "e_2", "subst(a,p,b)", "subst(a,p,(e_1e_2))", "(subst(a,p,e_1)subst(a,p,e_2))", "a", "p"], "#text": "If  is an application expression, say\n, where  and  are arbitrary\nlambda expressions, then the value of , really\n, is , that is, the application expression that is obtained\nby substituting  for  recursively in each component\nof the original application expression."}, {"title_reference": ["subst(lambda y.(yx), u, (lambda\nv.uu))", "lambda y.(yx)", "u", "(lambda v.lambda y.(yx)lambda y.(yx))"], "#text": "As an example, consider . Since the expression we are substituting into (i.e., the\nthird one) is an application expression, the algorithm requires us to\nreturn the application that results from recursively substituting\n for  in both components of this\napplication. Since we already performed these two substitutions in the\nexamples listed above, the final result of the algorithm is\n."}], "literal_block": [{"@classes": "code", "@xml:space": "preserve", "#text": "f(8)"}, {"@classes": "code", "@xml:space": "preserve", "#text": "var f = function(x) { return  2 * x - 5; };"}], "math_block": {"@xml:space": "preserve", "#text": "subst(a, p, b)"}, "comment": [{"@xml:space": "preserve", "#text": ".. inlineav:: substCase1b ss"}, {"@xml:space": "preserve", "#text": "show"}]}, {"@ids": "rp-15-part-2", "@names": "rp\\ 15\\ part\\ 2", "title": "RP 15 part 2", "paragraph": "The following exercise is good practice for identifying which case\napplies at each step of the substitution algorithm. To get credit for\nthis randomized problem, you must solve it correctly three times in\na row.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP15part2", "@long_name": "RP15part2", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "rp-15-part-3", "@names": "rp\\ 15\\ part\\ 3", "title": "RP 15 part 3", "paragraph": "The following exercise will test your ability to complete a full\nsubstitution by applying the algorithm scrupulously. To get credit for\nthis randomized problem, you must solve it correctly three times in\na row.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP15part3", "@long_name": "RP15part3", "@points": "1.0", "@required": "True", "@threshold": "5"}}, "comment": {"@xml:space": "preserve", "#text": ".. odsascript:: AV/PL/AV/substCase1b.js"}}]}}