{"document": {"@dupnames": "composite-based\\ expression\\ tree", "@ids": "composite-based-expression-tree", "@source": "<string>", "@title": "Composite-based Expression Tree", "title": "Composite-based Expression Tree", "subtitle": {"@dupnames": "composite-based\\ expression\\ tree", "@ids": "id1", "#text": "Composite-based Expression Tree"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}, {"@xml:space": "preserve", "#text": ".. inlineav:: compositeTraversalCON ss"}, {"@xml:space": "preserve", "#text": ":output: show"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Binary/BTCON.css"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/compositeTraversalCON.js"}], "paragraph": [{"title_reference": ["Composite design pattern", "procedural approach <procedural> <BinaryTreeImpl>"], "literal": ["traverse", "VarBinNode", "traverse", "traverse", "traverse"], "#text": "There is another approach that we can take to represent separate leaf\nand internal nodes, also using a virtual base class and separate node\nclasses for the two types.\nThis is to implement nodes using the .\nThis approach is noticeably different from the\n in that the\nnode classes themselves implement the functionality of .\nHere is the implementation.\nBase class  declares a member function\n that each subclass must implement.\nEach subclass then implements its own appropriate behavior for its\nrole in a traversal.\nThe whole traversal process is called by invoking \non the root node, which in turn invokes  on its\nchildren."}, {"title_reference": ["procedural approach <procedural> <BinaryTreeImpl>", "Flyweight <Flyweight> <DesignPatterns>"], "literal": ["traverse", "traverse", "traverse", "traverse", "traverse"], "#text": "When comparing the composite implementation to\nthe ,\neach has advantages and disadvantages.\nThe non-composite approach does not require that the node classes know\nabout the  function.\nWith this approach, it is easy to add new methods to the tree class\nthat do other traversals or other operations on nodes of the tree.\nHowever, we see that  in\nthe non-composite approach does\nneed to be familiar with each node subclass.\nAdding a new node subclass would therefore require modifications to\nthe  function.\nIn contrast, the composite approach requires that any new operation on\nthe tree that requires a traversal also be implemented in the node\nsubclasses.\nOn the other hand, the composite approach\navoids the need for the  function to know\nanything about the distinct abilities of the node subclasses.\nThose subclasses handle the responsibility of performing a traversal\non themselves.\nA secondary benefit is that there is no need for  to\nexplicitly enumerate all of the different node subclasses,\ndirecting appropriate action for each.\nWith only two node classes this is a minor point.\nBut if there were many such subclasses, this could become a bigger\nproblem.\nA disadvantage is that the traversal operation must not be called on a\nNULL pointer, because there is no object to catch the call.\nThis problem could be avoided by using a\n\nto implement empty nodes."}, {"literal": "traverse", "#text": "Typically, the non-composite version would be\npreferred in this example if  is a member function of\nthe tree class, and if the node subclasses are hidden from users of\nthat tree class.\nOn the other hand, if the nodes are objects that have meaning\nto users of the tree separate from their existence as nodes in the\ntree, then the composite version might be preferred because hiding the\ninternal behavior of the nodes becomes more important."}, "Another advantage of the composite design is that implementing each\nnode type's functionality might be easier.\nThis is because you can focus solely on the information passing and\nother behavior needed by this node type to do its job.\nThis breaks down the complexity that many programmers feel overwhelmed\nby when dealing with complex information flows related to recursive\nprocessing."]}}