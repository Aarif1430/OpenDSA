{"document": {"@ids": "the-splay-tree", "@names": "the\\ splay\\ tree", "@source": "<string>", "@title": "The Splay Tree", "title": "The Splay Tree", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@ids": "singprom", "@names": "singprom", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "zigzag", "@names": "zigzag", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "zigzig", "@names": "zigzig", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "splayex", "@names": "splayex", "@xml:space": "preserve", "odsafig": "null"}], "paragraph": [{"title_reference": ["m", "O(m log n)", "n", "m geq n", "O(n)", "m", "O(m log n)", "O(log n)"], "#text": "Like the AVL tree, the splay tree is not actually a distinct data\nstructure, but rather reimplements the BST insert, delete, and search\nmethods to improve the performance of a BST.\nThe goal of these revised methods is to provide guarantees on the time\nrequired by a series of operations, thereby avoiding the worst-case\nlinear time behavior of standard BST operations.\nNo single operation in the splay tree is guaranteed to be efficient.\nInstead, the splay tree access rules guarantee that a series of\n operations will take  time for a tree of\n nodes whenever .\nThus, a single insert or search operation could take \ntime.\nHowever,  such operations are guaranteed to require a total\nof  time, for an average cost of\n per access operation.\nThis is a desirable performance guarantee for any search-tree\nstructure."}, "Unlike the AVL tree, the splay\ntree is not guaranteed to be height balanced.\nWhat is guaranteed is that the total cost of the entire series of\naccesses will be cheap.\nUltimately, it is the cost of the series of operations that matters,\nnot whether the tree is balanced.\nMaintaining balance is really done only for the sake of reaching this\ntime efficiency goal.", {"title_reference": ["move-to-front", "self-organizing lists <self-organizing list> <SelfOrg>", "Union/Find <Union/Find> <UnionFind>"], "#text": "The splay tree access functions operate in a manner reminiscent of\nthe  rule for\n,\nand of the path compression technique for managing\na series of\n operations.\nThese access functions tend to make the tree more balanced, but an\nindividual access will not necessarily result in a more balanced\ntree."}, {"title_reference": ["S", "S", "splaying", "S", "S", "S", "S", "rotations <rotation>", "S"], "#text": "Whenever a node  is accessed (e.g., when  is\ninserted, deleted, or is the goal of a search), the splay tree\nperforms a process called .\nSplaying moves  to the root of the BST.\nWhen  is being deleted, splaying\nmoves the parent of  to the root.\nAs in the AVL tree, a splay of node \nconsists of a series of .\nA rotation moves  higher in the tree by adjusting its\nposition with respect to its parent and grandparent.\nA side effect of the rotations is a tendency to balance the tree.\nThere are three types of rotation."}, {"title_reference": ["single rotation", "S", "Figure #SingProm", "S", "Figure #SingProm", "Figure #AVLsingle"], "#text": "A  is performed only if \nis a child of the root node.\nThe single rotation is illustrated by Figure .\nIt basically switches  with its parent in a way that\nretains the BST property.\nWhile Figure  is slightly different from\nFigure , in fact the splay tree single\nrotation is identical to the AVL tree single rotation."}, {"title_reference": ["S", "P", "S", "G", "S"], "#text": "Unlike the AVL tree, the splay tree requires two types of\ndouble rotation.\nDouble rotations involve , its parent (call it ),\nand  's grandparent (call it ).\nThe effect of a double rotation is to move  up two levels in\nthe tree."}, {"title_reference": "zigzag rotation", "#text": "The first double rotation is called a .\nIt takes place when either of the following two conditions are met:"}, {"title_reference": ["G", "P", "S", "Figure #ZigZag"], "#text": "In other words, a zigzag rotation is used when ,\n, and  form a zigzag.\nThe zigzag rotation is illustrated by Figure ."}, {"title_reference": "zigzig", "#text": "The other double rotation is known as a  rotation.\nA zigzig rotation takes place when either of the following two\nconditions are met:"}, {"title_reference": ["Figure #ZigZig", "Figure #ZigZig", "Figure #AVLdouble"], "#text": "Thus, a zigzig rotation takes place in those\nsituations where a zigzag rotation is not appropriate.\nThe zigzig rotation is illustrated by Figure .\nWhile Figure  appears somewhat different from\nFigure , in fact the zigzig rotation is\nidentical to the AVL tree double rotation."}, {"title_reference": ["B", "C", "D"], "#text": "Note that zigzag rotations tend to make the tree more balanced,\nbecause they bring subtrees   and  up one level\nwhile moving subtree  down one level.\nThe result is often a reduction of the tree's height by one.\nZigzig promotions and single rotations do not typically reduce the\nheight of the tree; they merely bring the newly accessed record toward\nthe root."}, {"title_reference": ["S", "S", "S", "O(m log n)"], "#text": "Splaying node  involves a series of double rotations until\n reaches either the root or the child of the root.\nThen, if necessary, a single rotation makes  the root.\nThis process tends to re-balance the tree.\nRegardless of balance, splaying will make frequently accessed nodes\nstay near the top of the tree, resulting in reduced access cost.\nProof that the splay tree meets the guarantee of\n is beyond the scope of our study."}], "target": [{"@refid": "singprom"}, {"@refid": "zigzag"}, {"@refid": "zigzig"}, {"@refid": "splayex"}], "enumerated_list": [{"@enumtype": "arabic", "@prefix": "(", "@suffix": ")", "list_item": [{"paragraph": {"title_reference": ["S", "P", "P", "G"], "#text": "is the left child of , and  is the\nright child of ."}}, {"paragraph": {"title_reference": ["S", "P", "P", "G"], "#text": "is the right child of , and  is the\nleft child of ."}}]}, {"@enumtype": "arabic", "@prefix": "(", "@suffix": ")", "list_item": [{"paragraph": {"title_reference": ["S", "P", "G"], "#text": "is the left child of , which is in turn the\nleft child of ."}}, {"paragraph": {"title_reference": ["S", "P", "G"], "#text": "is the right child of , which is in turn the\nright child of ."}}]}], "topic": {"title": "Example", "paragraph": {"title_reference": ["Figure #SplayEx", "Figure #SplayEx", "Figure #SplayEx", "Figure #SplayEx"], "#text": "Consider a search for value 89 in the splay tree of\nFigure  (a).\nThe splay tree's search operation is identical to searching in\na BST.\nHowever, once the value has been found, it is splayed to the root.\nThree rotations are required in this example.\nThe first is a zigzig rotation, whose result is shown in\nFigure  (b).\nThe second is a zigzag rotation, whose result is shown in\nFigure  (c).\nThe final step is a single rotation resulting in the tree of\nFigure  (d).\nNotice that the splaying process has made the tree shallower."}}}}