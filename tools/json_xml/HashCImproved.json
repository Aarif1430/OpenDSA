{"document": {"@ids": "improved-collision-resolution", "@names": "improved\\ collision\\ resolution", "@source": "<string>", "@title": "Improved Collision Resolution", "title": "Improved Collision Resolution", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Hashing/collisionCON.css"}], "section": [{"@ids": "linear-probing-by-steps", "@names": "linear\\ probing\\ by\\ steps", "title": "Linear Probing by Steps", "paragraph": [{"title_reference": ["c", "textbf{p}(K, i) = ci", "i", "(textbf{h}(K) + ic) mod M"], "#text": "How can we avoid primary clustering?\nOne possible improvement might be to use linear probing,\nbut to skip slots by some constant  other than 1.\nThis would make the probe function\n,\nand so the  th slot in the probe sequence will be\n.\nIn this way, records with adjacent home positions will not follow the\nsame probe sequence."}, {"title_reference": ["c", "c = 2"], "#text": "One quality of a good probe sequence is that it will cycle through\nall slots in the hash table before returning to the home position.\nClearly linear probing (which \"skips\" slots by one each time) does this.\nUnfortunately, not all values for  will make this happen.\nFor example, if  and the table contains an even number of\nslots, then any key whose home position is in an even slot will have\na probe sequence that cycles through only the even slots.\nLikewise, the probe sequence for a key whose home position is in an\nodd slot will cycle through the odd slots.\nThus, this combination of table size and linear probing constant\neffectively divides the records into two sets stored in two\ndisjoint sections of the hash table.\nSo long as both sections of the table contain the same number of records,\nthis is not really important.\nHowever, just from chance it is likely that one section will become\nfuller than the other, leading to more collisions and poorer\nperformance for those records.\nThe other section would have fewer records, and thus better\nperformance.\nBut the overall system performance will be degraded,\nas the additional cost to the side that is more full outweighs the\nimproved performance of the less-full side."}, {"title_reference": ["c", "M", "c", "M", "M = 10", "c", "M = 11", "c"], "#text": "Constant  must be relatively prime to  to generate a\nlinear probing sequence that visits all slots in the table\n(that is,  and  must share no factors).\nFor a hash table of size , if \nis any one of 1, 3, 7, or 9,\nthen the probe sequence will visit all slots for any key.\nWhen , any value for  between 1 and 10 generates a\nprobe sequence that visits all slots for every key."}, "Now you can practice linear probing by different step sizes."], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "collisionCON1", "@long_name": "collisionCON1", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "collisionCON2", "@long_name": "collisionCON2", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "HashLinearStepPPRO", "@long_name": "HashLinearStepPPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "pseudo-random-probing", "@names": "pseudo-random\\ probing", "title": "Pseudo-Random Probing", "paragraph": [{"title_reference": ["c = 2", "k_1", "textbf{h}(k_1) = 3", "k_1", "k_2", "k_1", "k_2", "c > 1", "k_1", "k_2"], "#text": "Consider the situation where  and we wish to insert a record\nwith key  such that\n.\nThe probe sequence for   is 3, 5, 7, 9, and so on.\nIf another key  has home position at slot 5,\nthen its probe sequence will be 5, 7, 9, and so on.\nThe probe sequences of  and \nare linked together in a manner that contributes to clustering.\nIn other words, linear probing with a value of  does not\nsolve the problem of primary clustering.\nWe would like to find a probe function that does not link\nkeys together in this way.\nWe would prefer that the probe sequence for \nafter the first step on the sequence should not be identical to the\nprobe sequence of .\nInstead, their probe sequences should diverge."}, {"title_reference": ["pseudo-random probing", "i", "(textbf{h}(K) + r_i) mod M", "r_i", "i", "M-1", "textbf{p}(K, i) = textbf{Permutation}[i]", "M", "M - 1", "M - 1"], "strong": ["Permutation", "Permutation[0]"], "#text": "The ideal probe function would select the next position on the probe\nsequence at random from among the unvisited slots; that is, the probe\nsequence should be a random permutation of the hash table positions.\nUnfortunately, we cannot actually select the next position in the\nprobe sequence at random, because we would not be able to duplicate\nthis same probe sequence when searching for the key.\nHowever, we can do something similar called\n.\nIn pseudo-random probing, the  th slot in the probe sequence is\n\nwhere  is the  th value in a random permutation\nof the numbers from 1 to .\nAll inserts and searches must use the same sequence of random numbers.\nThe probe function would be\n\nwhere  is an array of length  that stores a value of\n0 in position , and stores a\nrandom permutation of the values from 1 to  in slots 1 to\n."}, "Here is a practice exercise for pseudo-random probing.", "Pseudo-random probing exhibits another desirable feature in a hash\nfunction."], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "collisionCON3", "@long_name": "collisionCON3", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "HashPseudoRandomPPRO", "@long_name": "HashPseudoRandomPPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "collisionCON4", "@long_name": "collisionCON4", "@points": "0", "@required": "True", "@threshold": "1.0"}}]}, {"@ids": "quadratic-probing", "@names": "quadratic\\ probing", "title": "Quadratic Probing", "paragraph": [{"title_reference": ["quadratic probing", "textbf{p}(K, i) = c_1 i^2 + c_{2}i + c_3", "c_1", "c_2", "c_3"], "#text": "Another probe function that eliminates\nprimary clustering is called\n.\nHere the probe function is some quadratic function\n\nfor some choice of constants , ,\nand  ."}, {"title_reference": ["textbf{p}(K, i) = i^2", "c_1 = 1", "c_2 = 0", "c_3 = 0", "i", "(textbf{h}(K) + i^2) mod M"], "#text": "The simplest variation is \n(i.e., , , and\n).\nThen the  th value in the probe sequence would be\n."}, "Now you can practice quadratic probing.", "There is one problem with quadratic probing: Its probe sequence\ntypically will not visit all slots in the hash table.", "For many hash table sizes, this probe function will cycle through a\nrelatively small number of slots.\nIf all slots on that cycle happen to be full, this means that the\nrecord cannot be inserted at all!\nA more realistic example is a table with 105 slots.\nThe probe sequence starting from any given slot will only visit 23\nother slots in the table.\nIf all 24 of these slots should happen to be full, even if other slots\nin the table are empty, then the record cannot be inserted because the\nprobe sequence will continually hit only those same 24 slots.", {"title_reference": ["textbf{p}(K, i) = i^2", "textbf{p}(K, i) = (i^2 + i)/2"], "#text": "Fortunately, it is possible to get good results from quadratic probing\nat low cost.\nThe right combination of probe function and table size will visit many\nslots in the table.\nIn particular, if the hash table size is a prime number and the probe\nfunction is ,\nthen at least half the slots in the table will be visited.\nThus, if the table is less than half full, we can be certain that a\nfree slot will be found.\nAlternatively, if the hash table size is a power of two and the probe\nfunction is ,\nthen every slot in the table will be visited by the probe function."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "collisionCON5", "@long_name": "collisionCON5", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "HashQuadraticPPRO", "@long_name": "HashQuadraticPPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "collisionCON6", "@long_name": "collisionCON6", "@points": "0", "@required": "True", "@threshold": "1.0"}}]}, {"@ids": "double-hashing", "@names": "double\\ hashing", "title": "Double Hashing", "paragraph": [{"strong": "p", "title_reference": ["K", "secondary clustering"], "#text": "Both pseudo-random probing and quadratic probing eliminate\nprimary clustering, which is the name given to the the situation when\nkeys share substantial segments of a probe sequence.\nIf two keys hash to the same home position, however, then they will always\nfollow the same probe sequence for every collision resolution method that\nwe have seen so far.\nThe probe sequences generated by pseudo-random and\nquadratic probing (for example) are entirely a function of the home\nposition, not the original key value.\nThis is because function  ignores its input parameter\n for these collision resolution methods.\nIf the hash function generates a cluster at a particular home\nposition, then the cluster remains under pseudo-random and quadratic\nprobing.\nThis problem is called ."}, {"title_reference": ["textbf{h}_2", "textbf{p}(K, i) = i * textbf{h}_2(K)", "double hashing"], "#text": "To avoid secondary clustering, we need to have the probe sequence make\nuse of the original key value in its decision-making process.\nA simple technique for doing this is to return to\nlinear probing by a constant step size\nfor the probe function, but to\nhave that constant be determined by a second hash function,\n.\nThus, the probe sequence would be of the form\n.\nThis method is called ."}, {"title_reference": ["h_2", "h_2", "M", "M", "h_2"], "#text": "There are important restrictions on .\nMost importantly, the value returned by  must never be zero\n(or ) because that will immediately lead to an infinite loop\nas the probe sequence makes no progress.\nHowever, a good implementation of double hashing should also ensure\nthat all of the probe sequence constants are relatively\nprime to the table size .\nFor example, if the hash table size were 100 and the step size for\nlinear probing (as generated by function ) were 50, then\nthere would be only one slot on the probe sequence.\nIf instead the hash table size is 101 (a prime number), than any step\nsize less than 101 will visit every slot in the table."}, {"title_reference": ["M", "textbf{h}_2", "1 <= textbf{h}_2(k) <= M - 1", "textbf{h}_2(k) = 1 + (k mod (M-1))", "M = 2^m", "m", "textbf{h}_2", "2^m", "textbf{h}_2(k) = (((k/M) mod (M/2)) * 2) + 1"], "#text": "This can be achieved easily.\nOne way is to select  to be a prime number, and have\n return a value in the range\n.\nWe can do this by using this secondary hash function:\n.\nAn alternative is to set \nfor some value  and have\n return an odd value\nbetween 1 and .\nWe can get that result with this secondary hash function:\n."}, "Now you can try it."], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "collisionCON7", "@long_name": "collisionCON7", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "collisionCON8", "@long_name": "collisionCON8", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "HashDoublePPRO", "@long_name": "HashDoublePPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/collisionCON1.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/collisionCON2.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/collisionCON3.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/collisionCON4.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/collisionCON5.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/collisionCON6.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/collisionCON7.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/collisionCON8.js"}], "line_block": {"line": null}, "footnote": {"@auto": "1", "@ids": "id1", "@names": "1", "label": "1", "paragraph": {"title_reference": ["textbf{h}_2(k) = (((k/M) mod (M/2)) * 2) + 1", "M", "M = 2^m", "M", "m", "textbf{h}_2", "((X mod (M/2)) * 2) + 1", "M-1", "k/M", "M = 2^m", "m", "m", "m", "m", "m", "2m"], "#text": "The secondary hash function\n might\nseem rather mysterious, so let's break this down.\nThis is being used in the context of two facts: (1) We want the\nfunction to return an odd value that is less than  the\nhash table size, and (2) we are using a hash table of size\n, which means that taking the mod of size\n is using the bottom  bits of the key value.\nOK, since  is multiplying something by 2 and\nadding 1, we guarentee that it is an odd number.\nNow,  must be in the range 1\nand  (if you need to, play around with this on paper\nto convince yourself that this is true).\nThis is exactly what we want.\nThe last piece of the puzzle is the first part .\nThat is not strictly necessary.\nBut remember that since the table size is , this\nis the same as shifting the key value right by  bits.\nIn other words, we are not using the bottom  bits to\ndecide on the second hash function value, which is especially a\ngood thing if we used the bottom  bits to decide on\nthe first hash function value!\nIn other words, we really do not want the value of the step\nsized used by the linear probing to be fixed to the slot in the\nhash table that we chose.\nSo we are using the next  bits of the key value\ninstead.\nNote that this would only be a good idea if we have keys in a\nlarge enough key range, that is, we want plenty of use of those\nsecond  bits in the key range.\nThis will be true if the max key value uses at least \nbits, meaning that the max key value should be at least the\nsquare of the hash table size.\nThis is not a problem for typical hashing applications."}}}]}}