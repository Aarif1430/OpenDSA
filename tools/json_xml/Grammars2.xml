<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="grammars-part-2" names="grammars\ -\ part\ 2" source="&lt;string&gt;" title="Grammars - Part 2"><title>Grammars - Part 2</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-13 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/PL/AV/parseTree.css</odsalink></raw><comment xml:space="preserve">(W 2/3/16)</comment><section ids="rp-2-part-1" names="rp\ 2\ part\ 1"><title>RP 2 part 1</title><block_quote><paragraph>The main topic of this module is <emphasis>ambiguous grammars</emphasis>.  In <title_reference>eg1</title_reference> of <emphasis>Grammars - Part 1</emphasis>, we developed a grammar for algebraic expressions that involved three non-terminals <title_reference>&lt;exp&gt;, &lt;trm&gt;, &lt;pri&gt;</title_reference>.   Could we develop a simpler grammar for the same language that only required two non-terminals?   Here is a candidate for doing that with only two non-terminals.</paragraph></block_quote><section ids="example-grammar-2" names="example\ grammar\ 2"><title>Example Grammar 2</title><math_block xml:space="preserve">\begin{eqnarray*}
&lt;exp&gt; &amp;::=&amp; &lt;exp&gt;\\
&amp;|&amp; &lt;exp&gt; + &lt;exp&gt; \\
&amp;|&amp; &lt;exp&gt; - &lt;exp&gt; \\
&amp;|&amp; &lt;exp&gt; * &lt;exp&gt; \\
&amp;|&amp; &lt;exp&gt; / &lt;exp&gt; \\
&lt;exp&gt; &amp;::=&amp; &lt;pri&gt; \\
&amp;|&amp; ( &lt;exp&gt; ) \\
&lt;pri&gt; &amp;:==&amp; A | B | C | \ldots | X | Y | Z
\end{eqnarray*}</math_block><paragraph>Let's try to parse the expression <title_reference>A+B*C</title_reference> using this grammar.
The grammar offers us a lot of options for how to start the parse.  We
could choose to first use the production with the <title_reference>+</title_reference> operator,
as is done in the following slide-show.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="parseTree5a"
    long_name="parseTree5a"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Or we could also start with the production having the <title_reference>*</title_reference> operator, in which case the parse proceeds as shown in the following slide-show.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="parseTree5b"
    long_name="parseTree5b"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Note that both of the slide-shows above produce valid parse trees for this grammar.   The problem, however, is that the two parse trees are different.   In the first of the two parse trees, B would multiply C, which would correspond to usual operator precedence.   However, in the parse tree produced by the second slide-show, B would be added to A, a result that is contrary to usual operator precedence.   A grammar such as this, which allows two different parse trees for the same expression, is called an <emphasis>ambiguous grammar</emphasis>.   Ambiguous grammars should always be avoided.   Although they allow you to determine the syntactic correctness of an expression, the variety of parse trees they allow confounds our ability to use the parse trees for any type of reliable semantic action.</paragraph><paragraph>The review problem set for this module contains four review problems, the first three of which refer to the same grammar.  The first problem is about determining how many parse trees a given string has in a given grammar.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP2part1"
    long_name="RP2part1"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section></section><section ids="rp-2-part-2" names="rp\ 2\ part\ 2"><title>RP 2 part 2</title><paragraph>This problem is again about determining how many parse trees a given string
has in a given grammar.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP2part2"
    long_name="RP2part2"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="rp-2-part-3" names="rp\ 2\ part\ 3"><title>RP 2 part 3</title><paragraph>This problem is once more about determining how many parse trees a
given string has in a given grammar.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP2part3"
    long_name="RP2part3"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="rp-2-part-4" names="rp\ 2\ part\ 4"><title>RP 2 part 4</title><paragraph>This problem will help you discover ambiguities in grammars as well as
convince yourself that a grammar is not ambiguous.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP2part4"
    long_name="RP2part4"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/PL/AV/parseTree5a.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/PL/AV/parseTree5b.js</odsascript></raw></section></document>