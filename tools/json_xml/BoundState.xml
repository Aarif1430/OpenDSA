<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="state-space-lower-bounds-proofs" names="state\ space\ lower\ bounds\ proofs" source="&lt;string&gt;" title="State Space Lower Bounds Proofs"><title>State Space Lower Bounds Proofs</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>We now consider the problem of finding both the minimum and the
maximum from an (unsorted) list of values.
This might be useful if we want to know the range of a collection of
values to be plotted, for the purpose of drawing the plot's scales.
Of course we could find them independently in <title_reference>2n-2</title_reference>
comparisons.
A slight modification is to find the maximum in <title_reference>n-1</title_reference>
comparisons, remove it from the list, and then find the minimum in
<title_reference>n-2</title_reference> further comparisons for a total of <title_reference>2n-3</title_reference>
comparisons.
Can we do better than this?</paragraph><paragraph>Before continuing, think a moment about how this problem of finding
the minimum and the maximum compares to the problem of the last
section, that of finding the second biggest value
(and by implication, the maximum).
Which of these two problems do you think is harder?
It is probably not at all obvious to you that one problem is harder or
easier than the other.
There is intuition that argues for either case.
On the one hand intuition might argue that the process of finding the
maximum should tell you something about the second biggest value, more
than that process should tell you about the minimum value.
On the other hand, any given comparison tells you something about
which of two can be a candidate for maximum value, and which can be a
candidate for minimum value, thus making progress in both directions.</paragraph><paragraph>We will start by considering a simple divide-and-conquer approach to
finding the minimum and maximum.
Split the list into two parts and find the minimum and
maximum elements in each part.
Then compare the two minimums and maximums to each other with a
further two comparisons to get the final result.
The algorithm is as follows:</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>The cost of this algorithm can be modeled by the following recurrence.</paragraph><math_block xml:space="preserve">\mathbf{T}(n) = \left\{\begin{array}{ll}
             0       &amp; n = 1\\
             1       &amp; n = 2\\
             {\bf T}(\lfloor n/2 \rfloor) + {\bf T}(\lceil n/2
             \rceil) + 2    &amp; n &gt; 2
            \end{array}
     \right.</math_block><paragraph>This is a rather interesting recurrence, and its
solution ranges between <title_reference>3n/2 - 2</title_reference>
(when <title_reference>n = 2^i</title_reference> or <title_reference>n=2^1 pm 1</title_reference>)
and <title_reference>5n/3 - 2</title_reference> (when <title_reference>n = 3 times 2^i</title_reference>).
We can infer from this behavior that how we divide the list affects
the performance of the algorithm.
For example, what if we have six items in the list?
If we break the list into two sublists of three elements, the cost
would be 8.
If we break the list into a sublist of size two and another of size
four, then the cost would only be 7.</paragraph><paragraph>With divide and conquer, the best algorithm is the one that minimizes
the work, not necessarily the one that balances the input sizes.
One lesson to learn from this example is that it can be important to
pay attention to what happens for small sizes of <title_reference>n</title_reference>, because
any division of the list will eventually produce many small lists.</paragraph><paragraph>We can model all possible divide-and-conquer strategies for this
problem with the following recurrence.</paragraph><math_block xml:space="preserve">\mathbf{T}(n) = \left\{
\begin{array}{ll}
0&amp;n=1\\
1&amp;n=2\\
\min_{1\leq k\leq n-1} \{{\bf T}(k) + {\bf T}(n-k)\} + 2&amp;n&gt;2
\end{array}\right.</math_block><paragraph>That is, we want to find a way to break up the list that will minimize
the total work.
If we examine various ways of breaking up small lists, we will
eventually recognize that breaking the list into a sublist of size 2
and a sublist of size (n-2) will always produce results as good as
any other division.
This strategy yields the following recurrence.</paragraph><math_block xml:space="preserve">\mathbf{T}(n) = \left\{
\begin{array}{ll}
0&amp;n=1\\
1&amp;n=2\\
{\bf T}(n-2) + 3&amp;n&gt;2
\end{array}\right.</math_block><paragraph>This recurrence (and the corresponding algorithm) yields
<title_reference>mathbf{T}(n) = lceil 3n/2 rceil - 2</title_reference> comparisons.
Is this optimal?
We now introduce yet another tool to our collection of lower bounds
proof techniques: The state space proof.</paragraph><paragraph>We will model our algorithm by defining a <title_reference>state</title_reference> that the
algorithm must be in at any given instant.
We can then define the start state, the end state, and the
transitions between states that any algorithm can support.
From this, we will reason about the minimum number of states that the
algorithm must go through to get from the start to the end, to reach
a state space lower bound.</paragraph><paragraph>At any given instant, we can track the following four categories of
elements:</paragraph><bullet_list bullet="*"><list_item><paragraph>Untested: Elements that have not been tested.</paragraph></list_item><list_item><paragraph>Winners: Elements that have won at least once, and never lost.</paragraph></list_item><list_item><paragraph>Losers: Elements that have lost at least once, and never won.</paragraph></list_item><list_item><paragraph>Middle: Elements that have both won and lost at least once.</paragraph></list_item></bullet_list><paragraph>We define the current state to be a vector of four values,
<title_reference>(U, W, L, M)</title_reference> for untested, winners, losers, and middles,
respectively.
For a set of <title_reference>n</title_reference> elements, the initial state of the algorithm is
<title_reference>(n, 0, 0, 0)</title_reference> and the end state is <title_reference>(0, 1, 1, n-2)</title_reference>.
Thus, every run for any algorithm must go from
state <title_reference>(n, 0, 0, 0)</title_reference> to state <title_reference>(0, 1, 1, n-2)</title_reference>.
We also observe that once an element is identified to be a middle,
it can then be ignored because it can neither be the minimum nor the
maximum.</paragraph><paragraph>Given that there are four types of elements, there are 10 types of
comparison.
Comparing with a middle cannot be more efficient than other
comparisons, so we should ignore those, leaving six comparisons of
interest.
We can enumerate the effects of each comparison type as follows.
If we are in state <title_reference>(i, j, k, l)</title_reference> and we have a comparison, then
the state changes are as follows.</paragraph><math_block xml:space="preserve">\begin{array}{lllll}
U:U&amp;(i-2,&amp;j+1,&amp;k+1,&amp;l)\\
W:W&amp;(i,&amp;j-1,&amp;k,&amp;l+1)\\
L:L&amp;(i,&amp;j,&amp;k-1,&amp;l+1)\\
L:U&amp;(i-1,&amp;j+1,&amp;k,&amp;l)\\
\quad or&amp;(i-1,&amp;j,&amp;k,&amp;l+1)\\
W:U&amp;(i-1,&amp;j,&amp;k+1,&amp;l)\\
\quad or&amp;(i-1,&amp;j,&amp;k,&amp;l+1)\\
W:L&amp;(i,&amp;j,&amp;k,&amp;l)\\
\quad or&amp;(i,&amp;j-1,&amp;k-1,&amp;l+2)
\end{array}</math_block><paragraph>Now, let us consider what an adversary will do for the various
comparisons.
The adversary will make sure that each comparison does the least
possible amount of work in taking the algorithm toward the goal
state.
For example, comparing a winner to a loser is of no value because the
worst case result is always to learn nothing new (the winner remains a
winner and the loser remains a loser).
Thus, only the following five transitions are of interest:</paragraph><math_block xml:space="preserve">\begin{array}{lllll}
U:U&amp;(i-2,&amp;j+1,&amp;k+1,&amp;l)\\
L:U&amp;(i-1,&amp;j+1,&amp;k,&amp;l)\\
W:U&amp;(i-1,&amp;j,&amp;k+1,&amp;l)\\
\hline
W:W&amp;(i,&amp;j-1,&amp;k,&amp;l+1)\\
L:L&amp;(i,&amp;j,&amp;k-1,&amp;l+1)
\end{array}</math_block><paragraph>Only the last two transition types increase the number of middles,
so there must be <title_reference>n-2</title_reference> of these.
The number of untested elements  must go to 0, and the first
transition is the most efficient way to do this.
Thus, <title_reference>lceil n/2 rceil</title_reference> of these are required.
Our conclusion is that the minimum possible number of transitions
(comparisons) is <title_reference>n + lceil n/2 rceil - 2</title_reference>.
Thus, our algorithm is optimal.</paragraph></document>