{"document": {"@dupnames": "the\\ dictionary\\ adt", "@ids": "the-dictionary-adt", "@source": "<string>", "@title": "The Dictionary ADT", "title": "The Dictionary ADT", "subtitle": {"@dupnames": "the\\ dictionary\\ adt", "@ids": "id1", "#text": "The Dictionary ADT"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "DesignDictionarySumm", "@long_name": "DesignDictionarySumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "paragraph": [{"title_reference": "dictionary", "#text": "The most common objective of computer programs is to store and\nretrieve data.\nMuch of this book is about efficient ways to organize collections of\ndata records so that they can be stored and retrieved quickly.\nIn this section we describe a simple interface for such a collection,\ncalled a .\nThe dictionary ADT provides operations for storing records, finding\nrecords, and removing records from the collection.\nThis ADT gives us a standard basis for comparing various data\nstructures.\nLoosly speaking, we can say that any data structure that supports\ninsert, search, and deletion is a \"dictionary\"."}, {"title_reference": ["search key", "comparable <comparable> <Comparison>", "totally ordered <total order>", "spatial data structures <spatial data structure> <Spatial>"], "#text": "Dictionaries depend on the concepts of a  and\n objects.\nTo implement the dictionary's search function, we will require that\nkeys be .\nOrdering fields that are naturally multi-dimensional, such as a point\nin two or three dimensions, present special opportunities if we wish\nto take advantage of their multidimensional nature.\nThis problem is addressed by\n."}, "Here is code to define a simple abstract dictionary class.", {"literal": ["insert", "find", "insert", "find"], "#text": "The methods  and  are the heart of the class.\nMethod  takes a record and inserts it into the dictionary.\nMethod  takes a key value and returns some record from\nthe dictionary whose key matches the one provided.\nIf there are multiple records in the dictionary with that key value,\nthere is no requirement as to which one is returned."}, {"literal": ["clear", "remove", "find", "size"], "#text": "Method  simply re-initializes the dictionary.\nThe  method is similar to , except that it\nalso deletes the record returned from the dictionary.\nOnce again, if there are multiple records in the dictionary that match\nthe desired key, there is no requirement as to which one actually is\nremoved and returned.\nMethod  returns the number of elements in the\ndictionary."}, {"literal": ["removeAny", "remove", "removeAny", "removeAny"], "#text": "The remaining Method is .\nThis is similar to , except that it does not take a key\nvalue.\nInstead, it removes an arbitrary record from the dictionary, if one\nexists.\nThe purpose of this method is to allow a user the ability to iterate\nover all elements in the dictionary (of course, the dictionary will\nbecome empty in the process).\nWithout the  method, a dictionary user could not get\nat a record of the dictionary that he didn't already know the key\nvalue for.\nWith the  method, the user can process all records\nin the dictionary as shown in the following code fragment."}, {"literal": "RemoveAny", "#text": "There are other approaches that might seem more natural for iterating\nthough a dictionary, such as using a \"first\" and a \"next\" function.\nBut not all data structures that we want to use to implement a\ndictionary are able to do \"first\" efficiently.\nFor example, a hash table implementation cannot efficiently locate the\nrecord in the table with the smallest key value.\nBy using , we have a mechanism that provides generic\naccess."}, "Given a database storing records of a particular type,\nwe might want to search for records in multiple ways.\nFor example, we might want to store payroll records in one dictionary\nthat allows us to search by ID,\nand also store those same records in a second dictionary that\nallows us to search by name.", "Here is an implementation for a payroll record.", {"literal": ["Payroll", "Payroll"], "#text": "Class  has multiple fields, each of which might be\nused as a search key.\nSimply by varying the type for the key, and using the appropriate\nfield in each record as the key value,\nwe can define a dictionary whose search key is the ID field,\nanother whose search key is the name field, and a third whose search\nkey is the address field.\nHere is an example where \nobjects are stored in two separate dictionaries, one using the\nID field as the key and the other using the name field as the key."}, {"title_reference": "homogeneous <homogeneity> <ListElement>", "#text": "One problem with the example as it is written is that the dictionary\nrelies on the programmer to be reasonable about being consistent with\nthe keys.\nThese dictionaries are intended to have\n elements.\nBut nothing stops the programmer from inserting an integer key into\nthe names dictionary, or searching with an integer search key.\nThis problem can be handled by using C++ templates or Java generics."}, {"title_reference": ["extract the key <comparable> <Comparison>", "key-value pair"], "#text": "The fundamental operation for a dictionary is finding a record that\nmatches a given key.\nThis raises the issue of how to\n from a record.\nWe will usually assume that dictionary implementations store a\n so as to be able to extract the key\nassociated with a record for this particular dictionary."}, {"literal": "insert", "#text": "The  method of the dictionary class supports the\nkey-value pair implementation because it takes two parameters,\na record and its associated key for that dictionary."}, "Now that we have defined the dictionary ADT and settled on the design\napproach of storing key-value pairs for our dictionary entries, we are\nready to consider ways to implement it.\nTwo possibilities would be to use an array-based or linked list.\nHere is an implementation for the dictionary using\nan (unsorted) array-based list.", {"literal": ["UALdict", "insert", "find", "remove", "remove", "removeAny"], "math": "\\Theta(n)", "#text": "Examining class  (UAL stands for \"unsorted array-based\nlist\"), we can easily see that \nis a constant-time operation, because it simply inserts the new record\nat the end of the list.\nHowever, , and  both require  time\nin the average and worst cases, because we need to do a sequential\nsearch.\nMethod  in particular must touch every record in the\nlist, because once the desired record is found, the remaining records\nmust be shifted down in the list to fill the gap.\nMethod  removes the last record from the list, so\nthis is a constant-time operation."}, {"literal": "UALDictionary", "#text": "As an alternative, we could implement the dictionary using a linked\nlist.\nThe implementation would be quite similar to that for\n, and the cost of the functions should be the same\nasymptotically."}, {"literal": ["find", "List", "insert", "List"], "#text": "Another alternative would be to implement the dictionary with a sorted\nlist.\nThe advantage of this approach would be that we might be able to speed\nup the  operation by using a binary search.\nTo do so, first we must define a variation on the  ADT to\nsupport sorted lists.\nA sorted list is somewhat different from an unsorted list in that it\ncannot permit the user to control where elements get inserted.\nThus, the  method must be quite different in a sorted\nlist than in an unsorted list.\nLikewise, the user cannot be permitted to append elements onto the\nlist.\nFor these reasons, a sorted list cannot be implemented with\nstraightforward inheritance from the  ADT."}, {"literal": ["find", "find", "insert", "insert", "find", "find", "insert", "remove", "remove"], "math": ["\\Theta(\\log n)", "n", "\\Theta(n)", "\\Theta(n)"], "#text": "The cost for  in a sorted list is  for a\nlist of length .\nThis is a great improvement over the cost of  in an\nunsorted list.\nUnfortunately, the cost of  changes from constant time in\nthe unsorted list to  time in the sorted list.\nWhether the sorted list implementation for the dictionary ADT is more\nor less efficient than the unsorted list implementation depends on the\nrelative number of\n and  operations to be performed.\nIf many more  operations than  operations are\nused, then it might be worth using a sorted list to implement the\ndictionary.\nIn both cases,  requires  time in the worst\nand average cases.\nEven if we used binary search to cut down on the time to find the\nrecord prior to removal, we would still need to shift down the\nremaining records in the list to fill the gap left by the\n operation."}, {"title_reference": "Search trees <search tree> <BST>", "math": "\\Theta(\\log n)", "#text": "are search\nstructures that can perform all three key operations of insert,\nsearch, and delete in  time."}]}}