{"document": {"@ids": "the-programmer-s-view-of-files", "@names": "the\\ programmer's\\ view\\ of\\ files", "@source": "<string>", "@title": "The Programmer's View of Files", "title": "The Programmer's View of Files", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "paragraph": [{"title_reference": "disk controller", "#text": "The programmer's logical view of a random access file is a single array of bytes.\nInteraction with a file can be viewed as a communications\nchannel for issuing one of three instructions: read bytes from the\ncurrent position in the file, write bytes to the current position in\nthe file, and move the current position within the file.\nYou do not normally see how the bytes are stored on the disk in sectors,\nclusters, and so forth.\nThe mapping from logical to physical addresses is done by the file\nsystem, and sector-level buffering is done automatically by the\n."}, {"title_reference": ["random access", "Sequential access"], "#text": "When processing records in a disk file, the order of access can have a\ngreat effect on I/O time.\nA  procedure processes records in an order independent\nof their logical order within the file.\n processes records in order of their logical\nappearance within the file.\nSequential processing requires less seek time if the physical layout\nof the disk file matches its logical layout, as would be expected if\nthe file were created on a disk with a high percentage of free space."}, {"literal": "RandomAccessFile", "#text": "Java provides several mechanisms for manipulating disk files.\nOne of the most commonly used is the  class.\nThe following methods can be used to manipulate information in the\nfile."}, {"title_reference": ["message passing <message passing> <BuffPool>", "buffer pools <buffer pool>"], "#text": "Note that the spirit if this ADT is similar to\n\nversion of the ADT for ."}], "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": {"literal": "RandomAccessFile(String name, String mode)", "#text": ": Class constructor,\nopens a disk file for processing."}}, {"paragraph": {"literal": "read(byte[] b)", "#text": ": Read some bytes from the current position in\nthe file. The current position moves forward as the bytes are read."}}, {"paragraph": {"literal": "write(byte[] b)", "#text": ": Write some bytes at the current position in\nthe file (overwriting the bytes already at that position).\nThe current position moves forward as the bytes are written."}}, {"paragraph": {"literal": ["seek(long pos)", "pos"], "#text": ":\nMove the current position in the file to .\nThis allows bytes at arbitrary places within the file to be read or\nwritten."}}, {"paragraph": {"literal": "close()", "#text": ": Close a file at the end of processing."}}]}}}