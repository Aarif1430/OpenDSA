<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="information\ flow\ in\ recursive\ functions" ids="information-flow-in-recursive-functions" source="&lt;string&gt;" title="Information Flow in Recursive Functions"><title>Information Flow in Recursive Functions</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Binary/WriteTrav.css</odsalink></raw><section dupnames="information\ flow\ in\ recursive\ functions" ids="id1"><title>Information Flow in Recursive Functions</title><paragraph>Handling information flow in a recursive function can be a challenge.
In any given function, we might need to be concerned with either or
both of:</paragraph><block_quote><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Passing down the correct information needed by the function to do
its work,</paragraph></list_item><list_item><paragraph>Returning (passing up) information to the recursive function's
caller.</paragraph></list_item></enumerated_list></block_quote><paragraph>Any given problems might need to do either or both.
Here are some examples and exercises.</paragraph><section ids="local" names="local"><title>Local</title><paragraph>Local traversal involves going to each node in the tree to do some
operation.
Such functions need no information from the parent (other than a
pointer to the current node), and pass no information back.
Examples include preorder traversal and incrementing the value of
every node by one.</paragraph></section><section ids="passing-down-information" names="passing\ down\ information"><title>Passing Down Information</title><paragraph>Slightly more complicated is the situation where every node needs the
same piece of information to be passed to it.
An example would be incrementing the value for all nodes by some
amount.
In this case, the value parameter is simply passed on
unchanged in all recursive calls.</paragraph><paragraph>Many functions need information that changes from node to node.
A simple example is a function to set the value for each node of the
tree to be its depth.
In this case, the depth is passed as a parameter to the function, and
each recursive call must adjust that value (by adding one).</paragraph></section></section><section ids="binary-tree-set-depth-exercise" names="binary\ tree\ set\ depth\ exercise"><title>Binary Tree Set Depth Exercise</title><raw format="xml" xml:space="preserve"><extertool
    resource_name='Binary Tree Set Depth Exercise'
    resource_type="external_assignment"
    learning_tool="code-workout"
    points="2.0">
</extertool>
</raw></section><section ids="collect-and-return" names="collect-and-return"><title>Collect-and-return</title><paragraph>Collect-and-return requires that we communicate information back up
the tree to the caller.
Simple examples are to count the number of nodes in a tree,
or to sum the values of all the nodes.</paragraph><topic><title>Example</title><paragraph>Consider the problem of counting (and returning) the number of
nodes in a binary tree.
The key insight is that the total count for any (non-empty) subtree is
one for the root plus the counts for the left and right subtrees.
Where do left and right subtree counts come from?
Calls to function <literal>count</literal> on the subtrees will compute this for
us.
Thus, we can implement <literal>count</literal> as follows.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>The following solution is correct but inefficient as it does
redundant checks on the left and the right child of each visited
node.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw></topic><paragraph>When you write a recursive function that returns a value,
such as counting the number of nodes in the subtree,
you have to make sure that your function actually returns a value.
A common mistake is to make a recursive call and not capture the
returned value.
Another common mistake is to not return a value.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="BinaryTreeMistakesCON"
    long_name="BinaryTreeMistakesCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></section><section ids="binary-tree-check-sum-exercise" names="binary\ tree\ check\ sum\ exercise"><title>Binary Tree Check Sum Exercise</title><raw format="xml" xml:space="preserve"><extertool
    resource_name='Binary Tree Check Sum Exercise'
    resource_type="external_assignment"
    learning_tool="code-workout"
    points="2.0">
</extertool>
</raw></section><section ids="binary-tree-leaf-nodes-count-exercise" names="binary\ tree\ leaf\ nodes\ count\ exercise"><title>Binary Tree Leaf Nodes Count Exercise</title><raw format="xml" xml:space="preserve"><extertool
    resource_name='Binary Tree Leaf Nodes Count Exercise'
    resource_type="external_assignment"
    learning_tool="code-workout"
    points="2.0">
</extertool>
</raw></section><section ids="binary-tree-sum-nodes-exercise" names="binary\ tree\ sum\ nodes\ exercise"><title>Binary Tree Sum Nodes Exercise</title><raw format="xml" xml:space="preserve"><extertool
    resource_name='Binary Tree Sum Nodes Exercise'
    resource_type="external_assignment"
    learning_tool="code-workout"
    points="2.0">
</extertool>
</raw></section><section ids="combining-information-flows" names="combining\ information\ flows"><title>Combining Information Flows</title><paragraph>Many functions require both that information be passed in, and that
information be passed back.
Let's start with a relatively simple case.
If we want to check if some node in the tree has a
particular value, that value has to be passed down, and the count has
to be passed back up.
The downward flow is simple, as the value being checked for never
changes.
The information passed up has the simple collect-and-return style:
Return True if and only if one of the children returns True.</paragraph></section><section ids="binary-tree-check-value-exercise" names="binary\ tree\ check\ value\ exercise"><title>Binary Tree Check Value Exercise</title><raw format="xml" xml:space="preserve"><extertool
    resource_name='Binary Tree Check Value Exercise'
    resource_type="external_assignment"
    learning_tool="code-workout"
    points="2.0">
</extertool>
</raw></section><section ids="combination-problems" names="combination\ problems"><title>Combination Problems</title><paragraph>Slightly more complicated problems combine what we have seen so far.
Information passing down the tree changes from node to node.
Data passed back up the tree uses the collect-and-return paradigm.</paragraph></section><section ids="binary-tree-height-exercise" names="binary\ tree\ height\ exercise"><title>Binary Tree Height Exercise</title><raw format="xml" xml:space="preserve"><extertool
    resource_name='Binary Tree Height Exercise'
    resource_type="external_assignment"
    learning_tool="code-workout"
    points="2.0">
</extertool>
</raw></section><section ids="binary-tree-get-difference-exercise" names="binary\ tree\ get\ difference\ exercise"><title>Binary Tree Get Difference Exercise</title><raw format="xml" xml:space="preserve"><extertool
    resource_name='Binary Tree Get Difference Exercise'
    resource_type="external_assignment"
    learning_tool="code-workout"
    points="2.0">
</extertool>
</raw></section><section ids="binary-tree-has-path-sum-exercise" names="binary\ tree\ has\ path\ sum\ exercise"><title>Binary Tree Has Path Sum Exercise</title><raw format="xml" xml:space="preserve"><extertool
    resource_name='Binary Tree Has Path Sum Exercise'
    resource_type="external_assignment"
    learning_tool="code-workout"
    points="2.0">
</extertool>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/BinaryTreeMistakesCON.js</odsascript></raw></section></document>