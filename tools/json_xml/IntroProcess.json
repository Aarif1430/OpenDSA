{"document": {"@dupnames": "software\\ development\\ processes", "@ids": "software-development-processes", "@source": "<string>", "@title": "Software Development Processes", "title": "Software Development Processes", "subtitle": {"@dupnames": "software\\ development\\ processes", "@ids": "id1", "#text": "Software Development Processes"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2015-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}], "paragraph": [{"strong": "software development process", "#text": "A  is simply the division of a software project into\ndistinct stages or phases of work.\nEach stage is characterized by specific activities which are used to help plan and\nmanage progress.\nA software development process is implemented to improve quality, cost or schedule\nperformance, or all of these things.\nWhile there as many software development processes as there are software practitioners,\na few have gained notoriety.\nThese more commonly encountered processes are the ones discussed in this section."}, {"emphasis": ["Plan-Do-Check-Act", "Plan-Do-Check-Act", "Agile", "Plan Driven"], "#text": "All software development processes are essentially variations on the \nfirst described by Francis Bacon in 1620 [Bacon].  Yes, that\u2019s right.\nThere are many software development processes, describing the   loop\nin varying levels of detail.  Today, most of these processes are lumped into either\nof two very broad categories:  or ."}, "Plan Driven processes emerged in the 1960's.\nAs the size of software projects grew, several worrying trends emerged:", "At the time, there was no professional class of programmers.\nEngineers, mathematicians, and physicists wrote programs to support their work.\nThe first software development processes were adapted from manufacturing and engineering\nprocesses.\nAmong the earliest was the systems development life cycle (SLDC).\nThe goals of the SDLC were\n\"to pursue the development of information systems in a very deliberate,\nstructured and methodical way, requiring each stage of the life cycle from\ninception of the idea to delivery of the final system,\nto be carried out rigidly and sequentially\" .\nPlan-driven methods continue to be the 'traditional' way most software\ncontinues to be developed today.", "Agile methods grew out frustration with the rigidity of the plan-driven processes commonly used\nin the 1990's just as the tech boom was heating up.\nTechnology was changing faster than projects could keep up and many projects failed because\nby the time they were ready to deliver, the playing field had changed enough to make the product,\nif not obsolete, at least a less compelling commercial success.", {"emphasis": "Agile Manifesto", "#text": "The practitioners of Agile methods tend to be a diverse and fraction group, but have, as a group\ndrafted a single statement that nearly all agile process models embrace.\nIt is known as the  .  Here it is in it's entirety:"}, {"emphasis": "either - or", "#text": "Much of the documentation available today implies that choosing a process is\nan  proposition.  That a project must be either plan driven or agile.\nThe reality is a bit more nuanced and there can can be bitter disagreements\nbetween proponents of different process models.\nOne way to summarize the differences between the two groups is to examine the\nmyths propagated about them."}, "Common misunderstandings directed at Plan-driven processes include:", "Common misunderstandings directed at agile processes include:", "The truth is that many agile and plan-driven methods exist.\nAll are more or less plan-driven and some have more 'agile' characteristics than others.\nTherefore, a more accurate characterisation is to think of processes\nexisting along a continuum, with the axis representing the relative\namount of willingness to embrace change (agility) at one and\nthe importance of comprehensive up front planning and adhering to that plan\nat the opposite end.  No process exists at either extreme.", "Each group has a sweet-spot where it outperforms the other as the following table summarizes.", "Balancing the trade-offs between agility and discipline is a decision each\nsoftware development project has to make on their own."], "block_quote": [{"bullet_list": {"@bullet": "-", "list_item": [{"paragraph": "Software projects routinely went over budget, or failed to deliver anything"}, {"paragraph": "Major defects and failures became more common"}, {"paragraph": "Software maintenance costs began increasing"}]}}, {"line_block": {"line": ["We are uncovering better ways of developing\nsoftware by doing it and helping others do it.", null, "Through this work we have come to value:", null, {"strong": "Individuals and interactions", "#text": "over processes and tools"}, {"strong": "Working software", "#text": "over comprehensive documentation"}, {"strong": "Customer collaboration", "#text": "over contract negotiation"}, {"strong": "Responding to change", "#text": "over following a plan"}, null, {"strong": "more", "#text": "That is, while there is value in the items on the right, we value the items on the left ."}]}}], "bullet_list": [{"@bullet": "-", "list_item": [{"definition_list": {"definition_list_item": {"term": "Can\u2019t respond to change", "definition": {"bullet_list": {"@bullet": "-", "list_item": {"paragraph": "Too big and complex"}}}}}}, {"paragraph": "Products cost more"}, {"paragraph": "Only for large organizations"}, {"paragraph": "Old-Fashioned"}, {"paragraph": {"strong": ["X", "X"], "#text": "Universally Applicable\n- Software development is uncertain and the  process improves predictability therefore all software developers should use process"}}]}, {"@bullet": "-", "list_item": [{"paragraph": "Agile is synonymous with Hacking"}, {"definition_list": {"definition_list_item": {"term": "It\u2019s a \u2018silver bullet\u2019", "definition": {"bullet_list": {"@bullet": "-", "list_item": {"paragraph": "Easy to implement, Very effective"}}}}}}, {"definition_list": {"definition_list_item": {"term": "Do whatever you want", "definition": {"bullet_list": {"@bullet": "-", "list_item": {"paragraph": "No cost or schedule commitments"}}}}}}, {"definition_list": {"definition_list_item": {"term": "Incompatible with traditional processes", "definition": {"bullet_list": {"@bullet": "-", "list_item": [{"paragraph": "No Documentation, Architecture, or Planning"}, {"paragraph": "Not appropriate for Firm Fixed Price Projects"}]}}}}}, {"definition_list": {"definition_list_item": {"term": "Universally Applicable", "definition": {"bullet_list": {"@bullet": "-", "list_item": {"paragraph": "The pace of IT change is accelerating and Agile methods adapt to change better than disciplined methods therefore Agile methods will take over the IT world."}}}}}}]}], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Scrum is not a complete software development process description as it covers only project management."}, {"paragraph": "CMMI is a process improvement model, not a software development methodology, but is often considered one."}]}, "table": {"tgroup": {"@cols": "3", "colspec": [{"@colwidth": "15"}, {"@colwidth": "65"}, {"@colwidth": "95"}], "thead": {"row": {"entry": [{"paragraph": "Characteristics"}, {"paragraph": "Agile"}, {"paragraph": "Plan Driven"}]}}, "tbody": {"row": [{"entry": [{"paragraph": "Primary Goals"}, {"paragraph": "Rapid Value, respond to change"}, {"paragraph": "Predictability, stability, & high assurance"}]}, {"entry": [{"paragraph": "Size"}, {"paragraph": "Small Teams and projects"}, {"paragraph": "Large teams and projects"}]}, {"entry": [{"paragraph": "Environment"}, {"paragraph": "Turbulent, project-focused"}, {"paragraph": "Stable, organization-focused"}]}, {"entry": [{"paragraph": "Requirements"}, {"paragraph": "Stories.  Rapid change expected."}, {"paragraph": "Formal Specs for projects, capability, interfaces, quality & similar.  Gradual change expected."}]}, {"entry": [{"paragraph": "Development"}, {"paragraph": "Simple design, short increments. Refactoring assumed inexpensive."}, {"paragraph": "Detailed architecture and design.  Refactoring assumed expensive."}]}, {"entry": [{"paragraph": "Test"}, {"paragraph": "Executable tests validate requirements"}, {"paragraph": "Documented test plans validate requirements"}]}]}}}, "footnote": [{"@auto": "1", "@ids": "id2", "@names": "1", "label": "1", "paragraph": {"emphasis": "Global Business Information Technology: an integrated systems approach", "#text": "Geoffrey Elliott. . Pearson Education. 2004."}}, {"@auto": "1", "@ids": "id3", "@names": "2", "label": "2", "paragraph": {"reference": {"@refuri": "http://www.agilealliance.org/", "#text": "http://www.agilealliance.org/"}}}], "section": [{"@ids": "waterfall-method", "@names": "waterfall\\ method", "title": "Waterfall Method", "paragraph": ["Initially described in 1970, the Waterfall process was another early\nsoftware development process adapted from manufacturing and construction processes.\nThe waterfall model is a sequential design process, in which progress is seen as\nflowing steadily downwards (like a waterfall) through several distinct phases.", "While many variations exist, most waterfall processes in use go through at least\nthe following phases:", "The waterfall model was simple to understand and was widely used throughout the 1980's,\nbut came under criticism primarily for it's lack of flexibility.\nAlthough officially endorsed bu the US Department of Defense in 1985, the DoD supplanted\nit with other process guidance 10 years later."], "raw": {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}, "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Requirements: System and software requirements, captured in a product requirements document."}, {"paragraph": "Analysis: resulting in models, schema, and business rules"}, {"paragraph": "Design: resulting in the software architecture"}, {"paragraph": "Implementation: the development and integration of software"}, {"paragraph": "Verification: the systematic discovery and debugging of defects"}, {"paragraph": "Maintenance: the installation, migration, support, and maintenance of complete systems"}]}, "footnote": {"@auto": "1", "@ids": "id4", "@names": "3", "label": "3", "paragraph": {"emphasis": "Waterfall model", "reference": {"@refuri": "http://creativecommons.org/licenses/by/3.0", "#text": "http://creativecommons.org/licenses/by/3.0"}, "#text": "Peter Kemp / Paul Smith, \n(Adapted from Paul Smith's work at wikipedia)\n[CC BY 3.0 ()], via Wikimedia Commons"}}}, {"@ids": "rational-unified-process", "@names": "rational\\ unified\\ process", "title": "Rational Unified Process", "paragraph": ["The Unified Software Development Process or Unified Process is a popular iterative\nand incremental software development process framework.\nThe best-known and extensively documented refinement of the Unified Process is the\nRational Unified Process (RUP).\nOther examples are OpenUP and Agile Unified Process.", "The Rational Unified Process (RUP) was created by the Rational Software Corporation in 1996.\nRUP is not a single concrete prescriptive process, but rather an adaptable process framework,\nintended to be tailored by the development organizations and software project teams that\nwill select the elements of the process that are appropriate for their needs.", "RUP is based on a set of building blocks and content elements,\ndescribing what is to be produced, the necessary skills required and\nthe step-by-step explanation describing how specific development goals are to be achieved.\nThe main building blocks, or content elements, are the following:", {"emphasis": "iterations", "#text": "The RUP defines a project as a series of .\nAn iteration is a period of time in which project tasks are performed.\nWithin each iteration, the tasks are categorized into nine disciplines:"}, "Other Plan-Driven Approaches"], "definition_list": [{"definition_list_item": [{"term": {"strong": "Roles (who)"}, "definition": {"paragraph": "A role defines a set of related skills, competencies and responsibilities."}}, {"term": {"strong": "Work products (what)"}, "definition": {"paragraph": "A work product represents something resulting from a task,\nincluding all the documents and models produced while working through the process."}}, {"term": {"strong": "Tasks (how)"}, "definition": {"paragraph": "A task describes a unit of work assigned to a Role that provides a meaningful result."}}]}, {"definition_list_item": [{"term": "Military Methods (DoD)", "definition": {"definition_list": {"definition_list_item": [{"term": "DoD-STD-2167", "definition": {"paragraph": "A document-driven approach that specified a large number of\n\"Data Item Descriptions\" for deliverables.\nTailoring was encouraged, but infrequently done."}}, {"term": "MIL-STD-1521", "definition": {"paragraph": "details a set of sequential reviews and audits required."}}, {"term": "MIL-STD-498", "definition": {"paragraph": "revised 2167 to allow more flexibility in systems engineering, planning,\ndevelopment, and integration."}}, {"term": "MIL-STD-499B", "definition": {"paragraph": "defines the contents of a systems engineering management plan."}}]}}}, {"term": "General Process Standards (ISO, EIA, IEEE)", "definition": {"definition_list": {"definition_list_item": [{"term": "EIA/IEEE J-STD-016", "definition": {"paragraph": "a generalization of MIL-STD-498 to include commercial software processes."}}, {"term": "ISO 9000", "definition": {"paragraph": "a quality management standard that includes software."}}, {"term": "ISO 12207 and 15504", "definition": {"paragraph": "address the software life cycle and ways to appraise software processes."}}]}}}, {"term": "Cleanroom (Harlan Mills, IBM)", "definition": {"paragraph": ["Uses statistical process control and mathematically based verification to develop software\nwith certified reliability.", "The name comes from physical clean rooms that prevent defects in precision electronics."]}}, {"term": "Capability Maturity Model for Software (SEI, Air Force, others)", "definition": {"paragraph": ["A process improvement framework, SW-CMM grew out of the need for the Air Force to\nselect qualified software system developers.", "Collects best practices into Key Practice Areas that are organized into\nfive levels of increasing process maturity."]}}, {"term": "Software Factories (Hitachi, GE, others)", "definition": {"paragraph": ["A long-term, integrated effort to improve software quality, software reuse, and software\ndevelopment productivity.", "Highly process-driven, emphasizing early defect reduction."]}}, {"term": "CMM Integration (SEI, DoD, NDIA, others)", "definition": {"paragraph": ["CMMI was established to integrate software and systems engineering CMMs, and improve\nor extend the CMM concept to other disciplines.", "Its a suite of models and appraisal methods that address a variety of disciplines using\na common architecture, vocabulary, and a core of process areas."]}}, {"term": "Personal Software Process (PSP)/Team Software Process (TSP) (Watts Humphrey, SEI)", "definition": {"definition_list": {"definition_list_item": [{"term": "PSP", "definition": {"paragraph": "A structured framework of forms, guidelines, and procedures for developing software.\nDirected toward the use of self-measurement to improve individual programming skills."}}, {"term": "TSP", "definition": {"paragraph": "Builds on PSP and supports the development of industrial-strength software through\nthe use of team planning and control."}}]}}}]}], "raw": {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}, "bullet_list": {"@bullet": "-", "list_item": [{"paragraph": "Six \"engineering\" disciplines", "block_quote": {"bullet_list": {"@bullet": "-", "list_item": [{"paragraph": "Business modelling"}, {"paragraph": "Requirements"}, {"paragraph": "Analysis and design"}, {"paragraph": "Implementation"}, {"paragraph": "Test"}, {"paragraph": "Deployment"}]}}}, {"paragraph": "And three \"supporting\" disciplines", "block_quote": {"bullet_list": {"@bullet": "-", "list_item": [{"paragraph": "Configuration and change management"}, {"paragraph": "Project management"}, {"paragraph": "Environment"}]}}}]}}, {"@ids": "extreme-programming-xp", "@names": "extreme\\ programming\\ (xp)", "title": "eXtreme Programming (XP)", "paragraph": ["Established in the late 1990's by Kent Beck, XP is\nregarded as perhaps the most famous agile method.\nXP was certainly among the first to gain attention from mainstream\nsoftware development projects.\nXP was refined from experience gained developing an information system for Daimler Chrysler\ncorporation.\nAs agile practices go, it is quite proscriptive, fairly rigorous and\ninitially expects all practices to be followed.\nKent Beck has been quoted as saying", {"emphasis": "Extreme Programming Explained", "#text": "In , Kent Beck describes extreme programming as a\nsoftware development discipline that organizes people to produce higher quality\nsoftware more productively.\nXP attempts to reduce the cost of changes in requirements by having multiple\nshort development cycles, rather than a long one.\nRather than a burden, changes are considered a natural, inescapable and desirable aspect of\nsoftware projects, and should be planned for, instead of attempting\nto define a stable set of requirements."}, "XP is characterised by several core practices including\nstories, pair programming, simple design,\ntest first, unit tests, and continuous integration.", "The XP process describes four basic activities that are performed\nwithin the software development process:\ncoding, testing, listening, and designing."], "block_quote": {"paragraph": "If you're not performing all 12 practices, then you're not doing XP."}, "raw": {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}, "definition_list": {"definition_list_item": [{"term": "Coding", "definition": {"paragraph": ["XP argues that the only truly important product of the software\ndevelopment process is code \u2013 software instructions that a computer can interpret.\nWithout code, there is no working product.", "Coding can also be used to figure out the most suitable solution.\nCoding can also help to communicate thoughts about programming problems.\nA programmer dealing with a complex programming problem, or finding it hard to\nexplain the solution to fellow programmers, might code it in a simplified manner\nand use the code to demonstrate what he or she means.\nCode, say the proponents of this position, is always clear and concise\nand cannot be interpreted in more than one way.\nOther programmers can give feedback on this code by also coding their thoughts."]}}, {"term": "Testing", "definition": {"paragraph": ["Unit tests determine whether a given feature works as intended.\nA programmer writes as many automated tests as they can think of that might \"break\" the code;\nif all tests run successfully, then the coding is complete.\nEvery piece of code that is written is tested before moving on to the next feature.", "Acceptance tests verify that the requirements as understood by the programmers\nsatisfy the customer's actual requirements.", "System-wide integration testing was encouraged, initially,\nas a daily end-of-day activity, for early detection of incompatible interfaces,\nto reconnect before the separate sections diverged widely from coherent functionality."]}}, {"term": "Listening", "definition": {"paragraph": "Programmers must listen to what the customers need the system to do,\nwhat \"business logic\" is needed.\nThey must understand these needs well enough to give the customer feedback\nabout the technical aspects of how the problem might be solved, or cannot be solved.\nCommunication between the customer and programmer is further addressed in the planning game."}}, {"term": "Designing", "definition": {"paragraph": "As software systems grow, the importance of design increases.\nSmall programs can be constructed with comparatively little design,\nhowever as software size grows, the more design is required.\nOften more upfront design is required as well as checking and revisiting\ndesigns throughout the lifetime of the project."}}]}, "footnote": {"@auto": "1", "@ids": "id5", "@names": "4", "label": "4", "paragraph": {"emphasis": "Planning / Feedback Loops", "reference": [{"@refuri": "https://en.wikipedia.org/wiki/File:XP-feedback.gif", "#text": "https://en.wikipedia.org/wiki/File:XP-feedback.gif"}, {"@refuri": "http://creativecommons.org/licenses/by-sa/3.0", "#text": "http://creativecommons.org/licenses/by-sa/3.0"}], "#text": "Don Wells, \n()\n[CC BY-SA 3.0 ()], via Wikimedia Commons"}}}, {"@ids": "crystal", "@names": "crystal", "title": "Crystal", "paragraph": ["Established in the late 1990's by Alistair Cockburn, Crystal is\nconceived as a family of software development processes organized by color,\nclear, yellow, orange, red.\nTo date, only Crystal Clear, the most light-weight in the family, has been completely documented.", "Crystal provides different levels of \u201cceremony\u201d depending on the size of the team and the\ncriticality of the project.\nCrystal practices draw from agile and plan-driven methods as well as psychology\nand organizational development research."]}, {"@ids": "scrum", "@names": "scrum", "title": "Scrum", "paragraph": ["Scrum is an agile software management process.\nThat is, it describes how software development teams should be organised and\nlet's each team determine what technical software development activities they\nshould perform.", "Projects are divided into 30-day work intervals (\u201csprints\u201d) in which a\nspecific number of requirements from a prioritized list (\u201cbacklog\u201d) are implemented.\nShort (10-15 minute) \u201cScrum meetings\u201d, held daily, maintain coordination within the team and with\nproject stakeholders (pigs and chickens)."]}, {"@ids": "feature-driven-development-fdd", "@names": "feature-driven\\ development\\ (fdd)", "title": "Feature-Driven Development (FDD)", "paragraph": "FDD is a lightweight, architecturally based process that initially establishes\nan overall object architecture and features list.\nProjects then proceed to design-by-feature and build-by-feature activities.\nBoth design-by-feature and build-by-feature are incremental software\nconstruction methodologies.\nIn FDD, the use of UML or other object-oriented design methods is strongly implied,\nif not explicitly required."}]}}