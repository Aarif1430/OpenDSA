{"document": {"@dupnames": "introduction\\ to\\ object\\ oriented\\ programming", "@ids": "introduction-to-object-oriented-programming", "@source": "<string>", "@title": "Introduction to Object Oriented Programming", "title": "Introduction to Object Oriented Programming", "subtitle": {"@dupnames": "introduction\\ to\\ object\\ oriented\\ programming", "@ids": "id1", "#text": "Introduction to Object Oriented Programming"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2014-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "paragraph": [{"title_reference": ["objects <object>", "data structures\n<data structure>"], "#text": "Object-oriented programming (OOP) is a programming paradigm based on the\nconcept of , which are  that contain data,\nin the form of fields (or attributes)\nand code, in the form of procedures, (or methods).\nA distinguishing feature of objects is that an object's procedures\nprovide access to and modify the its fields."}, "In object-oriented programming, computer programs are designed by making them\nout of objects that interact with one another.\nThere is significant diversity in object-oriented programming,\nbut most popular languages are class-based, meaning that objects are instances of classes,\nwhich typically also determines their type.", "Object orientation is an outgrowth of procedural programming.\nProcedural programming is a programming paradigm, derived from structured programming,\nbased upon the concept of the procedure call. Procedures, also known as routines, subroutines,\nor methods define the computational steps to be carried out.", "Any given procedure might be called at any point during a program's execution,\nincluding by other procedures or itself.\nProcedural programming is a list or set of instructions telling a\ncomputer what to do step by step and how to perform from the first\ncode to the second code.\nProcedural programming languages include C, Fortran, Pascal, and BASIC.", {"title_reference": "objects <object>", "strong": ["object", "instance of a class"], "#text": "The focus of procedural programming is to break down a programming task into\na collection of variables, data structures, and subroutines,\nwhereas in object-oriented programming it is to break down a programming task into\n that expose behavior (methods) and data (fields) using interfaces.\nThe most important distinction is that while procedural programming uses procedures\nto operate on data structures, object-oriented programming bundles the two together,\nso an , which is an , operates on its \"own\" data structure."}], "section": [{"@ids": "principles-of-object-oriented-programming", "@names": "principles\\ of\\ object\\ oriented\\ programming", "title": "Principles of Object Oriented Programming", "paragraph": "There are many views on the main features and motivations for object\noriented programming .\nThere are 4 principles that apply to most:", "block_quote": {"paragraph": ["Encapsulation refers to the creation of self-contained modules (classes)\nthat bind processing functions to its data members.\nThe data within each class is kept private.\nEach class defines rules for what is publicly visible and\nwhat modifications are allowed.", {"title_reference": "class hierarchy", "emphasis": "inheriting", "#text": "Classes may be created in hierarchies, and inheritance lets the\nstructure and methods in one class pass down the .\nBy  code, complex behaviors emerge\nthrough the reuse of code in a parent class.\nIf a step is added at the bottom of a hierarchy,\nonly the processing and data associated with that unique step must be added.\nEverything else above that step may be inherited.\nReuse is considered a major advantage of object orientation."}, "Object oriented programming lets programmers create procedures for\nobjects whose exact type is not known until runtime.\nFor example, a screen cursor may change its shape from an arrow to a\nline depending on the program mode.\nThe routine to move the cursor on screen in response to mouse movement can\nbe written for \"cursor\", and polymorphism lets that cursor take simulating\nsystem behaviour.\nIt can be also described as many shapes of same object.", "An abstraction denotes the essential characteristics of an object that distinguish it from all\nother kinds of object and thus provide crisply defined conceptual\nboundaries, relative to the perspective of the viewer.", "Abstraction denotes a model, a view, or some other focused representation\nfor an actual item. Its the development of a software object to represent\nan object we can find in the real world.\nEncapsulation hides the details of that implementation."]}, "footnote": [{"@auto": "1", "@ids": "id2", "@names": "1", "label": "1", "paragraph": {"reference": {"@name": "Wikipedia OO fundamental concepts", "@refuri": "https://en.wikipedia.org/wiki/Object-oriented_programming#Fundamental_features_and_concepts", "#text": "Wikipedia OO fundamental concepts"}, "target": {"@ids": "wikipedia-oo-fundamental-concepts", "@names": "wikipedia\\ oo\\ fundamental\\ concepts", "@refuri": "https://en.wikipedia.org/wiki/Object-oriented_programming#Fundamental_features_and_concepts"}}}, {"@auto": "1", "@ids": "id3", "@names": "2", "label": "2", "paragraph": {"reference": {"@name": "SOLID", "@refuri": "http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29", "#text": "SOLID"}, "target": {"@ids": "solid", "@names": "solid", "@refuri": "http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29"}, "#text": "Object oriented design"}}]}, {"@ids": "encapsulation", "@names": "encapsulation", "title": "Encapsulation", "paragraph": ["Consider the following example:", {"emphasis": ["weight", "weight"], "strong": "public", "#text": "It's clearly a bad idea to allow people to set the shipping weight to a negative value.\nHow can you change this class to prevent problems like this from happening?\nYour only choice is to make the  private and write a method that allows\nthe class to set limits on weight.  But since you have already declared \nto be , as soon as you make this 'fix', you break every class that\ncurrently uses it!"}, "The ability to change your code without breaking every class that uses it is one\nof the key benefits of encapsulation.\nBy limiting access and hiding the implementation details of your class to the maximum\nextent possible, you make it possible to change, fix, extend, or rework your class\nwithout requiring changes in any of the code that uses your class.", "How do we ensure our code remains flexible and maintainable?", "Compare our first example with the following:", "The alert among you might be thinking\n\"Hey! How is this any better than the first example?\"\nWe added a setter and getter, but added no new capability.\nWhat have we gained?", "We have gained quite a bit.\nNow we are free to change our minds about how weight values are set and retrieved.\nEven though we aren't doing anything now, we are free to change the implementation\nlater and no calling class will know.", "Good OO design demands thinking about the future.\nWhich brings us to our final example.\nNo classes would need to be modified to add the new capability below."], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}], "bullet_list": {"@bullet": "-", "list_item": [{"paragraph": {"emphasis": "private", "#text": "Keep fields hidden using a  access modifier"}}, {"paragraph": {"emphasis": "public accessor methods", "#text": "Make  and force callers to use them\nby hiding your fields."}}]}}, {"@ids": "inheritance", "@names": "inheritance", "title": "Inheritance", "paragraph": ["Consider the following example:", "When run, produces the following output:", {"emphasis": "equals", "strong": ["inherited", "Object", "Object", "equals", "hashCode", "toString"], "#text": "Where did the  method come from?\nIt was  from the class .\nIn Java (and some other languages as well), every class is a subclass of the class .\nIn Java, every class inherits methods for\n, , , and a few others."}, "Why?", {"emphasis": "interface", "#text": "The creators of the language assumed it would be very common to be able to determine\nif two objects were equal or to produce a String representation of an object.\nIf these methods were not in the Object class, then every programmer would have to\ncreate their own solution for this problem.\nMore importantly, every programmer might implement a different  for basic\nneeds currently satisfied by 'equals' and 'toString', which would complicate\nthe implementation of these common functions between developers."}, {"strong": "InputStream", "emphasis": ["InputStream", "InputStream", "FileInputStream", "BufferedInputStream", "PushbackInputStream"], "#text": "More generically, inheritance promotes code reuse.\nAn excellent example is the  class.\nThe  class is the base class (superclass) of\nall input streams in the Java IO API.\n subclasses include the , \nand the  among others."}, "Java InputStream's are used for reading data, one byte at a time, for example:", "Which creates a new FileInputStream instance.\nFileInputStream is a subclass of InputStream so it is safe to assign an instance of\nFileInputStream to an InputStream variable.", {"emphasis": ["InputStream", "InputStream"], "#text": "The  class exposes common methods which all subclasses of  inherit."}, {"emphasis": ["FileInputStream", "InputStream"], "#text": "The  class inherits all of the methods from  and offers two more:"}, {"emphasis": "AudioInputStream", "#text": "In contrast, the  class offers two completely different methods:"}, {"strong": ["IS-A", "IS-A", "IS-A"], "#text": "The above examples illustrate that both the AudioInputStream and FileInputStream objects have an\n relationship with InputStream.  That is, an AudioInputStream  InputStream\nand a FileInputStream  InputStream."}, {"strong": "IS-A", "emphasis": ["extends", "implements"], "#text": "The  relationship in Java is expressed using the keywords  for class inheritance\nand  for interface implementations."}, {"title_reference": "composition", "#text": "This is different from extending classes through ."}, "Not only does inheritance promote code reuse, but it provides a means to use\npolymorphism in our code."], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}], "block_quote": {"paragraph": "'test1' does not equal 'test2'.\n'test1' is an Object."}, "field_list": [{"field": [{"field_name": "void available()", "field_body": {"paragraph": "Returns an estimate of the number of bytes that can be\nread (or skipped over) from this input stream without blocking by the next\ninvocation of a method for this input stream."}}, {"field_name": "int close()", "field_body": {"paragraph": "Closes this input stream and releases any system resources associated with the stream."}}, {"field_name": "mark(int readlimit)", "field_body": {"paragraph": "Marks the current position in this input stream."}}, {"field_name": "boolean markSupported()", "field_body": {"paragraph": "Tests if this input stream supports the mark and reset methods."}}, {"field_name": "abstract int read()", "field_body": {"paragraph": "Reads the next byte of data from the input stream."}}, {"field_name": "int read(byte[] b)", "field_body": {"paragraph": "Reads some number of bytes from the input stream and stores them into the buffer array b."}}, {"field_name": "int read(byte[] b, int off, int len)", "field_body": {"paragraph": "Reads up to len bytes of data from the input stream into an array of bytes."}}, {"field_name": "void reset()", "field_body": {"paragraph": "Repositions this stream to the position at the time the mark method was last\ncalled on this input stream."}}, {"field_name": "long skip(long n)", "field_body": {"paragraph": "Skips over and discards n bytes of data from this input stream."}}]}, {"field": [{"field_name": "FileChannel getChannel()", "field_body": {"paragraph": "Returns the unique FileChannel object associated with this file input stream."}}, {"field_name": "FileDescriptor getFD()", "field_body": {"paragraph": "Returns the FileDescriptor object that represents the connection to the\nactual file in the file system being used by this FileInputStream."}}]}, {"field": [{"field_name": "AudioFormat getFormat()", "field_body": {"paragraph": "Obtains the audio format of the sound data in this audio input stream."}}, {"field_name": "long getFrameLength()", "field_body": {"paragraph": "Obtains the length of the stream, expressed in sample frames rather than bytes."}}]}]}, {"@ids": "polymorphism", "@names": "polymorphism", "title": "Polymorphism", "paragraph": {"title_reference": "Polymorphism", "#text": "is often referred to as the third pillar\nof object-oriented programming, after encapsulation and inheritance.\nPolymorphism is a Greek word that means \"many-shaped\" and polymorphism itself comes in\ntwo distinct forms:"}, "bullet_list": {"@bullet": "-", "list_item": [{"paragraph": [{"title_reference": "Run-time polymorphism"}, "Base classes may define and implement abstract, or virtual methods,\nand derived classes can override them, which means they provide their own\ndefinition and implementation.\nAt run-time, when client code calls the method, the type is resolved and invokes\nthat override of the virtual method.\nThus in your source code you can call a method on a base class, and cause a derived\nclass's version of the method to be executed.", "At run time, objects of a derived class may be treated as objects of a base class\nin places such as method parameters and collections or arrays.\nWhen this occurs, the object's declared type is no longer identical to its\nrun-time type.", "Note that a derived class may be treated as any type in its inheritance hierarchy.\nAlso, it is perfectly valid for an overloaded method to be overridden."]}, {"paragraph": [{"title_reference": "Compile-time polymorphism"}, {"strong": "Overloaded", "#text": "Compile-time polymorphism is simply method overloading.\n methods have the same method name but\ndifferent number of arguments or different types of arguments or both."}]}]}}, {"@ids": "run-time-polymorphism", "@names": "run-time\\ polymorphism", "title": "Run-time Polymorphism", "paragraph": [{"emphasis": "Object", "#text": "Consider our earlier discussion of the class  when we discussed encapsulation.\nWhat is the result of the following code from  pg. 74?"}, {"literal": ["equals()", "equals()"], "emphasis": "logically equivalent", "#text": "In this case, the two objects are not considered equal because they are not the same object.\nThis is the default behavior for , and it is often sufficient.\nIn cases where you need to determine whether two objects are ,\nyou override the  method."}, {"literal": "equals()", "#text": "There are many classes where it would be irritating to have  evaluate to false:"}, {"literal": ["==", "a.equals(b)"], "#text": "Recall that  always compares object references and in the above example, will identify\nthe two Integer classes as different even though  evaluates to true."}, {"literal": "toString()", "#text": "Similarly, the output of  displays the location of the object on the heap,\nwhich is not always the most intuitive string representation of your objects."}, "Compare the previous example with the following.\nWhat output does this program produce?", {"title_reference": "overrides <run-time polymorphism>", "literal": ["equals()", "toString()"], "emphasis": "Object", "#text": "The class  the definitions of  and \nproviding a more generally useful implementation than provided by the default\nimplementation in the  class."}, "The output is:"], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}], "line_block": [{"line": [{"literal": "'a' and 'b' are not equal."}, {"literal": "'a' is Complex@325e9e34"}, {"literal": "'b' is Complex@61e481c1"}]}, {"line": ["Object a = new Integer(2);", "Object b = new Integer(2);"]}, {"line": [{"literal": "'a' equals 'b'."}, {"literal": "'a' = (1.0 + 0.0i)"}, {"literal": "'b' = (1.0 + 0.0i)"}]}]}, {"@ids": "compile-time-polymorphism", "@names": "compile-time\\ polymorphism", "title": "Compile-time Polymorphism", "paragraph": ["In procedural languages without overloading, it was common to have many functions\nwith similar names to perform essentially the same task on different data types.\nThe absolute value function is a classic example.", {"literal": ["abs()", "int", "labs()", "fabs()", "*abs()"], "#text": "In C, the  function returns the absolute value of an integer.\nThe only valid parameter you can pass is an   any other type\nwill fail to compile.  How is this problem solved in C?\nWith different method names:  is used to return the absolute value\nof a long and  returns the absolute value of a float.\nThe burden is on the users of these functions  programmers\nto remember which function is needed.\nAdditionally, there is no easy way to be flexible about the generic concept\nof taking the absolute value of a number.  The burden is on the programmer\nof the various  functions to ensure the correct function is used\nwith the appropriate type."}, "Overloading is a powerful tool, but there are pitfalls.\nConsider the following snippet.\nWhat does the following program print?", "You might expect the program to print:", "It does not. Why?", {"literal": ["group", "group", "Collection<?>"], "strong": "compiler", "#text": "Because  is overloaded and the  determines which\nfunction to invoke.  For all three types the compile-time type\nof the parameter passed to  is the same: .\nThe type changes at run-time, but this has no effect on overloading."}, "Keep in mind that overriding methods is far more common in Java than\noverloading, so consider your use of overloading carefully."], "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, "line_block": {"line": [{"literal": "\"List\""}, {"literal": "\"Queue\""}, {"literal": "\"Unknown group\""}]}}, {"@ids": "abstraction", "@names": "abstraction", "title": "Abstraction", "paragraph": [{"title_reference": "procedural", "emphasis": "model", "#text": "One of the key advantages of object oriented languages over  languages is that\nobjects act as metaphors for the real-world  in other words, objects  the real world.\nIn a procedural language, tasks are executed in functions or procedures and the\ndata that the functions operate on is stored elsewhere. A better way to manage the complexity\nof large programs is to keep the data in a program and the operations allowed on that data\nin a cohesive logical unit.\nA program describing a car might perform basic tasks: steer, speed up, slow down, but also\nneeds to store information about the car: current speed, direction, cruise control setting, etc."}, {"literal": ["turnCarOn()", "turnCarOff()", "accelerate()", "steer()"], "emphasis": "car", "title_reference": "cohesion", "#text": "If you wrote your car driving program in a procedural language, you would likely require\ndifferent functions to control each of the car behaviors.\nYou might create functions for , , , ,\nand others.  You would also need variables to store the current state of the car.\nAlthough it's perfectly valid to construct such a car in a procedural language, these\nfunctions and variables we have created only exist as a whole entity, a  in the mind of\nthe programmer who created it.\nThe idea that individual units within a program each have a specific role or responsibility\nis called  and is difficult achieve in procedural programs."}, "For very large programs, which might contain hundreds or even thousands of entities,\nlack of cohesion can introduce errors, make programs more difficult to understand and maintain,\nand complicate the development of very large programs."]}]}}