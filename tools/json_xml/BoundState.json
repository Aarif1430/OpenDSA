{"document": {"@ids": "state-space-lower-bounds-proofs", "@names": "state\\ space\\ lower\\ bounds\\ proofs", "@source": "<string>", "@title": "State Space Lower Bounds Proofs", "title": "State Space Lower Bounds Proofs", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}], "paragraph": [{"math": ["2n-2", "n-1", "n-2", "2n-3"], "#text": "We now consider the problem of finding both the minimum and the\nmaximum from an (unsorted) list of values.\nThis might be useful if we want to know the range of a collection of\nvalues to be plotted, for the purpose of drawing the plot's scales.\nOf course we could find them independently in \ncomparisons.\nA slight modification is to find the maximum in \ncomparisons, remove it from the list, and then find the minimum in\n further comparisons for a total of \ncomparisons.\nCan we do better than this?"}, "Before continuing, think a moment about how this problem of finding\nthe minimum and the maximum compares to the problem of the last\nsection, that of finding the second biggest value\n(and by implication, the maximum).\nWhich of these two problems do you think is harder?\nIt is probably not at all obvious to you that one problem is harder or\neasier than the other.\nThere is intuition that argues for either case.\nOn the one hand intuition might argue that the process of finding the\nmaximum should tell you something about the second biggest value, more\nthan that process should tell you about the minimum value.\nOn the other hand, any given comparison tells you something about\nwhich of two can be a candidate for maximum value, and which can be a\ncandidate for minimum value, thus making progress in both directions.", "We will start by considering a simple divide-and-conquer approach to\nfinding the minimum and maximum.\nSplit the list into two parts and find the minimum and\nmaximum elements in each part.\nThen compare the two minimums and maximums to each other with a\nfurther two comparisons to get the final result.\nThe algorithm is as follows:", "The cost of this algorithm can be modeled by the following recurrence.", {"math": ["3n/2 - 2", "n = 2^i", "n=2^1 \\pm 1", "5n/3 - 2", "n = 3 \\times 2^i"], "#text": "This is a rather interesting recurrence, and its\nsolution ranges between \n(when  or )\nand  (when ).\nWe can infer from this behavior that how we divide the list affects\nthe performance of the algorithm.\nFor example, what if we have six items in the list?\nIf we break the list into two sublists of three elements, the cost\nwould be 8.\nIf we break the list into a sublist of size two and another of size\nfour, then the cost would only be 7."}, {"math": "n", "#text": "With divide and conquer, the best algorithm is the one that minimizes\nthe work, not necessarily the one that balances the input sizes.\nOne lesson to learn from this example is that it can be important to\npay attention to what happens for small sizes of , because\nany division of the list will eventually produce many small lists."}, "We can model all possible divide-and-conquer strategies for this\nproblem with the following recurrence.", "That is, we want to find a way to break up the list that will minimize\nthe total work.\nIf we examine various ways of breaking up small lists, we will\neventually recognize that breaking the list into a sublist of size 2\nand a sublist of size (n-2) will always produce results as good as\nany other division.\nThis strategy yields the following recurrence.", {"math": "\\mathbf{T}(n) = \\lceil 3n/2 \\rceil - 2", "#text": "This recurrence (and the corresponding algorithm) yields\n comparisons.\nIs this optimal?\nWe now introduce yet another tool to our collection of lower bounds\nproof techniques: The state space proof."}, {"title_reference": "state", "#text": "We will model our algorithm by defining a  that the\nalgorithm must be in at any given instant.\nWe can then define the start state, the end state, and the\ntransitions between states that any algorithm can support.\nFrom this, we will reason about the minimum number of states that the\nalgorithm must go through to get from the start to the end, to reach\na state space lower bound."}, "At any given instant, we can track the following four categories of\nelements:", {"math": ["(U, W, L, M)", "n", "(n, 0, 0, 0)", "(0, 1, 1, n-2)", "(n, 0, 0, 0)", "(0, 1, 1, n-2)"], "#text": "We define the current state to be a vector of four values,\n for untested, winners, losers, and middles,\nrespectively.\nFor a set of  elements, the initial state of the algorithm is\n and the end state is .\nThus, every run for any algorithm must go from\nstate  to state .\nWe also observe that once an element is identified to be a middle,\nit can then be ignored because it can neither be the minimum nor the\nmaximum."}, {"math": "(i, j, k, l)", "#text": "Given that there are four types of elements, there are 10 types of\ncomparison.\nComparing with a middle cannot be more efficient than other\ncomparisons, so we should ignore those, leaving six comparisons of\ninterest.\nWe can enumerate the effects of each comparison type as follows.\nIf we are in state  and we have a comparison, then\nthe state changes are as follows."}, "Now, let us consider what an adversary will do for the various\ncomparisons.\nThe adversary will make sure that each comparison does the least\npossible amount of work in taking the algorithm toward the goal\nstate.\nFor example, comparing a winner to a loser is of no value because the\nworst case result is always to learn nothing new (the winner remains a\nwinner and the loser remains a loser).\nThus, only the following five transitions are of interest:", {"math": ["n-2", "\\lceil n/2 \\rceil", "n + \\lceil n/2 \\rceil - 2"], "#text": "Only the last two transition types increase the number of middles,\nso there must be  of these.\nThe number of untested elements  must go to 0, and the first\ntransition is the most efficient way to do this.\nThus,  of these are required.\nOur conclusion is that the minimum possible number of transitions\n(comparisons) is .\nThus, our algorithm is optimal."}], "math_block": [{"@xml:space": "preserve", "#text": "\\mathbf{T}(n) = \\left\\{\\begin{array}{ll}\n             0       & n = 1\\\\\n             1       & n = 2\\\\\n             {\\bf T}(\\lfloor n/2 \\rfloor) + {\\bf T}(\\lceil n/2\n             \\rceil) + 2    & n > 2\n            \\end{array}\n     \\right."}, {"@xml:space": "preserve", "#text": "\\mathbf{T}(n) = \\left\\{\n\\begin{array}{ll}\n0&n=1\\\\\n1&n=2\\\\\n\\min_{1\\leq k\\leq n-1} \\{{\\bf T}(k) + {\\bf T}(n-k)\\} + 2&n>2\n\\end{array}\\right."}, {"@xml:space": "preserve", "#text": "\\mathbf{T}(n) = \\left\\{\n\\begin{array}{ll}\n0&n=1\\\\\n1&n=2\\\\\n{\\bf T}(n-2) + 3&n>2\n\\end{array}\\right."}, {"@xml:space": "preserve", "#text": "\\begin{array}{lllll}\nU:U&(i-2,&j+1,&k+1,&l)\\\\\nW:W&(i,&j-1,&k,&l+1)\\\\\nL:L&(i,&j,&k-1,&l+1)\\\\\nL:U&(i-1,&j+1,&k,&l)\\\\\n\\quad or&(i-1,&j,&k,&l+1)\\\\\nW:U&(i-1,&j,&k+1,&l)\\\\\n\\quad or&(i-1,&j,&k,&l+1)\\\\\nW:L&(i,&j,&k,&l)\\\\\n\\quad or&(i,&j-1,&k-1,&l+2)\n\\end{array}"}, {"@xml:space": "preserve", "#text": "\\begin{array}{lllll}\nU:U&(i-2,&j+1,&k+1,&l)\\\\\nL:U&(i-1,&j+1,&k,&l)\\\\\nW:U&(i-1,&j,&k+1,&l)\\\\\n\\hline\nW:W&(i,&j-1,&k,&l+1)\\\\\nL:L&(i,&j,&k-1,&l+1)\n\\end{array}"}], "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "Untested: Elements that have not been tested."}, {"paragraph": "Winners: Elements that have won at least once, and never lost."}, {"paragraph": "Losers: Elements that have lost at least once, and never won."}, {"paragraph": "Middle: Elements that have both won and lost at least once."}]}}}