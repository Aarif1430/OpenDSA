{"document": {"@dupnames": "general\\ trees", "@ids": "general-trees", "@source": "<string>", "@title": "General Trees", "title": "General Trees", "subtitle": {"@dupnames": "general\\ trees", "@ids": "id1", "#text": "General Trees"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/General/GenTreeCON.css"}], "paragraph": ["Many organizations are hierarchical in nature, such as the military\nand most businesses.\nConsider a company with a president and some number of vice presidents\nwho report to the president.\nEach vice president has some number of direct subordinates, and so on.\nIf we wanted to model this company with a data structure,\nit would be natural to think of the president\nin the root node of a tree, the vice presidents at level 1, and their\nsubordinates at lower levels in the tree as we go\ndown the organizational hierarchy.", {"title_reference": "general tree", "#text": "Because the number of vice presidents is likely to be more than two,\nthis company's organization cannot easily be represented by a\nbinary tree.\nWe need instead to use a tree whose nodes have an arbitrary\nnumber of children.\nUnfortunately, when we permit trees to have nodes with an arbitrary\nnumber of children, they become much harder to implement than binary\ntrees.\nWe consider such trees in this chapter.\nTo distinguish them from binary trees,\nwe use the term ."}, "In this module we will examine general tree terminology and define a\nbasic ADT for general trees."], "section": [{"@ids": "general-tree-definitions-and-terminology", "@names": "general\\ tree\\ definitions\\ and\\ terminology", "title": "General Tree Definitions and Terminology", "paragraph": [{"title_reference": ["tree", "subtrees <subtree>", "out degree", "forest", "Figure #GenTreeFig"], "math": ["\\mathbf{T}", "R", "\\mathbf{T}", "(\\mathbf{T} -\\{R\\})", "n > 0", "\\mathbf{T}_0", "\\mathbf{T}_1", "\\mathbf{T}_{n-1}", "R_1, R_2, ..., R_n", "R", "\\mathbf{T}_i (0 \\leq i < n)", "\\mathbf{T}", "\\mathbf{T}_i", "\\mathbf{T}_j", "i < j", "\\mathbf{T}_0", "R"], "#text": "A   is a finite set of one or more nodes\nsuch that there is one designated node , called the root\nof .\nIf the set  is not empty, these nodes are\npartitioned into  disjoint sets ,\n, ..., , each of which is\na tree, and whose roots ,\nrespectively, are children of .\nThe subsets  are said to be\n of .\nThese subtrees are ordered in that  is said to\ncome before  if .\nBy convention, the subtrees are arranged from left to right with\nsubtree  called the leftmost child of .\nA node's  is the number of children for that node.\nA  is a collection of one or more trees.\nFigure  presents further tree notation\ngeneralized from the notation for binary trees."}, {"math": ["n", "n-1"], "#text": "Each node in a tree has precisely one parent, except for the root,\nwhich has no parent.\nFrom this observation, it immediately follows that a tree with\n nodes must have  edges because each node, aside\nfrom the root, has one edge connecting that node to its parent."}], "target": {"@refid": "gentreefig"}, "raw": {"@format": "xml", "@ids": "gentreefig", "@names": "gentreefig", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "GenTreeCON", "@long_name": "GenTreeCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}}, {"@ids": "an-adt-for-general-tree-nodes", "@names": "an\\ adt\\ for\\ general\\ tree\\ nodes", "title": "An ADT for General Tree Nodes", "paragraph": ["Before discussing general tree implementations, we should first make\nprecise what operations such implementations must support.\nAny implementation must be able to initialize a tree.\nGiven a tree, we need access to the root of that tree.\nThere must be some way to access the children of a node.\nIn the case of the ADT for binary tree nodes, this was done by\nproviding member functions that give explicit access to the left and\nright child pointers.\nUnfortunately, because we do not know in advance how many children a\ngiven node will have in the general tree, we cannot give explicit\nfunctions to access each child.\nAn alternative must be found that works for an unknown number of\nchildren.", "One choice would be to provide a function that takes as its parameter\nthe index for the desired child.\nThat combined with a function that returns the number of children for\na given node would support the ability to access any node or process\nall children of a node.\nUnfortunately, this view of access tends to bias the\nchoice for node implementations in favor of an array-based approach,\nbecause these functions favor random access to a list of children.\nIn practice, an implementation based on a linked list is often\npreferred.", {"literal": "null", "#text": "An alternative is to provide access to the first (or leftmost) child\nof a node, and to provide access to the next (or right) sibling of a\nnode.\nHere are the class declarations for general trees and\ntheir nodes.\nBased on these two access functions, the children of a node can be\ntraversed like a list.\nTrying to find the next sibling of the rightmost sibling would return\n."}], "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}}, {"@ids": "general-tree-traversals", "@names": "general\\ tree\\ traversals", "title": "General Tree Traversals", "paragraph": [{"title_reference": ["tree traversals <tree traversal> <BinaryTreeTraversal>", "binary trees <binary tree>", "preorder <preorder traversal>", "postorder <postorder traversal>", "inorder <inorder traversal>"], "#text": "There are three traditional\n\nfor :\n,\n,\nand .\nFor general trees, preorder and postorder traversals are defined with\nmeanings similar to their binary tree\ncounterparts.\nPreorder traversal of a general tree first visits the root of the\ntree, then performs a preorder traversal of each subtree from left to\nright.\nA postorder traversal of a general tree performs a postorder traversal\nof the root's subtrees from left to right, then visits the root.\nInorder traversal does not have a natural definition for the\ngeneral tree, because there is no particular number of children for an\ninternal node.\nAn arbitrary definition  such as visit the leftmost subtree in\ninorder, then the root, then visit the remaining subtrees in inorder\ncan be invented.\nHowever, inorder traversals are generally not useful with\ngeneral trees."}, {"math": ["R", "T", "T", "T"], "#text": "To perform a preorder traversal, it is necessary to visit each of the\nchildren for a given node (say ) from left to right.\nThis is accomplished by starting at R's leftmost child\n(call it ).\nFrom , we can move to 's right sibling, and then\nto that node's right sibling, and so on."}, {"math": ["R", "T", "T", "T"], "#text": "To perform a preorder traversal, it is necessary to visit each of the\nchildren for a given node (say ) from left to right.\nThis is accomplished by starting at R's leftmost child\n(call it ).\nFrom , we can move to 's right sibling, and then\nto that node's right sibling, and so on."}, {"title_reference": "while", "literal": ["next", "null"], "#text": "Using the General Tree ADT show above, here is an\nimplementation to print the nodes of a general tree in\npreorder.\nNote the  loop at the end, which processes the list of\nchildren by beginning with the leftmost child, then repeatedly moving\nto the next child until calling  returns ."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "GenTreePreTravCON", "@long_name": "GenTreePreTravCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "GenTreePostTravCON", "@long_name": "GenTreePostTravCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/General/GenTreeCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/General/GenTreePreTravCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/General/GenTreePostTravCON.js"}]}]}}