<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="finding-the-i-th-best-element" names="finding\ the\ i\ th\ best\ element" source="&lt;string&gt;" title="Finding the i th Best Element"><title>Finding the <math>i</math> th Best Element</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>We now tackle the problem of finding the <math>i</math> th best element in
a list.
One solution is to sort the list and simply look
in the <math>i</math> th position.
However, this process provides considerably more information than we
need to solve the problem.
The minimum amount of information that we actually need to know can be
visualized as shown in Figure <title_reference>Figure #MedPoset</title_reference>.
That is, all we need to know is the <math>i-1</math> items less than our
desired value, and the <math>n-i</math> items greater.
We do not care about the relative order within the upper and lower
groups.
So can we find the required information faster than by first sorting?
Looking at the lower bound, can we tighten that beyond the
trivial lower bound of <math>n</math> comparisons?
We will focus on the specific question of finding the median element
(i.e., the element with rank <math>n/2</math>), because the resulting
algorithm can easily be modified to find the <math>i</math> th largest
value for any <math>i</math>.</paragraph><comment xml:space="preserve">_ MedPoset:</comment><raw format="xml" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>Looking at the Quicksort algorithm might give us some insight into
solving the median problem.
Recall that Quicksort works by selecting a pivot value, partitioning
the array into those elements less than the pivot and those greater
than the pivot, and moving the pivot to its proper location in the
array.
If the pivot is in position <math>i</math>, then we are done.
If not, we can solve the subproblem recursively by only considering
one of the sublists.
That is, if the pivot ends up in position <math>k &gt; i</math>, then we
simply solve by finding the <math>i</math> th best element in the left
partition.
If the pivot is at position <math>k &lt; i</math>, then we wish to find the
<math>i-k</math> th element in the right partition.</paragraph><paragraph>What is the worst case cost of this algorithm?
As with Quicksort, we get bad performance if the pivot is the first or
last element in the array.
This would lead to possibly <math>O(n^2)</math> performance.
However, if the pivot were to always cut the array in half, then our
cost would be modeled by the recurrence
<math>\mathbf{T}(n) = \mathbf{T}(n/2) + n = 2n</math> or <math>O(n)</math>
cost.</paragraph><paragraph>Finding the average cost requires us to use a recurrence with full
history, similar to the one we used to model the cost of Quicksort.
If we do this, we will find that <math>\mathbf{T}n</math> is in
<math>O(n)</math> in the average case.</paragraph><paragraph>Is it possible to modify our algorithm to get worst-case linear time?
To do this, we need to pick a pivot that is guaranteed to discard a
fixed fraction of the elements.
We cannot just choose a pivot at random, because doing so will not meet
this guarantee.
The ideal situation would be if we could pick the median value for the
pivot each time.
But that is essentially the same problem that we are trying to solve
to begin with.</paragraph><paragraph>Notice, however, that if we choose any constant <math>c</math>,
and then if we pick the median from a sample of size <math>n/c</math>,
then we can guarantee that we will discard at least <math>n/2c</math>
elements.
Actually, we can do better than this by selecting small subsets of a
constant size (so we can find the median of each in constant time),
and then taking the median of these medians.
Figure <title_reference>Figure #Median</title_reference> illustrates this idea.</paragraph><target refid="median"></target><raw format="xml" ids="median" names="median" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>This observation leads directly to the following algorithm.</paragraph><bullet_list bullet="*"><list_item><paragraph>Choose the <math>n/5</math> medians for groups of five elements from the
list. Choosing the median of five items can be done in constant time.</paragraph></list_item><list_item><paragraph>Recursively, select <math>M</math>, the median of the <math>n/5</math>
medians-of-fives.</paragraph></list_item><list_item><paragraph>Partition the list into those elements larger and smaller than
<math>M</math>.</paragraph></list_item></bullet_list><paragraph>While selecting the median in this way is guaranteed to eliminate a
fraction of the elements
(leaving at most <math>\lceil (7n - 5)/10\rceil</math> elements left),
we still need to be sure that our recursion yields a linear-time
algorithm.
We model the algorithm by the following recurrence.</paragraph><math_block xml:space="preserve">{\bf T}(n) \leq {\bf T}(\lceil n/5 \rceil) +
{\bf T}(\lceil (7n - 5)/10\rceil) + 6\lceil n/5 \rceil + n - 1.</math_block><paragraph>The <math>\mathbf{T}(\lceil n/5 \rceil)</math> term comes from computing
the median of the medians-of-fives,
the <math>6\lceil n/5 \rceil</math> term comes from the cost to calculate
the median-of-fives (exactly six comparisons for each group of five
element),
and the <math>\mathbf{T}(\lceil (7n - 5)/10\rceil)</math> term comes from
the recursive call of the remaining (up to) 70% of the elements that
might be left.</paragraph><paragraph>We will prove that this recurrence is linear using the process of
<title_reference>constructive induction</title_reference>.
We assume that it is linear for some constant <math>r</math>, and then show
that <math>\textbf{T}(n) \leq rn</math> for all <math>n</math> greater than some
bound.</paragraph><math_block xml:space="preserve">\begin{eqnarray*}
\mathbf{T}(n) &amp;\leq&amp; {\bf T}(\lceil \frac{n}{5} \rceil) +
        \mathbf{T}(\lceil \frac{7n - 5}{10}\rceil) +
        6\lceil \frac{n}{5} \rceil + n - 1\\
&amp;\leq&amp;r(\frac{n}{5} + 1) + r(\frac{7n-5}{10} + 1) + 6(\frac{n}{5} + 1) + n - 1\\
&amp;\leq&amp;(\frac{r}{5} + \frac{7r}{10} + \frac{11}{5})n + \frac{3r}{2} + 5\\
&amp;\leq&amp;\frac{9r + 22}{10}n + \frac{3r + 10}{2}.
\end{eqnarray*}</math_block><paragraph>This is true for <math>r \geq 23</math> and <math>n \geq 380</math>.
This provides a base case that allows us to use induction to prove
that <math>\forall n \geq 380, \mathbf{T}(n) \leq 23n</math>.</paragraph><paragraph>In reality, this algorithm is not practical
because its constant factor costs are so high.
So much work is being done to guarantee linear time performance that
it is more efficient on average to rely on chance to select the pivot,
perhaps by picking it at random or picking the middle value out of the
current subarray.</paragraph></document>