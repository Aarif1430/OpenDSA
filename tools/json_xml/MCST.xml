<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="minimal\ cost\ spanning\ trees" ids="minimal-cost-spanning-trees" source="&lt;string&gt;" title="Minimal Cost Spanning Trees"><title>Minimal Cost Spanning Trees</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><section dupnames="minimal\ cost\ spanning\ trees" ids="id1"><title>Minimal Cost Spanning Trees</title><paragraph>The <title_reference>minimal-cost spanning tree</title_reference> (MCST)
problem takes as input a connected, undirected graph
<title_reference>mathbf{G}</title_reference>, where each edge has a distance or weight measure
attached.
The MCST is the graph containing the vertices of <title_reference>mathbf{G}</title_reference>
along with the subset of <title_reference>mathbf{G}</title_reference> 's edges that
(1) has minimum total cost as measured by summing the values for all
of the edges in the subset, and
(2) keeps the vertices connected.
Applications where a solution to this problem is
useful include soldering the shortest set of wires needed to connect a
set of terminals on a circuit board, and connecting a set of cities by
telephone lines in such a way as to require the least amount of cable.</paragraph><paragraph>The MCST contains no cycles.
If a proposed MCST did have a cycle, a cheaper MCST could be
had by removing any one of the edges in the cycle.
Thus, the MCST is a free tree with <title_reference>|mathbf{V}| - 1</title_reference> edges.
The name "minimum-cost spanning tree" comes from the fact that the
required set of edges forms a tree, it spans the vertices (i.e., it
connects them together), and it has minimum cost.
Figure <title_reference>Figure #MCSTdgm</title_reference> shows the MCST for an example graph.</paragraph><target refid="mcstdgm"></target><raw format="xml" ids="mcstdgm" names="mcstdgm" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="MCSTCON"
    long_name="MCSTCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw></section><section ids="prim-s-algorithm" names="prim's\ algorithm"><title>Prim's Algorithm</title><paragraph>The first of our two algorithms for finding MCSTs is commonly
referred to as <title_reference>Prim's algorithm</title_reference>.
Prim's algorithm is very simple.
Start with any Vertex <title_reference>N</title_reference> in the graph, setting the MCST
to be <title_reference>N</title_reference> initially.
Pick the least-cost edge connected to <title_reference>N</title_reference>.
This edge connects <title_reference>N</title_reference> to another vertex; call this <title_reference>M</title_reference>.
Add Vertex <title_reference>M</title_reference> and Edge <title_reference>(N, M)</title_reference> to the MCST.
Next, pick the least-cost edge coming from either <title_reference>N</title_reference> or
<title_reference>M</title_reference> to any other vertex in the graph.
Add this edge and the new vertex it reaches to the MCST.
This process continues, at each step expanding the MCST by selecting
the least-cost edge from a vertex currently in the MCST to a vertex
not currently in the MCST.</paragraph><paragraph>Prim's algorithm is quite similar to Dijkstra's algorithm for finding
the single-source shortest
paths.
The primary difference is that we are seeking not the next closest
vertex to the start vertex, but rather the next closest vertex to any
vertex currently in the MCST.
Thus we replace the lines:</paragraph><literal_block xml:space="preserve">if (D[w] &gt; (D[v] + G.weight(v, w)))
  D[w] = D[v] + G.weight(v, w);</literal_block><paragraph>in Djikstra's algorithm with the lines:</paragraph><literal_block xml:space="preserve">if (D[w] &gt; G.weight(v, w))
  D[w] = G.weight(v, w);</literal_block><paragraph>in Prim's algorithm.</paragraph><paragraph>The following code shows an implementation for Prim's algorithm
that searches the distance matrix for the next closest vertex.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>For each vertex <title_reference>I</title_reference>, when <title_reference>I</title_reference> is processed by Prim's
algorithm, an edge going to <title_reference>I</title_reference> is added to the MCST that we are
building.
Array <literal>V[I]</literal> stores the previously visited vertex that is
closest to Vertex <title_reference>I</title_reference>.
This information lets us know which edge goes into the MCST when
Vertex <title_reference>I</title_reference> is processed.
The implementation above also contains calls to
<literal>AddEdgetoMST</literal> to indicate which edges are actually added to the
MCST.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="PrimAV"
    long_name="PrimAV"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><section ids="prim-s-algorithm-alternative-implementation" names="prim's\ algorithm\ alternative\ implementation"><title>Prim's Algorithm Alternative Implementation</title><paragraph>Alternatively, we can implement Prim's algorithm using a
<title_reference>priority queue</title_reference> to find the next closest vertex, as
shown next.
As with the priority queue version of Dijkstra's algorithm,
the <title_reference>heap</title_reference> stores <literal>DijkElem</literal> objects.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>Here is an AV that lets you try Prim's algorithm on other graphs.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="PrimAVPQ"
    long_name="PrimAVPQ"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>Prim's algorithm is an example of a greedy
algorithm.
At each step in the <literal>for</literal> loop, we select the least-cost edge that
connects some marked vertex to some unmarked vertex.
The algorithm does not otherwise check that the MCST really should
include this least-cost edge.
This leads to an important question:
Does Prim's algorithm work correctly?
Clearly it generates a spanning tree (because each pass through the
<literal>for</literal> loop adds one edge and one unmarked vertex to the spanning tree
until all vertices have been added), but does this tree have minimum
cost?</paragraph><block_quote><paragraph><strong>Theorem:</strong> Prim's algorithm produces a minimum-cost spanning tree.</paragraph><paragraph><strong>Proof:</strong> We will use a proof by contradiction.
Let <title_reference>mathbf{G} = (mathbf{V}, mathbf{E})</title_reference> be a graph for which
Prim's algorithm does <emphasis>not</emphasis> generate an MCST.
Define an ordering on the vertices according to the order in which
they were added by Prim's algorithm to the MCST:
<title_reference>v_0, v_1, ..., v_{n-1}</title_reference>.
Let edge <title_reference>e_i</title_reference> connect <title_reference>(v_x, v_i)</title_reference> for
some <title_reference>x &lt; i</title_reference> and <title_reference>i leq 1</title_reference>.
Let <title_reference>e_j</title_reference> be the lowest numbered (first) edge added
by Prim's algorithm such that the set of edges selected so
far <emphasis>cannot</emphasis> be extended to form an MCST for <title_reference>mathbf{G}</title_reference>.
In other words, <title_reference>e_j</title_reference> is the first edge where Prim's algorithm
"went wrong."
Let <title_reference>mathbf{T}</title_reference> be the "true" MCST.
Call <title_reference>v_p (p&lt;j)</title_reference> the vertex connected by edge
<title_reference>e_j</title_reference>, that is, <title_reference>e_j = (v_p, v_j)</title_reference>.</paragraph><paragraph>Because <title_reference>mathbf{T}</title_reference> is a tree, there exists some path in
<title_reference>mathbf{T}</title_reference> connecting <title_reference>v_p</title_reference> and <title_reference>v_j</title_reference>.
There must be some edge <title_reference>e'</title_reference> in this path connecting vertices
<title_reference>v_u</title_reference> and <title_reference>v_w</title_reference>, with <title_reference>u &lt; j</title_reference> and <title_reference>w geq j</title_reference>.
Because <title_reference>e_j</title_reference> is not part of <title_reference>mathbf{T}</title_reference>, adding edge
<title_reference>e_j</title_reference> to <title_reference>mathbf{T}</title_reference> forms a cycle.
Edge <title_reference>e'</title_reference> must be of lower cost than
edge <title_reference>e_j</title_reference>, because Prim's algorithm did not generate an MCST.
This situation is illustrated in Figure <title_reference>Figure #PrimProof</title_reference>.
However, Prim's algorithm would have selected the least-cost edge
available.
It would have selected <title_reference>e'</title_reference>, not <title_reference>e_j</title_reference>.
Thus, it is a contradiction that Prim's algorithm would have selected
the wrong edge, and thus, Prim's algorithm must be correct. BOX HERE</paragraph></block_quote><target refid="primproof"></target><raw format="xml" ids="primproof" names="primproof" xml:space="preserve"><odsafig>null</odsafig></raw><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="PrimAVPE"
    long_name="PrimAVPE"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Graph/MCSTCON.js</odsascript></raw></section></section></document>