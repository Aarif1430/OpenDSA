<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.2a -->
<document dupnames="binary\ tree\ traversals" ids="binary-tree-traversals" source="&lt;string&gt;" title="Binary Tree Traversals"><title>Binary Tree Traversals</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Binary/BinExampCON.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Binary/BTCON.css</odsalink></raw><section dupnames="binary\ tree\ traversals" ids="id1"><title>Binary Tree Traversals</title><paragraph>Often we wish to process a binary tree by "visiting" each of its
nodes, each time performing a specific action such as printing the
contents of the node.
Any process for visiting all of the nodes in some order is
called a <title_reference>traversal</title_reference>.
Any traversal that lists every node in the tree exactly once is
called an <title_reference>enumeration</title_reference> of the tree's nodes.
Some applications do not require that the nodes be visited in any
particular order as long as each node is visited precisely once.
For other applications, nodes must be visited in an order that
preserves some relationship.</paragraph><section ids="preorder-traversal" names="preorder\ traversal"><title>Preorder Traversal</title><paragraph>For example, we might wish to make sure that we visit any given node
<emphasis>before</emphasis> we visit its children.
This is called a <title_reference>preorder traversal</title_reference>.</paragraph><target refid="bintravexample"></target><raw format="xml" ids="bintravexample" names="bintravexample" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="BinExampCON"
    long_name="BinExampCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><topic><title>Example</title><paragraph>The preorder enumeration for the tree of
Figure <title_reference>Figure #BinTravExample</title_reference> is
<strong>A B D C E G F H I</strong>.</paragraph><paragraph>The first node printed is the root.
Then all nodes of the left subtree are printed (in preorder) before
any node of the right subtree.</paragraph></topic><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="preorderCON"
    long_name="preorderCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></section><section ids="postorder-traversal" names="postorder\ traversal"><title>Postorder Traversal</title><paragraph>Alternatively, we might wish to visit each node only
<emphasis>after</emphasis> we visit its children (and their subtrees).
For example, this would be necessary if we wish to return all nodes
in the tree to free store.
We would like to delete the children of a node before deleting the
node itself.
But to do that requires that the children's children be deleted
first, and so on.
This is called a <title_reference>postorder traversal</title_reference>.</paragraph><topic><title>Example</title><paragraph>The postorder enumeration for the tree of
Figure <title_reference>Figure #BinTravExample</title_reference> is
<strong>D B G E H I F C A</strong>.</paragraph></topic><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="postorderCON"
    long_name="postorderCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></section><section ids="inorder-traversal" names="inorder\ traversal"><title>Inorder Traversal</title><paragraph>An <title_reference>inorder traversal</title_reference> first visits the left child
(including its entire subtree), then visits the node, and finally
visits the right child (including its entire
subtree).
The <title_reference>binary search tree &lt;binary search tree&gt; &lt;BST&gt;</title_reference> makes use of
this traversal to print all nodes in ascending order of value.</paragraph><topic><title>Example</title><paragraph>The inorder enumeration for the tree of
Figure <title_reference>Figure #BinTravExample</title_reference> is
<strong>B D A G E C H F I</strong>.</paragraph></topic><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="inorderCON"
    long_name="inorderCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></section></section><section ids="implementation" names="implementation"><title>Implementation</title><paragraph>Now we will discuss some implementations for the traversals, but we
need to define a node ADT to work with.
Just as a linked list is composed of a collection of link objects, a
tree is composed of a collection of node objects.
Here is an ADT for binary tree nodes, called <literal>BinNode</literal>.
This class will be used by some of the binary tree structures
presented later.
Member functions are provided that set or return the element value,
return a pointer to the left child,
return a pointer to the right child,
or indicate whether the node is a leaf.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>A traversal routine is naturally written as a recursive
function.
Its input parameter is a pointer to a node which we will call
<literal>rt</literal> because each node can be viewed as the root of a some
subtree.
The initial call to the traversal function passes in a pointer to the
root node of the tree.
The traversal function visits <literal>rt</literal> and its children (if any)
in the desired order.
For example, a preorder traversal specifies that <literal>rt</literal> be
visited before its children.
This can easily be implemented as follows.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>Function <literal>preorder</literal> first checks that the tree is not
empty (if it is, then the traversal is done and <literal>preorder</literal>
simply returns).
Otherwise, <literal>preorder</literal> makes  a call to <literal>visit</literal>,
which processes the root node (i.e., prints the value or performs
whatever computation as required by the application).
Function <literal>preorder</literal> is then called recursively on the left
subtree, which will visit all nodes in that subtree.
Finally, <literal>preorder</literal> is called on the right subtree,
visiting all nodes in the right subtree.
Postorder and inorder traversals are similar.
They simply change the order in which the node and its children are
visited, as appropriate.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="btTravInorderPRO"
    long_name="btTravInorderPRO"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw></section><section ids="postorder-traversal-practice" names="postorder\ traversal\ practice"><title>Postorder Traversal Practice</title><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="btTravPostorderPRO"
    long_name="btTravPostorderPRO"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw></section><section ids="preorder-traversal-practice" names="preorder\ traversal\ practice"><title>Preorder Traversal Practice</title><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="btTravPreorderPRO"
    long_name="btTravPreorderPRO"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw></section><section ids="summary-questions" names="summary\ questions"><title>Summary Questions</title><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="TravSumm"
    long_name="TravSumm"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/BinExampCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/inorderCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/preorderCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Binary/postorderCON.js</odsascript></raw></section></document>