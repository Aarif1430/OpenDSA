{"document": {"@ids": "searching-in-an-array", "@names": "searching\\ in\\ an\\ array", "@source": "<string>", "@title": "Searching in an Array", "title": "Searching in an Array", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Searching/binarySearchCON.css"}], "section": [{"@ids": "sequential-search", "@names": "sequential\\ search", "title": "Sequential Search", "paragraph": [{"title_reference": ["n", "sequential search", "successful search", "unsuccessful search"], "#text": "If you want to find the position in an unsorted array of \nintegers that stores a particular value, you cannot really do better\nthan simply looking through the array from the beginning and move\ntoward the end until you find what you are looking for.\nThis algorithm is called .\nIf you do find it, we call this a .\nIf the value is not in the array, eventually you will reach the end.\nWe will call this an .\nHere is a simple implementation for sequential search."}, {"title_reference": ["algorithm analysis", "i", "i", "n", "n", "worst case", "n", "linear cost <linear growth rate>", "linear search"], "#text": "It is natural to ask how long a program or algorithm will take to\nrun.\nBut we do not really care exactly how long a particular program will\nrun on a particular computer.\nWe just want some sort of estimate that will let us compare one\napproach to solving a problem with another.\nThis is the basic idea of .\nIn the case of sequential search, it is easy to see that if the value\nis in position  of the array, then sequential search will\nlook at  values to find it.\nIf the value is not in the array at all, then we must look at\n values if the array holds  values.\nThis would be called the  for sequential search.\nSince the amount of work is proportional to ,\nwe say that the worst case for sequential search has\n.\nFor this reason, the sequential search algorithm is sometimes\ncalled ."}], "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}}, {"@ids": "binary-search", "@names": "binary\\ search", "title": "Binary Search", "paragraph": [{"title_reference": "binary search", "#text": "Sequential search is the best that we can do when trying to find a\nvalue in an unsorted array.\nBut if the array is sorted in increasing order by value, then we can\ndo much better.\nWe use a process called ."}, {"title_reference": ["mid", "k_{mid}", "k_{mid} = K", "k_{mid} > K", "K", "mid", "k_{mid} < K", "mid", "K", "K"], "#text": "Binary search begins by examining the value in the middle\nposition of the array; call this position  and the\ncorresponding value .\nIf , then processing can stop immediately.\nThis is unlikely to be the case, however.\nFortunately, knowing the middle value provides useful information\nthat can help guide the search process.\nIn particular, if , then you know that the value\n cannot appear in the array at any position greater\nthan .\nThus, you can eliminate future search in the upper half of the array.\nConversely, if , then you know that you can\nignore all positions in the array less than .\nEither way, half of the positions are eliminated from further\nconsideration.\nBinary search next looks at the middle position in that part of the\narray where value  may exist.\nThe value at this position again allows us to eliminate half\nof the remaining positions from consideration.\nThis process repeats until either the desired value is found, or\nthere are no positions remaining in the array that might contain the\nvalue .\nHere is an illustration of the binary search method."}, {"title_reference": ["n", "log n", "n", "log n"], "#text": "With the right math techniques, it is not too hard to show that the\ncost of binary search on an array of  values is at most\n.\nThis is because we are repeatedly splitting the size of the subarray\nthat we must look at in half.\nWe stop (in the worst case) when we reach a subarray of size 1.\nAnd we can only cut the value of  in half \ntimes before we reach 1."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "binarySearchCON", "@long_name": "binarySearchCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "binarySearchPRO", "@long_name": "binarySearchPRO", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Searching/binarySearchCON.js"}], "footnote": [{"@auto": "1", "@ids": "id1", "@names": "1", "label": "1", "paragraph": {"title_reference": ["lower bounds proof <lower bounds proof> <BoundLower>", "algorithm", "problem"], "#text": "It seems to be really \"obvious\" that sequential search is the\nbest that you can do on an unsorted array.\nBut writing a convincing proof that no algorithm could ever be\ndiscovered that is better is surprisingly difficult.\nThis is an example of a\n to\nfind the cost for the beest possible  to solve\nthe  of search in an unsorted array."}}, {"@auto": "1", "@ids": "id2", "@names": "2", "label": "2", "paragraph": {"title_reference": "prove <Search Lower Bound> <SortedSearch>", "#text": "It is possible to\n\nthat binary search is the most efficient algorithm possible in\nthe worst case when searching in a sorted array.\nThis is even more difficult than proving that sequential search\nis the most efficient algorithm possible on an unsorted array."}}]}]}}