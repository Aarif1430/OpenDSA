{"document": {"@ids": "all-pairs-shortest-paths", "@names": "all-pairs\\ shortest\\ paths", "@source": "<string>", "@title": "All-Pairs Shortest Paths", "title": "All-Pairs Shortest Paths", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@ids": "floydexamp", "@names": "floydexamp", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}], "paragraph": [{"title_reference": ["all-pairs shortest paths problem", "u, v in mathbf{V}", "d(u, v)"], "#text": "We next consider the problem of finding the shortest distance\nbetween all pairs of vertices in the graph, called\nthe .\nTo be precise, for every ,\ncalculate ."}, {"title_reference": ["Dijkstra's algorithm", "shortest path <single-source shortest paths problem>", "|mathbf{V}|", "mathbf{G}", "|mathbf{E}| = Theta(|mathbf{V}|)", "Theta(|mathbf{V}|^2 + |mathbf{V}||mathbf{E}| log\n|mathbf{V}|) = Theta(|mathbf{V}|^2 log |mathbf{V}|)", "Theta(|mathbf{V}|^3 log |mathbf{V}|)", "Theta(|mathbf{V}|^3)"], "literal": "MinVertex", "#text": "One solution is to run \nfor finding the \n times, each\ntime computing the shortest path from a different start vertex.\nIf  is sparse\n(that is, )\nthen this is a good solution, because the total cost will be\n\nfor the version of Dijkstra's algorithm based on priority queues.\nFor a dense graph, the priority queue version of Dijkstra's algorithm\nyields a cost of ,\nbut the version using  yields a cost\nof ."}, {"title_reference": ["Theta(|mathbf{V}|^3)", "k", "k-path", "v", "u", "v", "u", "k", "v", "u", "Figure #FloydExamp", "k"], "#text": "Another solution that limits processing time to\n\nregardless of the number of edges is known as Floyd's algorithm.\nIt is an example of dynamic programming.\nThe chief problem with solving this problem is organizing the search\nprocess so that we do not repeatedly solve the same subproblems.\nWe will do this organization through the use of the -path.\nDefine a  from vertex  to vertex\n to be any path whose intermediate vertices (aside from\n and ) all have indices less than .\nA 0-path is defined to be a direct edge from  to .\nFigure  illustrates the concept of\n-paths."}, {"title_reference": ["{rm D}_k(v, u)", "k", "v", "u", "k", "v", "u", "(k+1)", "k", "k", "k", "v", "k", "k", "k", "u", "k"], "literal": "D", "#text": "Define  to be the length of the shortest\n-path from vertex  to vertex .\nAssume that we already know the shortest -path from \nto .\nThe shortest -path either goes through vertex \nor it does not.\nIf it does go through , then the best path is\nthe best -path from  to  followed by the\nbest -path from  to .\nOtherwise, we should keep the best -path seen before.\nFloyd's algorithm simply checks all of the possibilities in a triple\nloop.\nHere is the implementation for Floyd's algorithm.\nAt the end of the algorithm, array  stores the all-pairs shortest\ndistances."}, {"title_reference": "Theta(|mathbf{V}|^3)", "#text": "Clearly this algorithm requires  running\ntime, and it is the best choice for dense graphs because it is\n(relatively) fast and easy to implement."}], "target": {"@refid": "floydexamp"}}}