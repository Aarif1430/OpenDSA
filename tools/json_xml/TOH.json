{"document": {"@ids": "introduction-to-analyzing-a-problem", "@names": "introduction\\ to\\ analyzing\\ a\\ problem", "@source": "<string>", "@title": "Introduction to Analyzing a Problem", "title": "Introduction to Analyzing a Problem", "subtitle": {"@ids": "towers-of-hanoi", "@names": "towers\\ of\\ hanoi", "#text": "Towers of Hanoi"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/RecurTutor/TOHfigCON.css"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "TOHfigCON", "@long_name": "TOHfigCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}], "paragraph": [{"math": "\\Theta(n \\log n)", "#text": "How do I know if I have a good algorithm to solve a problem?\nIf my algorithm runs in  time, is that good?\nIt would be if I were sorting the records stored in an array.\nBut it would be terrible if I were searching the array for the largest\nelement.\nThe value of an algorithm must be determined in relation to the\ninherent complexity of the problem at hand."}, "This module presents our first example of the end-to-end process for\nanalyzing a problem.\nWe will (1) define a simple problem, then (2) find an algorithm for it\n(giving an opportunity to talk a bit about the process of problem\nsolving), and finally (3) analyze the relationship between the\nalgorithm and the problem to see if the algorithm is efficient or\nnot.\nWe will also solve a simple recurrence as part of the process.", "The problem that we start with is one that you probably are\nalready quite familiar with: Towers of Hanoi.\nAs best you can, you should pretend that you have never seen the\nTowers of Hanoi problem before, that you are approaching it for the\nfirst time.\nThis problem is especially good for us to use as a starting\nexample for the analysis of a problem.\nThe reason is that there some simplifying aspects to it that make it\nunusually easy to discuss its analysis.\nFirst, there is only one problem instance of a given size.\nSecond, there is essentially only one optimal algorithm,\nand it is simple for us to recognize this to be a fact.\nThis avoids a lot of the complication that we normally\nencounter in the analysis process, even when considering the simplest\nof problems.\nIn other words, Towers of Hanoi is easy to analyze, which is different\nfrom being easy to solve, and which is also different from\nhaving \"easy cost\" (that is, being cheap to run).\nThese three aspects of being easy or hard\n(ability to analyze, ability to find a solution, and cost to run) are\ncompletely independent."], "topic": {"title": "TOWERS OF HANOI", "paragraph": [{"strong": "Input:", "#text": "Three poles (labeled A, B, and C) and $n$ disks of\ndifferent sizes placed in order of size on Pole A."}, {"strong": "Problem:", "#text": "Move the disks to Pole B, given the following\nconstraints:"}, {"strong": "Output:", "#text": "A series of moves that solves the problem."}], "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "A \"move\" takes the topmost disk from one pole and places it on\nanother pole (the only action allowed)."}, {"paragraph": "A disk may never be on top of a smaller disk."}]}}, "section": [{"@ids": "the-model", "@names": "the\\ model", "title": "The Model", "paragraph": "Recall that to do analysis, we have to define a model with two parts:\na definition for the size of the input, and a definition for how to\nmeasure the cost of a solution.", "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"strong": "The size of the input", "#text": "is the number of disks."}}, {"paragraph": {"strong": "The cost of the solution", "#text": "is the number of moves made."}}]}}, {"@ids": "finding-an-algorithm", "@names": "finding\\ an\\ algorithm", "title": "Finding an Algorithm", "paragraph": ["When trying to solve most problems, a good place to start is to try to\nsolve it for small instances.\nHow would we solve the problem when there are 0 disks, 1 disk, 2\ndisks, and so on?\nThose should all be pretty easy for you to figure out.\nHow about 3 disks? This starts to get a bit harder.\nThink about all the possible choices for a 3-disk series of\nmoves.\nThere a several possibilities, but you should find that there is only\none \"reasonable\" one.\nCan we generalize the insight from solving for 3 disks?\nHow about when we solve for 4 disks?", "Here is a useful observation: The largest disk has no effect on the\nmovements of the other disks.\nWhy?\nBecause it is always below the other disks, so they\ncan move around as though it did not exist.\nWhy is this useful? Because it essentially means that we can ignore\nthe biggest disk when we think about solving subproblems.\nMost importantly, it means that we can use the pole that the biggest\ndisk is sitting on to solve the subproblems, just as if that disk was\nnot there at all.", "Here is another observation that you should come to, if you actually\nplay around with the problem yourself.\nThis one is critical:\nWe can't move the bottom disk from Pole A to Pole B unless all other\ndisks are already on Pole C.\nThis critical observation almost immediately gives us a solution to\nthe problem.", {"emphasis": "analysis", "#text": "Problem solving often relies on a \"key insight\" that lets you\n\"crack\" the problem.\nSimilarly,  of the problem might rely on a\n\"key insight\" on how to view the analysis.\nThis is often a simplification for the \"states\" or progess of the\nalgorithm, or a recognition of the key input classes for the problem."}, "When we generalize the problem to more disks, we must end up with\na process something like:", "Notice that in this discussion, we used a number of problem-solving\nheuristics to solve this problem, including:", {"math": ["n-1", "n-1"], "#text": "As a practical matter, how do we deal with the fact that we have to\nmove  disks (twice)?\nAs programmers, we are used to packaging tasks into subroutines of\nsome sort.\nIn this case, since solving the problem on  disks looks\njust like a smaller version of solving the original problem,\nit seems natural to use recursion."}, "Generalizing the problem-solving approach a bit, we can say that we\nused a forward-backward strategy:\nFirst we solved simple special cases and generalized\ntheir solution, then we tested the generalization on other special\ncases.", "Here is the algorithm, cast as a program:"], "bullet_list": [{"@bullet": "*", "list_item": [{"paragraph": "Move all but the bottom disk to Pole C."}, {"paragraph": "Move the bottom disk from Pole A to Pole B."}, {"paragraph": "Move the remaining disks from Pole C to Pole B."}]}, {"@bullet": "*", "list_item": [{"paragraph": "Get our hands dirty: Try playing with some simple examples"}, {"paragraph": "Go to the extremes: Check the small cases first"}, {"paragraph": "Penultimate step: Key insight is that we can't solve the problem\nuntil we move the bottom disk. So to solve the whole problem, we\nfirst clear off the bottom disk, then we move the bottom disk, then\nwe solve the rest of the problem. Reducing the full problem to these\npieces is hopefully easier to solve than the original problem was."}]}], "literal_block": {"@xml:space": "preserve", "#text": "void Tower1(int n, POLE start, POLE goal, POLE tmp) {\n  if (n == 0) return;             // Base case\n  Tower1(n-1, start, tmp, goal); // Recurse: n-1 disk\n  move(start, goal);              // Move one disk\n  Tower1(n-1, tmp, goal, start); // Recurse: n-1 disk\n}"}}, {"@ids": "analysis-of-the-algorithm", "@names": "analysis\\ of\\ the\\ algorithm", "title": "Analysis of the Algorithm", "paragraph": [{"math": ["n", "n"], "#text": "Since the input to the problem is the number of disks, and the size of\nthe problem is also the number of disks, there is only one input\ninstance of size .\nSo we do not need to worry about complicating issues related to\nwhether we are concerned with the worst, best, or average case costs.\nThis is one of the reasons why we picked this problem to discuss first\nwe don't have the complexity of a range of inputs for a\ngiven size ."}, {"title_reference": "growth rate", "math": "n", "#text": "Given an algorithm to solve the problem, we want to know what the\ncost of that algorithm is as a function of the input size.\nIn particular, we want to know the  for the\nalgorithm as the input size grows.\nIn particular, our cost model says that our cost is the number of\nmoves that are made to solve the problem.\nSo, we want to count the number of moves required as a function of\n."}, {"math": "n", "#text": "To do this, we will need a mathematical model, some equation that\ndefines the number of moves as a function of .\nHow do we get there?\nWe can either deduce this from the structure of the algorithm, or by\nobserving its behavior.\nLet's start with behavior (though with a bit of proficiency we will\nfind that the structure of this particular algorithm makes the\nequation fairly straightforward).\nHere are some facts to get us started, by counting the number of moves\nthat the algorithm makes for some small inputs."}, {"math": "n", "#text": "Now, how do we generalize this?\nIf we look at the algorithm, we see that there are two recursive\ncalls, and one move is made.\nWe don't know what the cost of a recursive call actually is.\nBut if we give a name to the cost of our algorithm, then we can use\nthat same name to identify the cost of the subproblem.\nSo, for an arbitrary input size of , we can generalize the\ncost as:"}, {"title_reference": ["recurrence relation", "closed-form solution"], "#text": "This is using a , and we will need to\n\"solve\" it by finding a  for the\nrecurrence."}, "Actually, we can simplify our list of facts.\nWe only need f(1) and f(n), facts f(2) and f(3) are redundant\ninformation.\nBut spelling them out might help us to see the pattern.\nWe only need one base case in this case.\nSo here is the formal recurrence relation that defines the\nmathematical model for our algorithm's cost:", "How can we find a closed-form solution for this recurrence?\nNormally, we can't get anywhere with one of these analysis problems\nuntil we \"get our hands dirty\" with some small examples of the\nbehavior of the equation.\nSo here is a small table with the first few values.", {"math": ["2^n", "f(n) = 2^n - 1"], "#text": "Can we see a pattern here?\nIt looks like each time we add a disk, we roughly double the cost\nsomething like .\nIf we examine some simple cases, we see that they appear to fit the\nexact equation ."}, {"title_reference": "Guess and test", "#text": "This really is a common way to go about figuring out the closed-form\nsolution for many recurrence relations and summation:\nLook at what happens, try to find (or guess) a pattern, and then test\nthe pattern.\nThis is so common that it has its own  name: .\nWe will use this a lot to help us with analysis."}, {"strong": "always", "#text": "Now that we have a pretty good guess,\nhow do we prove that this  works?\nThis is the \"test\" part of \"guess and test\"."}, {"strong": "assume", "math": ["f(n-1) = 2^{n-1} - 1", "f(n-1)", "2^{n-1} - 1", "f(n) = 2f(n-1) + 1 = 2(2^{n-1} - 1) + 1 = 2^n - 1"], "#text": "Let's  that , and see what\nhappens.\nTake the recurrence, and simply replace  with our guess\nthat it is .\nDoing this gives us\n."}, {"strong": "ever", "math": ["n", "f(n) = 2^n - 1", "n", "f"], "title_reference": "proof by induction", "#text": "The implication here is that if there is  an  for\nwhich , then for all greater values of\n,  conforms to this rule.\nThis is the essence of .\nTo prove by induction, we need to show two things:"}, {"literal": "Tower1", "#text": "Here is the complete induction proof for :"}], "bullet_list": [{"@bullet": "*", "list_item": [{"paragraph": {"math": "f(0) = 0", "#text": "."}}, {"paragraph": {"math": "f(1) = 1", "#text": "."}}, {"paragraph": {"math": "f(2) = 3", "#text": "."}}, {"paragraph": {"math": "f(3) = 7", "#text": "."}}]}, {"@bullet": "*", "list_item": {"paragraph": {"math": "f(n) = f(n-1) + 1 + f(n-1) = 2f(n-1) + 1, \\forall n \\geq 4", "#text": "."}}}], "math_block": [{"@xml:space": "preserve", "#text": "f(n) = \\left\\{\n\\begin{array}{ll}\n1 & n = 1\\\\\n2f(n-1) + 1& n > 1\n\\end{array}\n\\right."}, {"@xml:space": "preserve", "#text": "\\begin{array}{r|rrrrrrr}\nn   &1&2&3&4 &5 &6\\\\\n\\hline\nf(n)&1&3&7&15&31&63\\\\\n\\end{array}"}], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"title_reference": "base case", "#text": "We can get started ()."}}, {"paragraph": {"math": ["k", "k+1"], "#text": "Being true for  implies that it is true also for\n."}}]}, "topic": {"title": "Proof by Induction", "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"strong": "Check the base case.", "math": ["n = 0", "f(0) = 0", "f(0) = 2^0 - 1"], "#text": "For , , so ."}}, {"paragraph": {"strong": "State the induction hypothesis.", "math": ["f(k) = 2^k - 1", "k<n"], "#text": "The induction hypothesis is\n, for ."}}, {"paragraph": [{"strong": ["Use the assumption from the induction hypothesis for", "to show that the result is true for"], "math": ["n-1", "n"], "#text": "."}, "From the recurrence we have"], "math_block": {"@xml:space": "preserve", "#text": "\\begin{eqnarray*}\nf(n) &=& 2f(n-1) + 1\\\\\n&=& 2(2^{n-1} - 1) + 1 = 2^n - 1\n\\end{eqnarray*}"}}]}, "paragraph": {"math": "n\\geq 0", "#text": "Thus, we conclude that formula is correct for all ."}}}, {"@ids": "lower-bound-for-the-problem", "@names": "lower\\ bound\\ for\\ the\\ problem", "title": "Lower Bound for the Problem", "paragraph": ["Is this a good algorithm?\nThat would depend on what?\nOn the intrinsic difficulty of the problem!", {"strong": "for all possible algorithms", "#text": "To decide if the algorithm is good, we need a lower bound on the\ncost of the PROBLEM.\nThe lower bound for the problem is the tightest (highest) lower bound\nthat we can prove  that solve the\nproblem.\nThis can be a difficult bar, given that we cannot possibly know all\nalgorithms for any problem, because there are theoretically an\ninfinite number."}, "Lower bounds don't give you a good algorithm.\nThey only help you know when to stop looking.\nIf the lower bound for the problem matches the upper bound for the\nalgorithm (within a constant factor), then we know that we can find an\nalgorithm that is better only by a constant factor.", "Can a lower bound tell us if an algorithm is NOT optimal?\nNo, sorry!\nWhy not?\nBecause we might not have the tightest possible lower bound!", "Let's determine the lower bounds for Towers of Hanoi.\nAnother reason why we picked this problem to start with is\nbecause it is \"obvious\" what the lower bound cost to the problem is.\nSo now we can focus entirely on the technique of proving the math, not\nfiguring out what to analyze.", {"math": ["n", "2n - 1"], "#text": "For our first try at a lower bounds proof, the \"trivial\" lower bound\nis that we must move every disk at least once, for a minimum cost\nof .\nSlightly better is to observe that to get the bottom disk to the third\npole, we must move every other disk at least twice (once to get them\noff the bottom disk, and once to get them over to the third pole).\nThis yields a cost of , which still is not a good match\nfor our algorithm.\nIs the problem in the algorithm or in the lower bound?"}, {"math": ["n-1", "\\textbf{T}(n-1)", "n-1", "\\textbf{T}(n-1)", "2^n-1"], "#text": "We can get to the correct lower bound by the following reasoning:\nTo move the biggest disk from first to the last pole, we must first\nhave all of the other  disks out of the way, and the only\nway to do that is to move them all to the middle pole (for a cost of\nat least ).\nWe then must move the bottom disk (for a cost of at least one).\nAfter that, we must move the  remaining disks from the\nmiddle pole to the third pole (for a cost of at least\n).\nThus, no possible algorithm can solve the problem in less than\n steps.\nThus, our algorithm is optimal."}]}, {"@ids": "new-models", "@names": "new\\ models", "title": "New Models", "paragraph": [{"math": ["O(n)", "O(1)"], "#text": "New model #1: We can move a stack of disks in one move.\nThis is a big help!  or even ."}, "New model #2: Not all disks start on Pole A.\nThis doesn't seem to change the cost of the problem. (Why?)", {"math": "O(n)", "#text": "Combining these two things, the cost looks to be ."}, "New model #3: Different numbers of poles.", {"math": "k", "#text": "New model #4: We want to know what the  th move is."}]}, {"@ids": "putting-it-all-together", "@names": "putting\\ it\\ all\\ together", "title": "Putting it all Together", "paragraph": ["So now we have an answer to the question\n\"How do I know if I have a good algorithm to solve a problem?\"\nAn algorithm is good (asymptotically speaking) if its upper bound\nmatches the problem's lower bound.\nIf they match, then we know to stop trying to find an (asymptotically)\nfaster algorithm.\nWhat if the (known) upper bound for our algorithm does not\nmatch the (known) lower bound for the problem?\nIn this case, we might not know what to do.\nIs our upper bound flawed, and the algorithm is really faster than we\ncan prove?\nIs our lower bound weak, and the true lower bound for the problem is\ngreater?\nOr is our algorithm simply not the best?", {"footnote_reference": {"@auto": "1", "@ids": "id1", "@refid": "id2", "#text": "1"}, "#text": "Now we know precisely what we are aiming for when designing an\nalgorithm:\nWe want to find an algorithm who's upper bound matches the lower bound\nof the problem.\nPutting together all that we know so far about algorithms, we can\norganize our thinking into the following \"algorithm for designing\nalgorithms\"."}, "We can repeat this process until we are either satisfied or\nexhausted.", {"emphasis": ["any", "could", "does"], "#text": "This brings us smack up against one of the toughest tasks in\nanalysis.\nLower bounds proofs are notoriously difficult to construct.\nThe problem is coming up with arguments that truly cover all of the\nthings that  algorithm possibly  do.\nThe most common fallacy is to argue from the point of view of what\nsome good algorithm actually  do, and claim that any\nalgorithm must do the same.\nThis simply is not true, and any lower bounds proof that refers to\nspecific behavior that must take place should be viewed with some\nsuspicion."}, "Which brings us back to the argument that we used to justify our lower\nbound for Towers of Hanoi.\nThis is essentially an argument about necessary behavior.\nTowers of Hanoi is rather rare in that we do have some specific\nbehavior that we know must happen.\nIn this particular case the problem is so constrained\nthat there really is no (better) alternative to this particular\nsequence of events.\nThis approach will not work for most problems.", "Does our \"problem solving algorithm\" always terminate?\nNo.\nYou might get stuck in a loop if you go through and make no\nprogress.\nSo, is it an algorithm?"], "line_block": {"line": {"strong": "If", "#text": "the upper and lower bounds match,"}, "line_block": {"line": [{"strong": "then", "#text": "stop,"}, {"strong": "else if", "#text": "the bounds are close or the problem isn't important,"}], "line_block": {"line": [{"strong": "then", "#text": "stop,"}, {"strong": "else if", "#text": "the problem definition focuses on the wrong thing,"}], "line_block": {"line": [{"strong": "then", "#text": "restate it,"}, {"strong": "else if", "#text": "the algorithm is too slow,"}], "line_block": {"line": [{"strong": "then", "#text": "find a faster algorithm,"}, {"strong": "else if", "#text": "lower bound is too weak,"}], "line_block": {"line": {"strong": "then", "#text": "generate a stronger bound."}}}}}}}, "footnote": {"@auto": "1", "@backrefs": "id1", "@ids": "id2", "@names": "1", "label": "1", "paragraph": {"emphasis": "Compared to What?", "#text": "This is a minor reformulation of the \"algorithm\" given by\nGregory J.E. Rawlins in his book"}}, "raw": {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/RecurTutor/TOHfigCON.js"}}]}}