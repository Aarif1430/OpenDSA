{"document": {"@dupnames": "free\\ and\\ bound\\ variables", "@ids": "id1 free-and-bound-variables", "@names": "free-and-bound-variables", "@source": "<string>", "@title": "Free and Bound Variables", "title": "Free and Bound Variables", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "target": {"@refid": "free-and-bound-variables"}, "section": [{"@dupnames": "free\\ and\\ bound\\ variables", "@ids": "id2", "title": "Free and Bound Variables", "paragraph": ["In the lambda calculus, like in other programming languages, there are\ntwo kinds of variable occurrences: variable declaration and variable\nuse. In the following JavaScript code fragment, for example:", {"math": ["x", "x", "x", "x", "x", "x", "y"], "emphasis": ["declaration", "use"], "#text": "there are two occurrences of the variable . The first\noccurrence of  (between parentheses) is the  of\nthe parameter , that is, the place where the variable is\nfirst introduced into the program. In contrast, the second occurrence\nof  is a  of the variable  (more precisely,\n is being used as an operand for an addition operation). Is\nthe occurrence of  in this program a variable declaration or a\nvariable use?"}, {"title_reference": ["scope", "bound", "binding occurrence", "free"], "math": ["x", "x", "x", "x", "x", "y", "y"], "#text": "Each variable declaration defines a  for that variable,\nthat is, the section(s) of the program in which this variable is\ndefined and usable. In the example above, the scope of the variable\n is the body of the function. When the use of a variable, say\n, appears within the scope of a declaration of , we\nsay that the former is  to the latter, and the latter is\nthe  of the variable. So, in the example\nabove, the declaration of  in parentheses is the binding\noccurrence of this variable and the use  on the next line is\nbound to this binding occurrence. A variable that is not bound is said\nto be .  In the example above, the occurrence of \nis free in the body of the function, since this function does not\ncontain any binding occurrence (i.e., declaration) of ."}, {"math": "x", "#text": "Since there may be several declarations of a variable  inside\na given program, there cannot be any ambiguity about which declaration\nof the variable each use of it is bound to. This is why each\nprogramming language must define a binding scheme. The lambda\ncalculus, like JavaScript and most other modern programming languages,\nuses static binding (also known as \"static scoping\" or \"lexical\nbinding\"; see <some section in previous chapter>), which means that\neach variable use is bound to the variable declaration by the same\nname in the smallest lambda abstraction that contains the variable\nuse."}, "We are now ready to discuss the concepts of declaration/use of\nvariables, binding occurrence, free and bound variables, and lexical\nscoping in the context of the lambda calculus. Consider the following\nexample:", {"math": ["y", "(y\\ x)", "y", "\\lambda", "y", "(\\lambda x.x\\ (y\\\nx))", "y", "x", "\\lambda x.x", "x", "x", "x", "x"], "#text": "This lambda expression is a lambda abstraction whose parameter is\n and whose body is the application of the identity function\nto the expression . Therefore, the  after the\n is the binding occurrence of the variable\n. The scope of this declaration is , which implies that the rightmost occurrence of  is\nbound to the leftmost binding occurrence. In contrast, the scope of the\nbinding occurrence of  in  is just the\nsecond  in it (that is, as always, the body of the lambda\nabstraction). As a result, the third, rightmost occurrence of \nin the expression above is free: it is a use of  that\ndoes not belong to the scope of any declarations of ."}, {"math": "x", "emphasis": "occurrence", "#text": "To summarize this example, going from left to right, the first\noccurrence of  is its binding occurrence, the second one is\nbound to the first one, and the third one is free. This example\nillustrates the fact that it is possible for any variable to occur\nboth free and bound within the same expression. Therefore, it can be\nconfusing to ask whether a variable is free or bound in a lambda\nexpression. It is preferable to ask this question about each\nparticular  of a variable, keeping in mind that a binding\noccurrence is never free since its role is to define a new variable."}], "literal_block": {"@classes": "code", "@xml:space": "preserve", "#text": "function (x) {\n   return x + y;\n}"}, "math_block": {"@xml:space": "preserve", "#text": "\\lambda y.(\\lambda x.x\\ (y\\ x))"}}, {"@ids": "rp-14-part-4", "@names": "rp\\ 14\\ part\\ 4", "title": "RP 14 part 4", "paragraph": "This exercise will be good practice for identifying free\nvariables in lambda expressions. To get credit for this randomized\nproblem, you must solve it correctly three times in a row.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP14part4", "@long_name": "RP14part4", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "rp-14-part-5", "@names": "rp\\ 14\\ part\\ 5", "title": "RP 14 part 5", "paragraph": "This exercise will be good practice for identifying bound\nvariables in lambda expressions. To get credit for this randomized\nproblem, you must solve it correctly three times in a row.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP14part5", "@long_name": "RP14part5", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "formal-definition-of-free-variables", "@names": "formal\\ definition\\ of\\ free\\ variables", "title": "Formal Definition of Free Variables", "paragraph": [{"title_reference": ["BNF grammar <BNF grammar> <BNF-grammar-for-LC>", "free"], "math": ["x", "E"], "#text": "Throughout this section, we have attempted to be as intuitive and\ninformal as possible. However, it is possible to define the notions of\nfree and bound variables systematically. For any precise definition\npertaining to  lambda calculus, we need only consider the three types of\nlambda expressions defined in the lambda calculus grammar (see\n).\nFor example, we say that any variable\n occurs  in any lambda expression\n if and only if:"}, "Notice that the recursion in cases 2 and 3 above mirrors the recursion\nin the lambda calculus grammar. The following table illustrates\nall cases of this definition.", "The reason we devoted a whole section to the notions of free and bound\nvariables is because we will invoke them repeatedly throughout this\nchapter, starting in the next section."], "block_quote": {"enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"math": ["E", "E", "x"], "#text": "is a variable and  is identical to , or"}}, {"paragraph": {"math": ["E", "(E_1\\ E_2)", "x", "E_1", "E_2"], "#text": "is of the form  and  occurs\nfree in either  or  (or both), or"}}, {"paragraph": {"math": ["E", "\\lambda y.E'", "y", "x", "x", "E'"], "#text": "is of the form  where  is\ndifferent from  and  occurs free in ."}}]}}, "table": {"@classes": "colwidths-given", "tgroup": {"@cols": "4", "colspec": [{"@colwidth": "1"}, {"@colwidth": "1"}, {"@colwidth": "2"}, {"@colwidth": "8"}], "thead": {"row": {"entry": [{"paragraph": {"math": "E"}}, {"paragraph": "Case"}, {"paragraph": {"math": ["x", "E"], "#text": "Does  occur free in ?"}}, {"paragraph": "Explanation"}]}}, "tbody": {"row": [{"entry": [{"paragraph": {"math": "x"}}, {"paragraph": "1"}, {"paragraph": "yes, because ..."}, {"paragraph": {"math": ["x", "E", "E", "\\lambda"], "#text": "...  appears in (is equal to)  and \ndoes not contain any binding occurrences (no )."}}]}, {"entry": [{"paragraph": {"math": "y"}}, {"paragraph": "1"}, {"paragraph": "no, because ..."}, {"paragraph": {"math": ["x", "E"], "#text": "...  does not occur in  and thus cannot occur free\nin it."}}]}, {"entry": [{"paragraph": {"math": "(x\\ y)"}}, {"paragraph": "2"}, {"paragraph": "yes, because ..."}, {"paragraph": {"math": "x", "#text": "...  occurs free in the first component of the function\napplication (recursive application of case 1)."}}]}, {"entry": [{"paragraph": {"math": "(y\\ x)"}}, {"paragraph": "2"}, {"paragraph": "yes, because ..."}, {"paragraph": {"math": "x", "#text": "...  occurs free in the second component of the function\napplication (recursive application of case 1)."}}]}, {"entry": [{"paragraph": {"math": "(y\\ z)"}}, {"paragraph": "2"}, {"paragraph": "no, because ..."}, {"paragraph": {"math": "x", "#text": "...  occurs free in neither the first nor the second component\nof the function application (doubly recursive application of case 1)."}}]}, {"entry": [{"paragraph": {"math": "\\lambda z.x"}}, {"paragraph": "3"}, {"paragraph": "yes, because ..."}, {"paragraph": {"math": ["x", "z", "x", "\\lambda z."], "#text": "...  is different from  (the parameter of the lambda\nabstraction) and  occurs free in the body of the lambda\nabstraction (recursive application of case 1). Note that the body is what\nis left of the lambda abstraction after the binding occurrence (i.e.,\n) is removed."}}]}, {"entry": [{"paragraph": {"math": "\\lambda z.z"}}, {"paragraph": "3"}, {"paragraph": "no, because ..."}, {"paragraph": {"math": ["x", "z", "x"], "#text": "...  is different from  (the parameter of the lambda\nabstraction) and  does not occur (at all, and thus not free\neither) in the body of the lambda abstraction."}}]}, {"entry": [{"paragraph": {"math": "\\lambda z.\\lambda x.x"}}, {"paragraph": "3"}, {"paragraph": "no, because ..."}, {"paragraph": {"math": ["x", "z", "x", "\\lambda x.x"], "#text": "...  is different from  (the parameter of the lambda\nabstraction) but  does not occur free in the body of the lambda\nabstraction (recursive application of case 3). Note that the body in\nthis case is the lambda abstraction ."}}]}, {"entry": [{"paragraph": {"math": ["\\lambda x.y", "\\lambda x.x"], "#text": "or"}}, {"paragraph": "3"}, {"paragraph": "no, because ..."}, {"paragraph": {"math": ["x", "E", "x", "E", "x", "E", "E", "x"], "#text": "...  is identical to the parameter of the lambda\nabstraction .  cannot be free in \nsince any free occurrences of  in the body of \nwould become bound in  by the leading binding\noccurrence of ."}}]}]}}}}]}}