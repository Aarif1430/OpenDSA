{"document": {"@ids": "the-pr-quadtree", "@names": "the\\ pr\\ quadtree", "@source": "<string>", "@title": "The PR Quadtree", "title": "The PR Quadtree", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@ids": "prexamp", "@names": "prexamp", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "prinsert", "@names": "prinsert", "@xml:space": "preserve", "odsafig": "null"}], "paragraph": [{"title_reference": ["Point-Region quadtree", "PR quadtree"], "#text": "In the \n(hereafter referred to as the )\neach node either has exactly four children or is a leaf.\nThat is, the PR quadtree is a full four-way branching\n(4-ary) tree in shape.\nThe PR quadtree represents a collection of data points in two\ndimensions by decomposing the region containing the data points\ninto four equal quadrants, subquadrants, and so on, until no leaf node\ncontains more than a single point.\nIn other words, if a region contains zero or one data points, then it\nis represented by a PR quadtree consisting of a single leaf node.\nIf the region contains more than a single data point, then the region\nis split into four equal quadrants.\nThe corresponding PR quadtree then contains an internal node and four\nsubtrees, each subtree representing a single quadrant of the region,\nwhich might in turn be split into subquadrants.\nEach internal node of a PR quadtree represents a single split\nof the two-dimensional region.\nThe four quadrants of the region (or equivalently, the corresponding\nsubtrees) are designated (in order) NW, NE, SW, and~SE.\nEach quadrant containing more than a single point would\nin turn be recursively divided into subquadrants until each leaf of\nthe corresponding PR quadtree contains at most one point."}, {"title_reference": ["Figure #PRExamp", "Figure #PRExamp"], "math": "128 \\times 128", "#text": "For example, consider the region of Figure  (a)\nand the corresponding PR quadtree in\nFigure  (b).\nThe decomposition process demands a fixed key range.\nIn this example, the region is assumed to be of size\n.\nNote that the internal nodes of the PR quadtree are used solely to\nindicate decomposition of the region; internal nodes do not store data\nrecords.\nBecause the decomposition lines are predetermined (i.e, key-space\ndecomposition is used), the PR quadtree is a trie."}, {"math": ["Q", "Q", "Q", "x", "y", "x", "y", "Q", "Q", "Q"], "title_reference": "Figure #PRExamp", "#text": "Search for a record matching point  in the PR quadtree is\nstraightforward.\nBeginning at the root, we continuously branch to the quadrant that\ncontains  until our search reaches a leaf node.\nIf the root is a leaf, then just check to see if the node's data\nrecord matches point .\nIf the root is an internal node, proceed to the child that contains\nthe search coordinate.\nFor example, the NW quadrant of Figure  contains\npoints whose  and  values each fall in the range 0 to 63.\nThe NE quadrant contains points whose  value falls in the range\n64 to 127, and whose  value falls in the range 0 to 63.\nIf the root's child is a leaf node, then that child is checked to see\nif  has been found.\nIf the child is another internal node, the search process continues\nthrough the tree until a leaf node is found.\nIf this leaf node stores a record whose position matches  then\nthe query is successful; otherwise  is not in the tree."}, {"math": ["P", "P", "P", "P", "P", "P"], "title_reference": "Figure #PRinsert", "#text": "Inserting record  into the PR quadtree is performed by first\nlocating the leaf node that contains the location of .\nIf this leaf node is empty, then  is stored at this\nleaf.\nIf the leaf already contains  (or a record with 's\ncoordinates), then a duplicate record should be reported.\nIf the leaf node already contains another record, then the node\nmust be repeatedly decomposed until the existing record and \nfall into different leaf nodes.\nFigure  shows an example of such an insertion."}, {"math": ["P", "N", "P", "N", "N", "N", "N'", "N'", "C"], "title_reference": ["Figure #PRinsert", "Figure #PRinsert"], "#text": "Deleting a record  is performed by first locating the\nnode  of the PR quadtree that contains .\nNode  is then changed to be empty.\nThe next step is to look at 's three siblings.\n and its siblings must be merged together to form a single\nnode  if only one point is contained among them.\nThis merging process continues until some level is reached at which\nat least two points are contained in the subtrees represented by\nnode  and its siblings.\nFor example, if point  is to be deleted from the PR quadtree\nrepresenting Figure  (b), the resulting node must\nbe merged with its siblings, and that larger node again merged with\nits siblings to restore the PR quadtree to the decomposition of\nFigure  (a)."}, {"math": ["r", "Q"], "emphasis": "only", "#text": "Region search is easily performed with the PR quadtree.\nTo locate all points within radius  of query\npoint , begin at the root.\nIf the root is an empty leaf node, then no data points are found.\nIf the root is a leaf containing a data record, then the location of\nthe data point is examined to determine if it falls within the\ncircle.\nIf the root is an internal node, then the process is performed\nrecursively, but  on those subtrees containing some part\nof the search circle."}, {"title_reference": "trie", "emphasis": ["whether", "where"], "#text": "Let us now consider how the structure of the PR quadtree affects the\ndesign of its node representation.\nThe PR quadtree is actually a .\nDecomposition takes place at the mid-points for internal nodes,\nregardless of where the data points actually fall.\nThe placement of the data points does determine  a\ndecomposition for a node takes place, but not  the\ndecomposition for the node takes place.\nInternal nodes of the PR quadtree are quite different from leaf nodes,\nin that internal nodes have children (leaf nodes do not) and leaf\nnodes have data fields (internal nodes do not).\nThus, it is likely to be beneficial to represent internal nodes\ndifferently from leaf nodes.\nFinally, there is the fact that approximately half of the leaf nodes\nwill contain no data field."}, "Another issue to consider is: How does a routine traversing the\nPR quadtree get the coordinates for the square represented by the\ncurrent PR quadtree node?\nOne possibility is to store with each node its spatial description\n(such as upper-left corner and width).\nHowever, this will take a lot of space  perhaps as much as the\nspace needed for the data records, depending on what information is\nbeing stored.", "Another possibility is to pass in the coordinates when the recursive\ncall is made.\nFor example, consider the search process.\nInitially, the search visits the root node of the tree, which has\norigin at (0, 0), and whose width is the full size of the space being\ncovered.\nWhen the appropriate child is visited, it is a simple matter for the\nsearch routine to determine the origin for the child, and the width of\nthe square is simply half that of the parent.\nNot only does passing in the size and position information for a node\nsave considerable space, but avoiding storing such information\nin the nodes enables a good design choice for\nempty leaf nodes, as discussed next.", "How should we represent empty leaf nodes?\nOn average, half of the leaf nodes in a PR quadtree are empty\n(i.e., do not store a data point).\nOne implementation option is to use a NULL pointer in internal\nnodes to represent empty nodes.\nThis will solve the problem of excessive space requirements.\nThere is an unfortunate side effect that using a NULL pointer requires\nthe PR quadtree processing methods to understand this convention.\nIn other words, you are breaking encapsulation on the node\nrepresentation because the tree now must know things about how the\nnodes are implemented.\nThis is not too horrible for this particular application, because the\nnode class can be considered private to the tree class, in which case\nthe node implementation is completely invisible to the outside world.\nHowever, it is undesirable if there is another reasonable alternative.", {"title_reference": ["Flyweight", "design pattern"], "emphasis": "all", "#text": "Fortunately, there is a good alternative.\nIt is called the  .\nIn the PR quadtree, a flyweight is a single empty leaf node that\nis reused in all places where an empty leaf node is needed.\nYou simply have  of the internal nodes with empty leaf\nchildren point to the same node object.\nThis node object is created once at the beginning of the program,\nand is never removed.\nThe node class recognizes from the pointer value that the flyweight is\nbeing accessed, and acts accordingly."}, {"emphasis": ["cannot", "only", "all"], "#text": "Note that when using the Flyweight design pattern, you \nstore coordinates for the node in the node.\nThis is an example of the concept of intrinsic versus extrinsic state.\nIntrinsic state for an object is state information stored in the object.\nIf you stored the coordinates for a node in the node object, those\ncoordinates would be intrinsic state.\nExtrinsic state is state information about an object stored elsewhere\nin the environment, such as in global variables or passed to the\nmethod.\nIf your recursive calls that process the tree pass in the coordinates\nfor the current node, then the coordinates will be extrinsic state.\nA flyweight can have in its intrinsic state \ninformation that is accurate for  instances of the\nflyweight.\nClearly coordinates do not qualify, because each empty\nleaf node has its own location.\nSo, if you want to use a flyweight, you must pass in coordinates."}, {"title_reference": "Composite design pattern", "#text": "Another design choice is: Who controls the work, the node\nclass or the tree class?\nFor example, on an insert operation, you could have the tree class\ncontrol the flow down the tree, looking at (querying) the nodes to see\ntheir type and reacting accordingly.\nThis is the typical approach used by the BST implementation.\nAn alternate approach is to have the node class do the work.\nThat is, you have an insert method for the nodes.\nIf the node is internal, it passes the city record to the appropriate\nchild (recursively).\nIf the node is a flyweight, it replaces itself with a new leaf node.\nIf the node is a full node, it replaces itself with a subtree.\nThis is an example of the .\nUse of the composite design would be difficult if NULL pointers are\nused to represent empty leaf nodes.\nIt turns out that the PR quadtree insert and delete methods are easier\nto implement when using the composite design."}], "target": [{"@refid": "prexamp"}, {"@refid": "prinsert"}]}}