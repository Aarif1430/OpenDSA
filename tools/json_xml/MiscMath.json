{"document": {"@ids": "miscellaneous-notation", "@names": "miscellaneous\\ notation", "@source": "<string>", "@title": "Miscellaneous Notation", "title": "Miscellaneous Notation", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}], "paragraph": ["This module collects together definitions for a number of mathematical\nterms and concepts, as a place for reference when needed.", {"strong": "Units of measure:", "title_reference": ["(2^{10} = 1024", "(2^{20}", "(2^{30}", "2^{30}"], "#text": "OpenDSA modules use the following notation for units of measure.\n\"B\" will be used as an abbreviation for bytes, \"b\" for bits,\n\"KB\" for kilobytes  bytes),\n\"MB\" for megabytes  bytes)\n\"GB\" for gigabytes  bytes)\nand \"ms\" for milliseconds\n(a millisecond is 1/1000 of a second).\nSpaces are not placed between the number and the unit abbreviation\nwhen a power of two is intended.\nThus a disk drive of size 25 gigabytes (where a gigabyte is intended\nas  bytes) will be written as \"25GB\".\nSpaces are used when a decimal value is intended.\nAn amount of 2000 bits would therefore be written \"2 Kb\" while\n\"2Kb\" represents 2048 bits.\n2000 milliseconds is written as 2000 ms.\nNote that in this book large amounts of storage are nearly always\nmeasured in powers of two and times in powers of\nten."}, {"strong": "Factorial function:", "title_reference": ["factorial", "n!", "n", "n", "5! = 1 cdot 2 cdot 3 cdot 4 cdot 5 = 120", "0! = 1", "n", "n! approx sqrt{2pi n}(frac{n}{e})^n", "e approx 2.71828", "e", "n!", "n^n", "sqrt{2pi n}/e^n < 1", "c^n", "c"], "#text": "The  function, written  for  an\ninteger greater than 0, is the product of\nthe integers between 1 and , inclusive.\nThus, .\nAs a special case, .\nThe factorial function grows quickly as  becomes larger.\nBecause computing the factorial function directly is a time-consuming\nprocess, it can be useful to have an equation that provides a\ngood approximation.\nStirling's approximation states that\n,\nwhere \n( is the base for the system of natural logarithms) .\nThus we see that while  grows\nslower than  (because ),\nit grows faster than  for any positive integer constant\n."}, {"strong": "Permutations:", "title_reference": ["permutation", "mathbf{S}", "mathbf{S}", "n", "n", "n!", "n", "n-1", "random permutation", "n!", "n", "n-1", "n-1"], "literal": ["A", "swap(A, i, j)", "i", "j", "A", "Random(n)"], "#text": "A  of a sequence \nis simply the members of  arranged in some order.\nFor example, a permutation of the integers 1 through  would\nbe those values arranged in some order.\nIf the sequence contains  distinct members, then there are\n different permutations for the sequence.\nThis is because there are  choices for the first member in\nthe permutation; for each choice of first member there are \nchoices for the second member, and so on.\nSometimes one would like to obtain a  for a\nsequence, that is, one of the  possible permutations is\nselected in such a way that each permutation has equal probability of\nbeing selected.\nA simple function for generating a random permutation is as\nfollows.\nHere, the  values of the sequence are stored in\npositions 0 through  of array ,\nfunction \nexchanges elements  and  in array ,\nand  returns an integer value in the range 0 to\n."}, {"strong": "Boolean variables:", "title_reference": "Boolean variable", "literal": ["True", "False"], "#text": "A \nis a variable that takes on one of the two values  and\n.\nThese two values are often associated with the values 1 and 0,\nrespectively, although there is no reason why this needs to be the\ncase.\nIt is poor programming practice to rely on the\ncorrespondence between 0 and False, because these are logically\ndistinct objects of different types."}, {"strong": "Logic Notation:", "title_reference": ["A Rightarrow B", "A", "B", "A", "B", "A Leftrightarrow B", "A", "B", "A", "B", "A vee B", "A", "B", "A wedge B", "A", "B", "sim!A", "overline{A}", "A", "A", "A"], "#text": "We will occasionally make use of the notation of symbolic or Boolean\nlogic.\n means \" implies \" or\n\"If  then \".\n means \" if and only if \"\nor \" is equivalent to \".\n means \" or \"\n(useful both in the context of symbolic\nlogic or when performing a Boolean operation).\n means \" and \".\n and  both mean \"not \" or\nthe negation of  where  is a Boolean variable."}, {"strong": "Floor and ceiling:", "title_reference": ["floor", "x", "lfloor x rfloor", "x", "leq x", "lfloor 3.4 rfloor = 3", "lfloor 3.0 rfloor", "lfloor -3.4 rfloor = -4", "lfloor -3.0 rfloor = -3", "ceiling", "x", "lceil x rceil", "x", "geq x", "lceil 3.4 rceil = 4", "lceil 4.0 rceil", "lceil -3.4 rceil = lceil -3.0 rceil = -3"], "#text": "The  of  (written )\ntakes real value  and returns the greatest\ninteger .\nFor example, ,\nas does ,\nwhile  and\n.\nThe  of  (written\n) takes real value  and returns the\nleast integer .\nFor example, , as does\n,\nwhile ."}, {"strong": "Modulus function:", "title_reference": ["modulus", "mod", "n bmod m", "n bmod m", "r", "n = qm + r", "q", "|r| < |m|", "n bmod m", "m-1", "n", "m", "5 bmod 3 = 2", "25 bmod 3 = 1", "5 bmod 7 = 5", "5 bmod 5 = 0"], "literal": "n % m", "#text": "The  (or ) function returns the remainder of\nan integer division.\nSometimes written  in mathematical expressions,\nthe syntax in many programming languages is .\nFrom the definition of remainder,  is the integer\n such that  for  an integer,\nand .\nTherefore, the result of  must be between 0 and\n when  and  are positive integers.\nFor example, ; ,\n, and ."}, {"title_reference": ["q", "r", "n bmod m = n - mlfloor n/mrfloor", "-3 bmod 5 = 2", "n bmod m = n - m (mathrm{trunc}(n/m))", "-3 bmod 5 = -3"], "#text": "There is more than one way to assign values to \nand , depending on how integer division is interpreted.\nThe most common mathematical definition computes the mod function as\n.\nIn this case, .\nHowever, Java and C++ compilers typically use the underlying\nprocessor's machine instruction for computing integer arithmetic.\nOn many computers this is done by truncating the resulting fraction,\nmeaning .\nUnder this definition, .\nAnother language might do something different."}, {"title_reference": ["hash systems <hash system> <HashFunc>", "key"], "#text": "Unfortunately, for many applications this is not what the user wants\nor expects.\nFor example, many \nwill perform some computation on a record's  value and then\ntake the result modulo the hash table size.\nThe expectation here would be that the result is a legal index into\nthe hash table, not a negative number.\nImplementers of hash functions must either insure that the\nresult of the computation is always positive, or else add the hash\ntable size to the result of the modulo function when that result is\nnegative."}], "footnote": {"@auto": "1", "@ids": "id1", "@names": "1", "label": "1", "paragraph": {"title_reference": "approx", "#text": "The symbol \"\" means \"approximately equal.\""}}}}