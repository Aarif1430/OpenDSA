{"document": {"@dupnames": "dynamic\\ storage\\ allocation", "@ids": "dynamic-storage-allocation", "@source": "<string>", "@title": "Dynamic Storage Allocation", "title": "Dynamic Storage Allocation", "subtitle": {"@dupnames": "dynamic\\ storage\\ allocation", "@ids": "id1", "#text": "Dynamic Storage Allocation"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/MemManage/dynamicCON.css"}, {"@format": "xml", "@ids": "memmode", "@names": "memmode", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "freeblocklistCON", "@long_name": "freeblocklistCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@ids": "compfrag", "@names": "compfrag", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "fragCON", "@long_name": "fragCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/MemManage/freeblocklistCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/MemManage/fragCON.js"}], "paragraph": [{"title_reference": ["free blocks <free block>", "reserved blocks <reserved block>", "freelist", "memory requests <memory request>"], "#text": "For the purpose of dynamic storage allocation, we view memory as a\nsingle array broken into a series of variable-size blocks, where\nsome of the blocks are  and some are\n or already allocated.\nThe free blocks are linked together to form a  used\nfor servicing future .\nThis figure illustrates the situation that can arise after\na series of memory allocations and deallocations."}, {"title_reference": ["failure policy <failure policy> <Garbage>", "garbage collection"], "#text": "When a memory request is received by the memory manager, some block\non the freelist must be found that is large enough to service the\nrequest.\nIf no such block is found, then the memory manager must resort to a\n such as\n."}, {"title_reference": ["m", "m", "k", "k > m", "k - m"], "#text": "If there is a request for  words, and no block exists of\nexactly size , then a larger block must be used instead.\nOne possibility in this case is that the entire block is given away\nto the memory allocation request.\nThis might be desirable when the size of the block is only slightly\nlarger than the request.\nThis is because saving a tiny block that is too small to be useful for\na future memory request might not be worthwhile.\nAlternatively, for a free block of size ,\nwith , up to  space may be\nretained by the memory manager to form a new free\nblock, while the rest is used to service the request."}, {"title_reference": ["External fragmentation", "Internal fragmentation", "m", "m"], "#text": "Memory managers can suffer from two types of fragmentation.\n\noccurs when a series of memory requests result in lots of small free\nblocks, no one of which is useful for servicing typical requests.\n occurs when more than  words\nare allocated to a request for  words, wasting free storage.\nThe difference between internal and external fragmentation is\nillustrated by this figure.\nThe small white block labeled \"External fragmentation\" is too small\nto satisfy typical memory requests.\nThe small grey block labeled \"Internal fragmentation\" was allocated as\npart of the grey block to its left, but it does not actually store\ninformation."}, {"title_reference": "buddy method", "#text": "Some memory management schemes sacrifice space to internal\nfragmentation to make memory management easier (and perhaps reduce\nexternal fragmentation).\nFor example, external fragmentation does not happen in file management\nsystems that allocate file space in clusters.\nAnother example of sacrificing space to internal fragmentation so as\nto simplify memory management is the \ndescribed later in this chapter."}, {"title_reference": ["memory pool", "sequential fit"], "#text": "The process of searching the  for a block large\nenough to service the request, possibly reserving the remaining space\nas a free block, is referred to as a  method."}], "target": [{"@refid": "memmode"}, {"@refid": "compfrag"}]}}