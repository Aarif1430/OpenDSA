{"document": {"@dupnames": "bucket\\ hashing", "@ids": "bucket-hashing", "@source": "<string>", "@title": "Bucket Hashing", "title": "Bucket Hashing", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Hashing/buckethashCON.css"}], "section": [{"@dupnames": "bucket\\ hashing", "@ids": "id1", "title": "Bucket Hashing", "paragraph": [{"title_reference": ["R", "k_R", "home position", "textbf{h}(k_R)", "R", "R", "R"], "#text": "Closed hashing stores all records directly in the hash table.\nEach record  with key value  has a\n that is\n, the slot computed by the hash function.\nIf  is to be inserted and another record already\noccupies 's home position, then  will be stored at\nsome other slot in the table.\nIt is the business of the collision resolution policy to determine\nwhich slot that will be.\nNaturally, the same policy must be followed during search as during\ninsertion, so that any record not found in its home position can\nbe recovered by repeating the collision resolution process."}, {"title_reference": ["buckets <bucket>", "M", "B", "M/B", "overflow bucket"], "#text": "One implementation for closed hashing groups hash table slots into\n.\nThe  slots of the hash table are divided into\n buckets, with each bucket consisting of  slots.\nThe hash function assigns each record to the first slot\nwithin one of the buckets.\nIf this slot is already occupied, then the bucket slots are searched\nsequentially until an open slot is found.\nIf a bucket is entirely full, then the record is stored in an\n of infinite capacity at the end of the table.\nAll buckets share the same overflow bucket.\nA good implementation will use a hash function that distributes the\nrecords evenly among the buckets so that as few records as\npossible go into the overflow bucket."}, "When searching for a record, the first step is to hash the key to\ndetermine which bucket should contain the record.\nThe records in this bucket are then searched.\nIf the desired key value is not found and the bucket still has free\nslots, then the search is complete.\nIf the bucket is full, then it is possible that the desired\nrecord is stored in the overflow bucket.\nIn this case, the overflow bucket must be searched until the record is\nfound or all records in the overflow bucket have been checked.\nIf many records are in the overflow bucket, this will be an\nexpensive process.", "Now you can try it yourself."], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "buckethashCON1", "@long_name": "buckethashCON1", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "HashBucketPRO", "@long_name": "HashBucketPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "an-alternate-approach", "@names": "an\\ alternate\\ approach", "title": "An Alternate Approach", "paragraph": ["A simple variation on bucket hashing is to hash a key value to some slot\nin the hash table as though bucketing were not being used.\nIf the home position is full, then we search through the rest of the\nbucket to find an empty slot.\nIf all slots in this bucket are full, then the record is assigned\nto the overflow bucket.\nThe advantage of this approach is that initial collisions are reduced,\nbecause any slot can be a home position rather than just the first slot\nin the bucket.", "Bucket methods are good for implementing hash tables stored on disk,\nbecause the bucket size can be set to the size of a disk block.\nWhenever search or insertion occurs, the entire bucket is read\ninto memory.\nBecause the entire bucket is then in memory, processing an insert or\nsearch operation requires only one disk access,\nunless the bucket is full.\nIf the bucket is full, then the overflow bucket must be retrieved\nfrom disk as well.\nNaturally, overflow should be kept small to minimize unnecessary disk\naccesses."], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "buckethashCON2", "@long_name": "buckethashCON2", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "HashBucket2PRO", "@long_name": "HashBucket2PRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/buckethashCON1.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/buckethashCON2.js"}]}]}}