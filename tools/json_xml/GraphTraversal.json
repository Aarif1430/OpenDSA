{"document": {"@dupnames": "graph\\ traversals", "@ids": "graph-traversals", "@source": "<string>", "@title": "Graph Traversals", "title": "Graph Traversals", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@dupnames": "graph\\ traversals", "@ids": "id1", "title": "Graph Traversals", "paragraph": [{"title_reference": ["traversal", "tree traversal <BinaryTreeTraversal>"], "#text": "Many graph applications need to visit the vertices of a graph in some\nspecific order based on the graph's topology.\nThis is known as a graph  and is similar in concept\nto a .\nRecall that tree traversals visit every node exactly once, in some\nspecified order such as preorder, inorder, or postorder.\nMultiple tree traversals exist because various applications require\nthe nodes to be visited in a particular order.\nFor example, to print a BST's nodes in ascending order requires an\ninorder traversal as opposed to some other\ntraversal.\nStandard graph traversal orders also exist.\nEach is appropriate for solving certain problems.\nFor example, many problems in artificial intelligence programming\nare modeled using graphs.\nThe problem domain might consist of a large collection of states,\nwith connections between various pairs of states.\nSolving this sort of problem requires getting from a specified start\nstate to a specified goal state by moving between states only\nthrough the connections.\nTypically, the start and goal states are not directly connected.\nTo solve this problem, the vertices of the graph must be searched in\nsome organized manner."}, "Graph traversal algorithms typically begin with a start vertex and\nattempt to visit the remaining vertices from there.\nGraph traversals must deal with a number of troublesome cases.\nFirst, it might not be possible to reach all vertices from the start\nvertex.\nThis occurs when the graph is not connected.\nSecond, the graph might contain cycles, and we must make sure that\ncycles do not cause the algorithm to go into an infinite loop.", {"literal": ["VISITED", "VISITED"], "#text": "Graph traversal algorithms can solve both of these problems\nby flagging vertices as  when appropriate.\nAt the beginning of the algorithm, no vertex is flagged as .\nThe flag for a vertex is set when the vertex is first visited\nduring the traversal.\nIf a flagged vertex is encountered during traversal, it is not visited\na second time.\nThis keeps the program from going into an infinite loop when it\nencounters a cycle."}, {"literal": ["VISITED", "graphTraverse"], "title_reference": "mathbf{G}", "#text": "Once the traversal algorithm completes, we can check to see if all\nvertices have been processed by checking whether they have the\n flag set.\nIf not all vertices are flagged,\nwe can continue the traversal from another unvisited vertex.\nNote that this process works regardless of whether the graph is\ndirected or undirected.\nTo ensure visiting all vertices,  could be called\nas follows on a graph :"}, {"literal": "doTraversal", "#text": "Function  might be implemented by using\none of the graph traversals described next."}], "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}}, {"@ids": "depth-first-search", "@names": "depth-first\\ search", "title": "Depth-First Search", "raw": [{"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "graphDFS", "@long_name": "graphDFS", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "graphDFSPE", "@long_name": "graphDFSPE", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}], "paragraph": [{"title_reference": ["depth-first search", "v", "v", "v", "depth-first search tree"], "#text": "The first method of organized graph traversal is called\n (DFS).\nWhenever a vertex  is visited during the search,\nDFS will recursively visit all of  's unvisited neighbors.\nEquivalently, DFS will add all edges leading out of  to a\nstack.\nThe next vertex to be visited is determined by popping the stack and\nfollowing that edge.\nThe effect is to follow one branch through the graph to its\nconclusion, then it will back up and follow another branch, and so on.\nThe DFS process can be used to define a\n.\nThis tree is composed of the edges that were followed to any new\n(unvisited) vertex during the traversal, and leaves out the edges that\nlead to already visited vertices.\nDFS can be applied to directed or undirected graphs."}, "Here is an implementation for the DFS algorithm.", {"literal": ["PreVisit", "PostVisit", "PostVisit"], "emphasis": "after", "title_reference": "visitor design pattern <visitor design pattern> <DesignPatterns>", "#text": "This implementation contains calls to functions  and\n.\nThese functions specify what activity should take place during the\nsearch.\nJust as a preorder tree traversal requires action before the subtrees\nare visited, some graph traversals require that a vertex be processed\nbefore ones further along in the DFS.\nAlternatively, some applications require activity  the\nremaining vertices are processed; hence the call to function\n.\nThis would be a natural opportunity to make use of the\n."}, "This visualization shows a graph and the result of performing a DFS on\nit, resulting in a depth-first search tree.", {"title_reference": "Theta(|mathbf{V}| + |mathbf{E}|)", "#text": "DFS processes each edge once in a directed graph.\nIn an undirected graph, DFS processes each edge from both\ndirections.\nEach vertex must be visited, but only once, so the total cost is\n."}, "Here is an exercise to practice DFS."]}, {"@ids": "breadth-first-search", "@names": "breadth-first\\ search", "title": "Breadth-First Search", "paragraph": [{"title_reference": "breadth-first search", "#text": "Our second graph traversal algorithm is known as a\n (BFS).\nBFS examines all vertices connected to the start vertex\nbefore visiting vertices further away.\nBFS is implemented similarly to DFS, except that a queue\nreplaces the recursion stack.\nNote that if the graph is a tree and the start vertex is at the root,\nBFS is equivalent to visiting vertices level by level from top to\nbottom."}, "Here is an implementation for BFS.", "Here is an AV for you to try it on other graphs.", "Here is an exercise to practice BFS."], "raw": [{"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "graphBFS", "@long_name": "graphBFS", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "graphBFSPE", "@long_name": "graphBFSPE", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}]}]}}