<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="limits-to-computing" names="limits\ to\ computing" source="&lt;string&gt;" title="Limits to Computing"><title>Limits to Computing</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>By now you have studied many data structures that can be used in a
wide variety of problems, and many examples of efficient algorithms.
In general, our search algorithms strive to be at worst in
<math>O(\log n)</math> to find a record,
and our sorting algorithms strive to be in <math>O(n \log n)</math>.
You might have come across a few algorithms have higher asymptotic
complexity.
Both
<title_reference>Floyd's all-pairs shortest-paths algorithm &lt;Floyd's algorithm&gt; &lt;Floyd&gt;</title_reference>
and standard matrix multiply
have running times of <math>\Theta(n^3)</math>
(though for both, the amount of data being processed is
<math>\Theta(n^2)</math> since they both act on <math>n \times n</math>
matricies).</paragraph><paragraph>We can solve many problems efficiently because we have available
(and choose to use) efficient algorithms.
Given any problem for which you know <emphasis>some</emphasis> algorithm, it is
always possible to write an inefficient algorithm to
"solve" the problem.
For example, consider a sorting algorithm that tests every possible
permutation of its input until it finds the correct permutation that
provides a sorted list.
The running time for this algorithm would be unacceptably
high, because it is proportional to the number of permutations which
is <math>n!</math> for <math>n</math> inputs.
When solving the
<title_reference>minimum-cost spanning tree problem &lt;MCST&gt; &lt;MCST&gt;</title_reference>,
if we were to
test every possible subset of edges to see which forms the shortest
minimum spanning tree, the amount of work would be proportional to
<math>2^{|{\rm E}|}</math> for a graph with <math>|{\rm E}|</math> edges.
Fortunately, for both of these problems we have more clever
algorithms that allow us to find answers (relatively) quickly without
explicitly testing every possible solution.</paragraph><paragraph>Unfortunately, there are many computing problems for which the best
possible algorithm takes a long time to run.
A simple example is the
<title_reference>Towers of Hanoi problem &lt;Towers of Hanoi problem&gt; &lt;Recursion&gt;</title_reference>
which requires <math>2^n</math> moves to "solve" a tower with <math>n</math>
disks.
It is not possible for any computer program that solves the Towers of
Hanoi problem to run in less than <math>\Omega(2^n)</math> time, because
that many moves must be printed out.</paragraph><paragraph>Besides those problems whose solutions <emphasis>must</emphasis> take a long time
to run, there are also many problems for which we simply do not know if
there are efficient algorithms or not.
The best algorithms that we know for such problems are very slow, but
perhaps there are better ones waiting to be discovered.
Of course, while having a problem with high running time is bad, it is
even worse to have a problem that cannot be solved at all!
Such problems
(which are called
<title_reference>unsolveable problems &lt;unsolveable problem&gt; &lt;Computability&gt;</title_reference>)
do exist.
The classic example of such a problem is deciding whether an arbitrary
computer program will go into an infinite loop when processing a
specified input.
This is known as the <title_reference>halting problem</title_reference>.</paragraph></document>