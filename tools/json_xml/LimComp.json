{"document": {"@ids": "limits-to-computing", "@names": "limits\\ to\\ computing", "@source": "<string>", "@title": "Limits to Computing", "title": "Limits to Computing", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "paragraph": [{"title_reference": ["O(log n)", "O(n log n)", "Floyd's all-pairs shortest-paths algorithm <Floyd's algorithm> <Floyd>", "Theta(n^3)", "Theta(n^2)", "n times n"], "#text": "By now you have studied many data structures that can be used in a\nwide variety of problems, and many examples of efficient algorithms.\nIn general, our search algorithms strive to be at worst in\n to find a record,\nand our sorting algorithms strive to be in .\nYou might have come across a few algorithms have higher asymptotic\ncomplexity.\nBoth\n\nand standard matrix multiply\nhave running times of \n(though for both, the amount of data being processed is\n since they both act on \nmatricies)."}, {"emphasis": "some", "title_reference": ["n!", "n", "minimum-cost spanning tree problem <MCST> <MCST>", "2^{|{rm E}|}", "|{rm E}|"], "#text": "We can solve many problems efficiently because we have available\n(and choose to use) efficient algorithms.\nGiven any problem for which you know  algorithm, it is\nalways possible to write an inefficient algorithm to\n\"solve\" the problem.\nFor example, consider a sorting algorithm that tests every possible\npermutation of its input until it finds the correct permutation that\nprovides a sorted list.\nThe running time for this algorithm would be unacceptably\nhigh, because it is proportional to the number of permutations which\nis  for  inputs.\nWhen solving the\n,\nif we were to\ntest every possible subset of edges to see which forms the shortest\nminimum spanning tree, the amount of work would be proportional to\n for a graph with  edges.\nFortunately, for both of these problems we have more clever\nalgorithms that allow us to find answers (relatively) quickly without\nexplicitly testing every possible solution."}, {"title_reference": ["Towers of Hanoi problem <Towers of Hanoi problem> <Recursion>", "2^n", "n", "Omega(2^n)"], "#text": "Unfortunately, there are many computing problems for which the best\npossible algorithm takes a long time to run.\nA simple example is the\n\nwhich requires  moves to \"solve\" a tower with \ndisks.\nIt is not possible for any computer program that solves the Towers of\nHanoi problem to run in less than  time, because\nthat many moves must be printed out."}, {"emphasis": "must", "title_reference": ["unsolveable problems <unsolveable problem> <Computability>", "halting problem"], "#text": "Besides those problems whose solutions  take a long time\nto run, there are also many problems for which we simply do not know if\nthere are efficient algorithms or not.\nThe best algorithms that we know for such problems are very slow, but\nperhaps there are better ones waiting to be discovered.\nOf course, while having a problem with high running time is bad, it is\neven worse to have a problem that cannot be solved at all!\nSuch problems\n(which are called\n)\ndo exist.\nThe classic example of such a problem is deciding whether an arbitrary\ncomputer program will go into an infinite loop when processing a\nspecified input.\nThis is known as the ."}]}}