{"document": {"@dupnames": "tree-based\\ indexing", "@ids": "tree-based-indexing", "@source": "<string>", "@title": "Tree-based Indexing", "title": "Tree-based Indexing", "subtitle": {"@dupnames": "tree-based\\ indexing", "@ids": "id1", "#text": "Tree-based Indexing"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Indexing/treeIndexingCON.css"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "pagedBSTCON", "@long_name": "pagedBSTCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "rebalanceBSTCON", "@long_name": "rebalanceBSTCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "TreeIndexing", "@long_name": "TreeIndexing", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Indexing/pagedBSTCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Indexing/rebalanceBSTCON.js"}], "paragraph": ["Linear indexing is efficient when the database is static,\nthat is, when records are inserted and deleted rarely or never.\nISAM is adequate for a limited number of updates, but not for frequent\nchanges.\nBecause it has essentially two levels of indexing, ISAM will also break\ndown for a truly large database where the number of cylinders is too\ngreat for the top-level index to fit in main memory.", "In their most general form, database applications have the following\ncharacteristics:", "For such databases, a better organization must be found.\nOne approach would be to use the binary search tree (BST) to store\nprimary and secondary key indices.\nBSTs can store duplicate key values, they provide efficient insertion\nand deletion as well as efficient search, and they can perform\nefficient range queries.\nWhen there is enough main memory, the BST is a viable\noption for implementing both primary and secondary key indices.", {"title_reference": ["Theta(log n)", "B", "B"], "#text": "Unfortunately, the BST can become unbalanced.\nEven under relatively good conditions, the depth of leaf nodes\ncan easily vary by a factor of two.\nThis might not be a significant concern when the tree is stored in\nmain memory because the time required is still \nfor search and update.\nWhen the tree is stored on disk, however, the depth of nodes in the\ntree becomes crucial.\nEvery time a BST node  is visited, it is necessary to visit\nall nodes along the path from the root to .\nEach node on this path must be retrieved from disk.\nEach disk access returns a block of information.\nIf a node is on the same block as its parent, then the cost to find\nthat node is trivial once its parent is in main memory.\nThus, it is desirable to keep subtrees together on the same\nblock.\nUnfortunately, many times a node is not on the same block as its\nparent.\nThus, each access to a BST node could potentially require that another\nblock to be read from disk.\nUsing a buffer pool to store multiple blocks in\nmemory can mitigate disk access problems if BST accesses display good\nlocality of reference.\nBut a buffer pool cannot eliminate disk I/O entirely.\nThe problem becomes greater if the BST is unbalanced, because nodes deep\nin the tree have the potential of causing many disk blocks to be read.\nThus, there are two significant issues that must be addressed\nto have efficient search from a disk-based BST.\nThe first is how to keep the tree balanced.\nThe second is how to arrange the nodes on blocks so as to keep the\nnumber of blocks encountered on any path from the root to the leaves at\na minimum."}, "We could select a scheme for balancing the BST and allocating BST\nnodes to blocks in a way that minimizes disk I/O, as illustrated by\nthe first slideshow.\nHowever, maintaining such a scheme in the face of insertions and\ndeletions is difficult.\nIn particular, the tree should remain balanced when an update takes\nplace, but doing so might require much reorganization.\nEach update should affect only a few blocks, or its cost will be\ntoo high.", "As you can see from this slideshow,\nadopting a rule such as requiring the BST to be complete can cause a\ngreat deal of rearranging of data within the tree.", {"title_reference": ["2-3 Tree <2-3 tree> <TwoThreeTree>", "B-tree <B-tree> <BTree>"], "#text": "We can solve these problems by selecting another tree structure that\nautomatically remains balanced after updates, and which is amenable\nto storing in blocks.\nThere are a number of balanced tree data structures, and\nthere are also techniques for keeping BSTs balanced.\nExamples are the AVL and splay trees.\nAs an alternative,\nthe  has the property that its leaves\nare always at the same level.\nThe main reason for discussing the 2-3 Tree here in preference to the\nother balanced search trees is that it naturally\nleads to the , which is by far the\nmost widely used indexing method today."}], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Large sets of records that are frequently updated."}, {"paragraph": "Search is by one or a combination of several keys."}, {"paragraph": "Key range queries or min/max queries are used."}]}}}