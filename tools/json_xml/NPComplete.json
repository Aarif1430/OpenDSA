{"document": {"@ids": "np-completeness", "@names": "np-completeness", "@source": "<string>", "@title": "NP-Completeness", "title": "NP-Completeness", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@ids": "hard-problems", "@names": "hard\\ problems", "title": "Hard Problems", "paragraph": ["There are several ways that a problem could be considered hard.\nFor example, we might have trouble understanding the definition of the\nproblem itself.\nAt the beginning of a large data collection and analysis project,\ndevelopers and their clients might have only a hazy notion of what\ntheir goals actually are, and need to work that out over time.\nFor other types of problems, we might have trouble finding or\nunderstanding an algorithm to solve the problem.\nUnderstanding spoken English and translating it to written text is an\nexample of a problem whose goals are easy to define, but whose\nsolution is not easy to discover.\nBut even though a natural language processing algorithm might be\ndifficult to write, the program's running time might be fairly fast.\nThere are many practical systems today that solve aspects of this\nproblem in reasonable time.", {"title_reference": ["Towers of Hanoi <Towers of Hanoi problem>", "n"], "#text": "None of these is what is commonly meant when a computer\ntheoretician uses the word \"hard\".\nThroughout this section, \"hard\" means that the best-known algorithm\nfor the problem is expensive in its running time.\nOne example of a hard problem is\n.\nIt is easy to understand this problem and its solution.\nIt is also easy to write a program to solve this problem.\nBut, it takes an extremely long time to run for any \"reasonably\"\nlarge value of .\nTry running a program to solve Towers of Hanoi for only 30 disks!"}, {"title_reference": ["Theta(2^n)", "Theta(n log n)", "Theta(n^2)", "Theta(n^4)", "Theta(n^4)"], "#text": "The Towers of Hanoi problem takes exponential time, that is, its\nrunning time is .\nThis is radically different from an algorithm that takes\n time or  time.\nIt is even radically different from a problem that takes\n time.\nThese are all examples of polynomial running time, because the\nexponents for all terms of these equations are constants.\nIf we buy a new computer that runs twice as fast,\nthe size of problem with complexity  that we can\nsolve in a certain amount of time is increased by the fourth root of\ntwo.\nIn other words, there is a multiplicative factor increase, even if it\nis a rather small one.\nThis is true for any algorithm whose running time can be represented\nby a polynomial."}, {"title_reference": "Theta(2^n)", "#text": "Consider what happens if you buy a computer that is twice as fast and\ntry to solve a bigger Towers of Hanoi problem in a given amount of\ntime.\nBecause its complexity is , we can solve a problem\nonly one disk bigger!\nThere is no multiplicative factor, and this is true for any\nexponential algorithm:\nA constant factor increase in processing\npower results in only a fixed addition in problem-solving power."}, "There are a number of other fundamental differences between\npolynomial running times and exponential running times that argues for\ntreating them as qualitatively different.\nPolynomials are closed under composition and addition.\nThus, running polynomial-time programs in sequence, or having one\nprogram with polynomial running time call another a polynomial number\nof times yields polynomial time.\nAlso, all computers known are polynomially related.\nThat is, any program that runs in polynomial time on any computer\ntoday, when transferred to any other computer, will still run in\npolynomial time.", {"title_reference": ["n^{100}", "1.001^n", "(O(c^n))", "c"], "#text": "There is a practical reason for recognizing a distinction.\nIn practice, most polynomial time algorithms are \"feasible\" in that\nthey can run reasonably large inputs in reasonable time.\nIn contrast, most algorithms requiring exponential time are not\npractical to run even for fairly modest sizes of input.\nOne could argue that a program with high polynomial degree\n(such as ) is not practical, while an exponential-time\nprogram with cost  is practical.\nBut the reality is that we know of almost no problems where the best\npolynomial-time algorithm has high degree (they nearly all have\ndegree four or less), while almost no exponential-time algorithms\n(whose cost is  have their constant  close to\none.\nSo there is not much gray area between polynomial and\nexponential time algorithms in practice."}, {"title_reference": ["hard algorithm", "Omega(c^n)", "c > 1"], "emphasis": "problem", "#text": "For the purposes of this Module, we define a \nto be one that runs in exponential time, that is, in\n for some constant .\nA definition for a hard  will be presented soon."}]}, {"@ids": "the-theory-of-np-completeness", "@names": "the\\ theory\\ of\\ np-completeness", "title": "The Theory of NP-Completeness", "paragraph": ["Imagine a magical computer that works by guessing the correct\nsolution from among all of the possible solutions to a problem.\nAnother way to look at this is to imagine a super parallel computer\nthat could test all possible solutions simultaneously.\nCertainly this magical (or highly parallel) computer can do anything a\nnormal computer can do.\nIt might also solve some problems more quickly than a normal computer\ncan.\nConsider some problem where, given a guess for a solution, checking\nthe solution to see if it is correct can be done in polynomial time.\nEven if the number of possible solutions is exponential,\nany given guess can be checked in polynomial time (equivalently, all\npossible solutions are checked simultaneously in polynomial time),\nand thus the problem can be solved in polynomial time by our\nhypothetical magical computer.\nAnother view of this concept is this: If you cannot get the answer\nto a problem in polynomial time by guessing the right answer and then\nchecking it, then you cannot do it in polynomial time in any other way.", {"title_reference": ["non-deterministic choice", "non-deterministic algorithm"], "#text": "The idea of \"guessing\" the right answer to a problem  or checking\nall possible solutions in parallel to determine which is correct\nis a called a .\nAn algorithm that works in this manner is called a\n,\nand any problem with an algorithm that runs on a non-deterministic\nmachine in polynomial time is given a special name:\nIt is said to be a problem in NP.\nThus, problems in NP are those problems that can be solved\nin polynomial time on a non-deterministic machine."}, {"emphasis": "not", "title_reference": ["O(2^n)", "n"], "#text": "Not all problems requiring exponential time on a regular\ncomputer are in NP.\nFor example, Towers of Hanoi is  in NP, because it must\nprint out  moves for  disks.\nA non-deterministic machine cannot \"guess\" and print the correct\nanswer in less time."}, "On the other hand, consider the TRAVELING SALESMAN problem.", {"title_reference": ["Figure #Sales", "Figure #Sales"], "#text": "Figure  illustrates this problem.\nFive vertices are shown, with edges and associated costs between each\npair of edges.\n(For simplicity Figure  shows an undirected graph,\nassuming that the cost is the same in both\ndirections, though this need not be the case.)\nIf the salesman visits the cities in the order ABCDEA, he will travel\na total distance of 13.\nA better route would be ABDCEA, with cost 11.\nThe best route for this particular graph would be ABEDCA, with cost 9."}, {"title_reference": "decision problem", "#text": "We cannot solve this problem in polynomial time with a guess-and-test\nnon-deterministic computer.\nThe problem is that, given a candidate cycle, while we can quickly\ncheck that the answer is indeed a cycle of the appropriate form,\nand while we can quickly calculate the length of the cycle,\nwe have no easy way of knowing if it is in fact the <em>shortest</em>\nsuch cycle.\nHowever, we can solve a variant of this problem cast in the form\nof a .\nA decision problem is simply one whose answer is either YES or NO.\nThe decision problem form of TRAVELING SALESMAN is as follows."}, {"title_reference": ["k", "2^{|{mathrm E}|}"], "emphasis": "some", "#text": "We can solve this version of the problem in polynomial time with a\nnon-deterministic computer.\nThe non-deterministic algorithm simply checks all of the possible\nsubsets of edges in the graph, in parallel.\nIf any subset of the edges is an appropriate cycle of total length\nless than or equal to , the answer is YES; otherwise the\nanswer is NO.\nNote that it is only necessary that  subset meet the\nrequirement; it does not matter how many subsets fail.\nChecking a particular subset is done in polynomial time by adding the\ndistances of the edges and verifying that the edges form a cycle that\nvisits each vertex exactly once.\nThus, the checking algorithm runs in polynomial time.\nUnfortunately, there are  subsets to check,\nso this algorithm cannot be converted to a polynomial time algorithm\non a regular computer.\nNor does anybody in the world know of any other polynomial time\nalgorithm to solve TRAVELING SALESMAN on a regular computer, despite\nthe fact that the problem has been studied extensively by many\ncomputer scientists for many years."}, {"emphasis": "not", "title_reference": "NP-complete", "#text": "It turns out that there is a large collection of\nproblems with this property:\nWe know efficient non-deterministic algorithms, but we do not know if\nthere are efficient deterministic algorithms.\nAt the same time, we have not been able to prove that any of these\nproblems do  have efficient deterministic algorithms.\nThis class of problems is called .\nWhat is truly strange and fascinating about NP-complete problems is\nthat if anybody ever finds the solution to any one of them that runs\nin polynomial time on a regular computer, then by a series of\nreductions, every other problem that is in NP can also be\nsolved in polynomial time on a regular computer!"}, {"title_reference": ["NP-hard", "X", "X", "X"], "emphasis": ["any", "as hard as"], "#text": "Define a problem to be  if  problem in NP\ncan be reduced to  in polynomial time.\nThus,  is  any problem in NP.\nA problem  is defined to be NP-complete if"}, "The requirement that a problem be NP-hard might seem to be impossible,\nbut in fact there are hundreds of such problems,\nincluding TRAVELING SALESMAN.\nAnother such problem is called K-CLIQUE.", {"emphasis": "or", "#text": "Nobody knows whether there is a polynomial time solution for\nK-CLIQUE, but if such an algorithm is found for K-CLIQUE \nfor TRAVELING SALESMAN, then that solution can be modified to solve\nthe other, or any other problem in NP, in polynomial time."}, "The primary theoretical advantage of knowing that a problem P1 is\nNP-complete is that it can be used to show that another problem\nP2 is NP-complete.\nThis is done by finding a polynomial time reduction of\nP1 to P2.\nBecause we already know that all problems in NP can be reduced to P1\nin polynomial time (by the definition of NP-complete), we now know\nthat all problems can be reduced to P2 as well by the simple algorithm\nof reducing to P1 and then from there reducing to P2.", {"emphasis": ["any", "all"], "#text": "There is a practical advantage to knowing that a problem is\nNP-complete.\nIt relates to knowing that if a polynomial time solution can be found\nfor  problem that is NP-complete, then a polynomial\nsolution can be found for  such problems.\nThe implication is that,"}, "How is NP-completeness of practical significance for typical\nprogrammers?\nWell, if your boss demands that you provide a fast algorithm to solve\na problem, she will not be happy if you come back saying that the\nbest you could do was an exponential time algorithm.\nBut, if you can prove that the problem is NP-complete, while she\nstill won't be happy, at least she should not be mad at you!\nBy showing that her problem is NP-complete, you are in effect saying\nthat the most brilliant computer scientists for the last 50 years\nhave been trying and failing to find a polynomial time algorithm for\nher problem.", {"title_reference": "Figure #Complex", "#text": "Problems that are solvable in polynomial time on a regular computer\nare said to be in class P.\nClearly, all problems in P are solvable in polynomial time on a\nnon-deterministic computer simply by neglecting to use the\nnon-deterministic capability.\nSome problems in NP are NP-complete.\nWe can consider all problems solvable in exponential time or better as\nan even bigger class of problems because all problems solvable in\npolynomial time are solvable in exponential time.\nThus, we can view the world of exponential-time-or-better problems in\nterms of Figure ."}, {"title_reference": ["P = NP", "P neq NP"], "emphasis": "all", "#text": "The most important unanswered question in theoretical computer\nscience is whether .\nIf they are equal, then there is a polynomial time\nalgorithm for TRAVELING SALESMAN and all related problems.\nBecause TRAVELING SALESMAN is known to be NP-complete, if a\npolynomial time algorithm were to be found for this problem, then\n problems in NP would also be solvable in polynomial\ntime.\nConversely, if we were able to prove that TRAVELING SALESMAN has an\nexponential time lower bound, then we would know that\n."}], "topic": [{"title": "Problem", "paragraph": ["TRAVELING SALESMAN (1)", {"strong": "Input:", "title_reference": "G", "#text": "A complete, directed graph  with\npositive distances assigned to each edge in the graph."}, {"strong": "Output:", "#text": "The shortest simple cycle that includes every vertex."}]}, {"title": "Problem", "paragraph": ["TRAVELING SALESMAN (2)", {"strong": "Input:", "title_reference": ["G", "k"], "#text": "A complete, directed graph  with\npositive distances assigned to each edge in the graph, and an\ninteger ."}, {"strong": "Output:", "title_reference": ["leq k", "G"], "#text": "YES if there is a simple cycle with total\ndistance  containing every vertex in ,\nand NO otherwise."}]}, {"title": "Problem", "paragraph": ["K-CLIQUE", {"strong": "Input:", "title_reference": ["G", "k"], "#text": "An arbitrary undirected graph  and an\ninteger ."}, {"strong": "Output:", "title_reference": "k", "#text": "YES if there is a complete subgraph of at\nleast  vertices, and NO otherwise."}]}], "target": [{"@refid": "sales"}, {"@refid": "complex"}], "raw": [{"@format": "xml", "@ids": "sales", "@names": "sales", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "clique", "@long_name": "clique", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@ids": "complex", "@names": "complex", "@xml:space": "preserve", "odsafig": "null"}], "enumerated_list": [{"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"title_reference": "X", "#text": "is in NP, and"}}, {"paragraph": {"title_reference": "X", "#text": "is NP-hard."}}]}, {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Because no one has yet found such a solution,\nit must be difficult or impossible to do; and"}, {"paragraph": "Effort to find a polynomial time solution for one\nNP-complete problem can be considered to have been expended for all\nNP-complete problems."}]}]}]}}