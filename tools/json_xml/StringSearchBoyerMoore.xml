<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="boyer-moore\ string\ search\ algorithm" ids="boyer-moore-string-search-algorithm" source="&lt;string&gt;" title="Boyer-Moore String Search Algorithm"><title>Boyer-Moore String Search Algorithm</title><subtitle dupnames="boyer-moore\ string\ search\ algorithm" ids="id1">Boyer-Moore String Search Algorithm</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-13 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>Like the KMP algorithm, a string search algorithm developed by Boyer
and Moore in 1977 initially examines the structure of the string <math>sub</math>
to see if it can be realigned a considerable distance to the right,
when a mismatch occurs.  Unlike the KMP algorithm, the Boyer‑Moore
algorithm compares the characters of the string <math>sub</math> to that of the
<math>master</math> string in a right‑to‑left fashion.  The hope is that
this will allow realignments of considerable magnitude when a mismatch
occurs early in the comparison of <math>sub</math> against a portion of
<math>master</math>.  For instance, suppose that, at the beginning of a
right‑to‑left scan of <math>sub</math> aligned against a portion of
<math>master</math>, we find the character "L" in <math>master</math> and some
other non-matching character in the rightmost index of
<math>sub</math>. Then, if "L" does not occur anywhere else in <math>sub</math>,
<math>sub</math> may be realigned so that the character in index 0 of
<math>sub</math> aligns with the character immediately to the right of “L”
in <math>master</math>. (Why?)  Analogously, if the first "L" to the left
of the final position in <math>sub</math> occurs at index <math>i</math> of
<math>sub</math>, then <math>sub</math> may be realigned so that index <math>i</math>
in <math>sub</math> is aligned with the “L” in <math>master</math>. (Why?) Thus,
when a mismatch occurs at the rightmost (that is, the first examined)
position of <math>sub</math>, the character in <math>master</math> that caused
the mismatch can be used to tell us how much <math>sub</math> can be
realigned to the right. A pre-processing pass through <math>sub</math> could
be used to determine the amount of realignment for any possible
character that could occur in <math>master</math>. This information is
called the "mismatched character heuristic" and is stored in an array
that we will identify by the name <math>MMC</math>.</paragraph><paragraph>To supplement this mismatched character heuristic, the Boyer-Moore
algorithm uses another <math>align</math> array that contains re-alignment
information defined as follows.</paragraph><math_block xml:space="preserve">align[p] = \left\{ \begin{array}{ll} 1 \; \mbox{if} \; p = length(sub) - 1 \mbox{ ,that is, if the last character} \\ suffix\_length + offset \mbox{  otherwise} \end{array} \right.</math_block><paragraph>where <math>suffix\_length</math> is the length of the suffix of the string
beginning at position <math>p + 1</math> and <math>offset</math> is the least
amount this suffix must be moved to the left to match another
occurrence of itself in <math>sub</math> without matching the character in
position in <math>p</math>.  This motion to the left may involve the
leftmost characters "sliding off the end of the master string".  When
this occurs, those characters that have slid off the end of the master
string are viewed as matching the non-existent characters to which
they would be compared.  The computation of the <math>align</math> array
can be tricky.  It somewhat resembles the computation of the KMP
<math>align</math> array but is done "in reverse" because of the
right-to-left scan done by Boyer-Moore.  We will further study the
computation of the <math>align</math> array later in this module.  However,
let us first watch a slideshow of the entire Boyer-Moore algorithm,
under the assumption that both the mismatched character heuristic and
this "reverse KMP" <math>align</math> array have been computed.</paragraph><comment xml:space="preserve">could then be used in a</comment><comment xml:space="preserve">fashion similar to the :math:`align` array in the KMP algorithm. (The</comment><comment xml:space="preserve">full‑blown version of the Boyer‑Moore algorithm actually takes into</comment><comment xml:space="preserve">account possible realignments when the mismatched character does not</comment><comment xml:space="preserve">occur at the rightmost position of :math:`sub`. We omit the details of such a</comment><comment xml:space="preserve">refinement here.  The interested reader should consult “A fast</comment><comment xml:space="preserve">string-searching algorithm” by Robert S. Boyer and J. Strother Moore</comment><comment xml:space="preserve">in Communications of the ACM, 20(10):762-772, 1977.)</comment><comment xml:space="preserve">Slideshow for Boyer-Moore search algorithm</comment><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="Boyer_Moore_Algorithm_Slideshow"
    long_name="Boyer_Moore_Algorithm_Slideshow"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>Now that you've seen how the Boyer-Moore algorithm works once the
mismatched character and reverse KMP alignments have been
pre-computed, use the next two slideshows to study in more detail how
the pre-computation of these two alignment tables would be done.</paragraph><paragraph>Slideshow for Boyer-Moore Mismatched Character Table Construction</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="Boyer_Moore_MMC_Slideshow"
    long_name="Boyer_Moore_MMC_Slideshow"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>Slideshow for Boyer-Moore "Reverse KMP" Alignment Table Construction</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="Boyer_Moore_Align_Table_Slideshow"
    long_name="Boyer_Moore_Align_Table_Slideshow"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>We've seen from the above slideshows that there are really three algorithms at play in Boyer-Moore:</paragraph><paragraph>The main algorithm using two pre-computed re-alignment tables::</paragraph><literal_block xml:space="preserve">m = Sub.length - 1
while m &lt; Master.length:
  s = Sub.length - 1
  while s &gt;= 0 and Master[m] = Sub[s]: m = m-1, s = s-1
  if s &lt; 0: return m+1
  else: m = m + larger_of(MMC[master[m]], Align[s])
return -1</literal_block><paragraph>The algorithm to compute the mismatched character table::</paragraph><literal_block xml:space="preserve">p = current character in alphabet
if alphabet[p] doesn't exist in string then: MMC[p] = string.length
else: MMC[p] = distance from right end of string to furthest right occurrence of alphabet[p] in string.</literal_block><paragraph>And the algorithm to compute the reverse-KMP alignment table::</paragraph><literal_block xml:space="preserve">p = current_index
suffix_length = length of the suffix of string beginning at p+1
offset = least amount that the suffix must be moved left to match another occurrence of itself
                    that isn't preceded by the same character that is at string[p]
if p = string.length()-1 then:
  align[p] = 1
else
  align[p] = suffix_length + offset</literal_block><paragraph>Keeping in mind the pseudocode for these algorithms, test yourself on
Boyer-Moore by completing the following four exercises.</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Exercise in tracing one step of the Boyer-Moore algorithm</paragraph></list_item></enumerated_list><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="Boyer_Moore_Next_Step_Exercise"
    long_name="Boyer_Moore_Next_Step_Exercise"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><enumerated_list enumtype="arabic" prefix="" start="2" suffix="."><list_item><paragraph>Exercise in tracing one step of the Boyer-Moore Mismatched Character Table Construction</paragraph></list_item></enumerated_list><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="Boyer_Moore_MMC_Exercise"
    long_name="Boyer_Moore_MMC_Exercise"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><enumerated_list enumtype="arabic" prefix="" start="3" suffix="."><list_item><paragraph>Exercise in tracing one step of the Boyer-Moore Alignment Table Construction</paragraph></list_item></enumerated_list><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="Boyer_Moore_Alignment_Exercise"
    long_name="Boyer_Moore_Alignment_Exercise"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><enumerated_list enumtype="arabic" prefix="" start="4" suffix="."><list_item><paragraph>Proficiency Exercise in tracing entire Boyer-Moore algorithm</paragraph></list_item></enumerated_list><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="Boyer_Moore_EX_PRO"
    long_name="Boyer_Moore_EX_PRO"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw></document>