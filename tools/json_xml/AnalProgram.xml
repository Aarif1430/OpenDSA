<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="calculating\ program\ running\ time" ids="calculating-program-running-time" source="&lt;string&gt;" title="Calculating Program Running Time"><title>Calculating Program Running Time</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Searching/binarySearchCON.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/AlgAnal/BsearchDandCRecurCON.css</odsalink></raw><section dupnames="calculating\ program\ running\ time" ids="id1"><title>Calculating Program Running Time</title><paragraph>This modules discusses the analysis for several simple code
fragments.
We will make use of the algorithm analysis simplifying rules:</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>If <math>f(n)</math> is in <math>O(g(n))</math> and <math>g(n)</math> is in
<math>O(h(n))</math>, then <math>f(n)</math> is in <math>O(h(n))</math>.</paragraph></list_item><list_item><paragraph>If <math>f(n)</math> is in <math>O(k g(n))</math> for any constant
<math>k &gt; 0</math>, then <math>f(n)</math> is in <math>O(g(n))</math>.</paragraph></list_item><list_item><paragraph>If <math>f_1(n)</math> is in <math>O(g_1(n))</math> and <math>f_2(n)</math> is in
<math>O(g_2(n))</math>, then <math>f_1(n) + f_2(n)</math> is in
<math>O(\max(g_1(n), g_2(n)))</math>.</paragraph></list_item><list_item><paragraph>If <math>f_1(n)</math> is in <math>O(g_1(n))</math> and <math>f_2(n)</math> is in
<math>O(g_2(n))</math>, then <math>f_1(n) f_2(n)</math> is in
<math>O(g_1(n) g_2(n))</math>.</paragraph></list_item></enumerated_list><target refid="assignanal"></target><topic ids="assignanal" names="assignanal"><title>Example</title><paragraph>We begin with an analysis of a simple assignment to an integer
variable.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>Because the assignment statement takes constant time, it is
<math>\Theta(1)</math>.</paragraph></topic><target refid="flanal"></target><topic ids="flanal" names="flanal"><title>Example</title><paragraph>Consider a simple <literal>for</literal> loop.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>The first line is <math>\Theta(1)</math>.
The <literal>for</literal> loop is repeated <math>n</math> times.
The third line takes constant time so, by simplifying rule (4),
the total cost for executing
the two lines making up the <literal>for</literal> loop is <math>\Theta(n)</math>.
By rule (3), the cost of the entire code fragment is also
<math>\Theta(n)</math>.</paragraph></topic><topic><title>Example</title><paragraph>We now analyze a code fragment with several <literal>for</literal>
loops, some of which are nested.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>This code fragment has three separate statements: the
first assignment statement and the two <literal>for</literal> loops.
Again the assignment statement takes constant time;
call it <math>c_1</math>.
The second <literal>for</literal> loop is just like the one in
Example <title_reference>#FLAnal</title_reference> and takes <math>c_2 n = \Theta(n)</math> time.</paragraph><paragraph>The first <literal>for</literal> loop is a double loop and requires a special
technique.
We work from the inside of the loop outward.
The expression <literal>sum++</literal> requires constant time; call it
<math>c_3</math>.
Because the inner <literal>for</literal> loop is executed <math>j</math> times,
by simplifying rule (4) it has cost <math>c_3j</math>.
The outer <literal>for</literal> loop is executed <math>n</math> times, but each time
the cost of the inner loop is different because it costs
<math>c_3j</math> with <math>j</math> changing each time.
You should see that for the first execution of the outer loop,
<math>j</math> is 1.
For the second execution of the outer loop, <math>j</math> is 2.
Each time through the outer loop, <math>j</math> becomes one greater,
until the last time through the loop when <math>j = n</math>.
Thus, the total cost of the loop is <math>c_3</math> times the sum of
the integers 1 through <math>n</math>.
We know that</paragraph><math_block xml:space="preserve">\sum_{i = 1}^{n} i = \frac{n (n+1)}{2},</math_block><paragraph>which is <math>\Theta(n^2)</math>.
By simplifying rule (3), <math>\Theta(c_1 + c_2 n + c_3 n^2)</math> is
simply <math>\Theta(n^2)</math>.</paragraph></topic><topic><title>Example</title><paragraph>Compare the asymptotic analysis for the following two code
fragments.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>In the first double loop, the inner <literal>for</literal> loop always executes
<math>n</math> times.
Because the outer loop executes <math>n</math> times, it should be
obvious that the statement <literal>sum1++</literal> is executed precisely
<math>n^2</math> times.
The second loop is similar to the one analyzed in the previous
example, with cost <math>\sum_{j = 1}^{n} j</math>.
This is approximately <math>{1 \over 2} n^2</math>.
Thus, both double loops cost <math>\Theta(n^2)</math>, though the second
requires about half the time of the first.</paragraph></topic><topic><title>Example</title><paragraph>Not all doubly nested <literal>for</literal> loops are <math>\Theta(n^2)</math>.
The following pair of nested loops illustrates this fact.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>When analyzing these two code fragments, we will assume that
<math>n</math> is a power of two.
The first code fragment has its outer <literal>for</literal> loop executed
<math>\log n+1</math> times because on each iteration <math>k</math> is
multiplied by two until it reaches <math>n</math>.
Because the inner loop always executes <math>n</math> times,
the total cost for the first code fragment can be expressed as</paragraph><math_block xml:space="preserve">\sum_{i=0}^{\log n} n = n \log n.</math_block><paragraph>So the cost of this first double loop is <math>\Theta(n \log n)</math>.
Note that a variable substitution takes place here to create the
summation, with <math>k = 2^i</math>.</paragraph><paragraph>In the second code fragment, the outer loop is also executed
<math>\log n+1</math> times.
The inner loop has cost <math>k</math>, which doubles each time.
The summation can be expressed as</paragraph><math_block xml:space="preserve">\sum_{i=0}^{\log n} 2^i = \Theta(n)</math_block><paragraph>where <math>n</math> is assumed to be a power of two and again
<math>k = 2^i</math>.</paragraph></topic><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>What about other control statements?
<literal>While</literal> loops are analyzed in a manner similar to <literal>for</literal>
loops.
The cost of an <literal>if</literal> statement in the worst case is the greater of
the costs for the <literal>then</literal> and <literal>else</literal> clauses.
This is also true for the average case, assuming that
the size of <math>n</math> does not affect the probability of executing one
of the clauses (which is usually, but not necessarily, true).
For <literal>switch</literal> statements, the worst-case cost is that of the most
expensive branch.
For subroutine calls, simply add the cost of executing the subroutine.</paragraph><paragraph>There are rare situations in which the probability for executing the
various branches of an <literal>if</literal> or <literal>switch</literal> statement are
functions of the input size.
For example, for input of size <math>n</math>, the <literal>then</literal> clause of an
<literal>if</literal> statement might be executed with probability <math>1/n</math>.
An example would be an <literal>if</literal> statement that executes the
<literal>then</literal> clause only for the smallest of <math>n</math> values.
To perform an average-case analysis for such programs,
we cannot simply count the cost of the <literal>if</literal>
statement as being the cost of the more expensive branch.
In such situations, the technique of
<title_reference>amortized analysis &lt;amortized analysis&gt; &lt;AmortAnal&gt;</title_reference> can come to
the rescue.</paragraph><paragraph>Determining the execution time of a recursive
subroutine can be difficult.
The running time for a recursive subroutine is
typically best expressed by a recurrence relation.
For example, the recursive factorial function
calls itself with a value one less than its input value.
The result of this recursive call is then multiplied by the input
value, which takes constant time.
Thus, the cost of the factorial function, if we wish to measure cost
in terms of the number of multiplication operations,
is one more than the number of multiplications made by the recursive
call on the smaller input.
Because the base case does no multiplications, its cost is zero.
Thus, the running time for this function can be expressed as</paragraph><math_block xml:space="preserve">\Theta(n) = \Theta(n-1) + 1 \ \mbox{for}\ n&gt;1;\ \ T(1) = 0.</math_block><paragraph>The closed-form solution for this
recurrence relation is <math>\Theta(n)</math>.</paragraph><section ids="case-study-two-search-algorithms" names="case\ study:\ two\ search\ algorithms"><title>Case Study: Two Search Algorithms</title><paragraph>The final example of algorithm analysis for this section will compare
two algorithms for performing search in an array.
Earlier, we determined that the running time for sequential search on
an array where the search value <math>K</math> is equally likely to appear
in any location is <math>\Theta(n)</math> in both the average and worst
cases.
We would like to compare this running time to that required to perform
a <title_reference>binary search</title_reference> on an array whose values are stored in order
from lowest to highest.
Here is a visualization of the binary search method.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="binarySearchCON"
    long_name="binarySearchCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></section><section ids="binary-search-practice-exercise" names="binary\ search\ practice\ exercise"><title>Binary Search Practice Exercise</title><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="binarySearchPRO"
    long_name="binarySearchPRO"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw></section><section ids="analyzing-binary-search" names="analyzing\ binary\ search"><title>Analyzing Binary Search</title><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="BsearchDandCRecurCON"
    long_name="BsearchDandCRecurCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Function <literal>binarySearch</literal> is designed to find the (single) occurrence of
<math>K</math> and return its position.
A special value is returned if <math>K</math> does not appear in the array.
This algorithm can be modified to implement variations
such as returning the position of the first
occurrence of <math>K</math> in the array if multiple occurrences are
allowed, and returning the position of the greatest value less than
<math>K</math> when <math>K</math> is not in the array.</paragraph><paragraph>Comparing sequential search to binary search, we see that as <math>n</math>
grows, the <math>\Theta(n)</math> running time for sequential search in the
average and worst cases quickly becomes much greater than the
<math>\Theta(\log n)</math> running time for binary search.
Taken in isolation, binary search appears to be much more
efficient than sequential search.
This is despite the fact that the constant factor for binary search is
greater than that for sequential search, because the calculation for
the next search position in binary search is more expensive than just
incrementing the current position, as sequential search does.</paragraph><paragraph>Note however that the running time for sequential search will be
roughly the same regardless of whether or not the array values are
stored in order.
In contrast, binary search requires that the array values be ordered
from lowest to highest.
Depending on the context in which binary search is to be used, this
requirement for a sorted array could be detrimental to the running
time of a complete program, because  maintaining the values in sorted
order requires a greater cost when inserting new elements into the
array.
This is an example of a tradeoff between the
advantage of binary search during search and the disadvantage related
to maintaining a sorted array.
Only in the context of the complete problem to be solved can we know
whether the advantage outweighs the disadvantage.</paragraph></section></section><section ids="summary-exercise" names="summary\ exercise"><title>Summary Exercise</title><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="AnalProgramSumm"
    long_name="AnalProgramSumm"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Searching/binarySearchCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/AlgAnal/BsearchDandCRecurCON.js</odsascript></raw></section></document>