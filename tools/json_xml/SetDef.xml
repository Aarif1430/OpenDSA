<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="sets-and-relations" names="sets\ and\ relations" source="&lt;string&gt;" title="Sets and Relations"><title>Sets and Relations</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><section ids="set-notation" names="set\ notation"><title>Set Notation</title><paragraph>The concept of a set in the mathematical sense has wide
application in computer science.
The notations and techniques of set theory are commonly used
when describing and implementing algorithms because the abstractions
associated with sets often help to clarify and simplify algorithm
design.</paragraph><paragraph>A <title_reference>set</title_reference> is a collection of distinguishable
<title_reference>members &lt;member&gt;</title_reference> or <title_reference>elements &lt;element&gt;</title_reference>.
The members are typically drawn from some larger population known as
the <title_reference>base type</title_reference>.
Each member of a set is either a <title_reference>primitive element</title_reference> of the
base type or is a set itself.
There is no concept of duplication in a set.
Each value from the base type is either in the set or not in the set.
For example, a set named <title_reference>mathbf{P}</title_reference> might consist of the three
integers 7, 11, and 42.
In this case, <title_reference>mathbf{P}</title_reference>'s members are 7, 11, and 42, and the
base type is integer.</paragraph><paragraph>The following table shows the symbols commonly used to express sets
and their relationships.</paragraph><target refid="setnotation"></target><topic ids="setnotation" names="setnotation"><title>Table</title><math_block xml:space="preserve">\begin{array}{l|l}
\{1, 4\}&amp; \mbox{A set composed of the members 1 and 4}\\
\{\mathsf{x}\, |\, \mathsf{x}\ \mbox{is a positive integer}\}&amp;
   \mbox{A set definition using a set former}\\
&amp;\qquad \mbox{Example: the set of all positive integers}\\
\mathsf{x} \in \mathbf{P}&amp;\mathsf{x}\ \mbox{is a member of set}\ \mathbf{P}\\
\mathsf{x} \notin \mathbf{P}&amp;\mathsf{x}\ \mbox{is not a member of set}\ \mathbf{P}\\
\emptyset&amp;\mbox{The null or empty set}\\
|\mathbf{P}|&amp; \mbox{Cardinality: size of set}\ \mathbf{P}
           \mbox{or number of members for set}\ \mathbf{P}\\
\mathbf{P}\,\subseteq\,\mathbf{Q},
  \mathbf{Q}\,\supseteq\,\mathbf{P}&amp;
  \mbox{Set}\ \mathbf{P}\ \mbox{is included in set}\ \mathbf{Q},\\
&amp;\qquad \mbox{set}\ \mathbf{P}\ \mbox{is a subset of set}\ \mathbf{Q},\\
&amp;\qquad \mbox{set}\ \mathbf{Q}\ \mbox{is a superset of set}\ \mathbf{P}\\
\mathbf{P}\,\cup\,\mathbf{Q}      &amp;
  \mbox{Set Union: all elements appearing in}
  \ \mathbf{P}\ \mbox{OR}\ \mathbf{Q}\\
\mathbf{P}\,\cap\,\mathbf{Q}      &amp;
  \mbox{Set Intersection: all elements appearing in}\ \mbox{P}
  \ \mbox{AND}\ \mathbf{Q}\\
\mathbf{P}\,-\,\mathbf{Q} &amp;
  \mbox{Set difference: all elements of set}
  \ \mathbf{P}\ \mbox{NOT in set}\ \mathbf{Q}\\
\end{array}</math_block></topic><paragraph>Here are some examples of this notation in use.
First define two sets, <title_reference>mathbf{P}</title_reference> and <title_reference>mathbf{Q}</title_reference>.</paragraph><math_block xml:space="preserve">\mathbf{P} = \{2, 3, 5\}, \qquad \mathbf{Q} = \{5, 10\}.</math_block><paragraph><title_reference>|mathbf{P}| = 3</title_reference>  (because <title_reference>mathbf{P}</title_reference> has three
members) and <title_reference>|mathbf{Q}| = 2</title_reference>
(because <title_reference>mathbf{Q}</title_reference> has two members).
The union of <title_reference>mathbf{P}</title_reference> and <title_reference>mathbf{Q}</title_reference>, written
<title_reference>mathbf{P} cup mathbf{Q}</title_reference>, is the set of elements in either
<title_reference>mathbf{P}</title_reference> or <title_reference>mathbf{Q}</title_reference>, which is {2, 3, 5, 10}.
The intersection of <title_reference>mathbf{P}</title_reference> and <title_reference>mathbf{Q}</title_reference>,
written <title_reference>mathbf{P} cap mathbf{Q}</title_reference>, is the set of elements that
appear in both <title_reference>mathbf{P}</title_reference> and <title_reference>mathbf{Q}</title_reference>, which is {5}.
The set difference of <title_reference>mathbf{P}</title_reference> and <title_reference>mathbf{Q}</title_reference>,
written <title_reference>mathbf{P} - mathbf{Q}</title_reference>,
is the set of elements that occur in <title_reference>mathbf{P}</title_reference> but not in
<title_reference>mathbf{Q}</title_reference>, which is {2, 3}.
Note that
<title_reference>mathbf{P} cup mathbf{Q} = mathbf{Q} cup mathbf{P}</title_reference>
and that
<title_reference>mathbf{P} cap mathbf{Q} = mathbf{Q} cap mathbf{P}</title_reference>,
but in general
<title_reference>mathbf{P} - mathbf{Q} neq mathbf{Q} - mathbf{P}</title_reference>.
In this example,
<title_reference>mathbf{Q} - mathbf{P}  = {10}</title_reference>.
Finally, the set {5, 3, 2} is indistinguishable from set
<title_reference>mathbf{P}</title_reference>, because sets have no concept of order.
Likewise, set {2, 3, 2, 5} is also indistinguishable from
<title_reference>mathbf{P}</title_reference>, because sets have no concept of duplicate elements.</paragraph><paragraph>The <title_reference>powerset</title_reference> of a set <title_reference>mathbf{S}</title_reference> is the set of all
possible subsets for <title_reference>mathbf{S}</title_reference>.
Consider the set <title_reference>mathbf{S} = { a, b, c }</title_reference>.
The powerset of <title_reference>mathbf{S}</title_reference> is</paragraph><math_block xml:space="preserve">\{ \emptyset,\ \{a\},\ \{b\},\ \{c\},\ \{a, b\},
\ \{a, c\},\ \{b, c\},\ \{a, b, c\}\}.</math_block><paragraph>A collection of elements with no order (like a set), but with
duplicate-valued elements is called a
<title_reference>bag</title_reference> .
To distinguish bags from sets, we will use square brackets [] around
a bag's elements.
For example, bag [3, 4, 5, 4] is distinct from bag [3, 4, 5],
while set {3, 4, 5, 4} is indistinguishable from set
{3, 4, 5}.
However, bag [3, 4, 5, 4] is indistinguishable from bag
[3, 4, 4, 5].</paragraph><paragraph>A <title_reference>sequence</title_reference> is a collection of elements with an order, and
which may contain duplicate-valued elements.
A sequence is also sometimes called a <title_reference>tuple</title_reference> or a
<title_reference>vector</title_reference>.
In a sequence, there is a 0th element, a 1st element, 2nd element, and
so on.
We will use angle brackets <title_reference>langlerangle</title_reference> to enclose the
elements of a sequence.
For example, <title_reference>langle3, 4, 5, 4rangle</title_reference> is a sequence.
Note that sequence <title_reference>langle3, 5, 4, 4rangle</title_reference> is distinct from
sequence <title_reference>langle3, 4, 5, 4rangle</title_reference>, and both are distinct from
sequence <title_reference>langle3, 4, 5rangle</title_reference>.</paragraph><footnote auto="1" ids="id1" names="1"><label>1</label><paragraph>The object referred to here as a
bag is sometimes called a
<title_reference>multilist &lt;multilist&gt; &lt;Multilists&gt;</title_reference>.
But, the term multilist also refers to a list that may contain
sublists.</paragraph></footnote></section><section ids="relations" names="relations"><title>Relations</title><paragraph>A <title_reference>relation</title_reference> <title_reference>R</title_reference> over set <title_reference>mathbf{S}</title_reference> is a set of
ordered pairs from <title_reference>mathbf{S}</title_reference>.
As an example of a relation, if <title_reference>mathbf{S}</title_reference> is
<title_reference>{a, b, c}</title_reference>, then</paragraph><math_block xml:space="preserve">\{ \langle a, c\rangle, \langle b, c\rangle, \langle c, b\rangle \}</math_block><paragraph>is a relation, and</paragraph><math_block xml:space="preserve">\{ \langle a, a\rangle, \langle a, c\rangle, \langle b, b\rangle,
\langle b, c\rangle, \langle c, c\rangle \}</math_block><paragraph>is a different relation.
If tuple <title_reference>langle x, yrangle</title_reference> is in relation <title_reference>R</title_reference>, we may
use the infix notation <title_reference>xRy</title_reference>.
We often use relations such as the less than operator (<title_reference>&lt;</title_reference>) on
the natural numbers, which includes ordered pairs such as
<title_reference>langle1, 3rangle</title_reference> and
<title_reference>langle2, 23rangle</title_reference>, but not <title_reference>langle3, 2rangle</title_reference> or
<title_reference>langle2, 2rangle</title_reference>.
Rather than writing the relationship in terms of ordered pairs, we
typically use an infix notation for such relations, writing <title_reference>1&lt;3</title_reference>.</paragraph><paragraph>Define the properties of relations as follows, with <title_reference>R</title_reference> a
binary relation over set <title_reference>mathbf{S}</title_reference>.</paragraph><bullet_list bullet="*"><list_item><paragraph><title_reference>R</title_reference> is <title_reference>reflexive</title_reference> if <title_reference>aRa</title_reference>
for all <title_reference>a in mathbf{S}</title_reference>.</paragraph></list_item><list_item><paragraph><title_reference>R</title_reference> is <title_reference>irreflexive</title_reference> if <title_reference>aRa</title_reference> is not true
for all <title_reference>a in mathbf{S}</title_reference>.</paragraph></list_item><list_item><paragraph><title_reference>R</title_reference> is <title_reference>symmetric</title_reference> if whenever <title_reference>aRb</title_reference>,
then <title_reference>bRa</title_reference>, for all <title_reference>a, b in mathbf{S}</title_reference>.</paragraph></list_item><list_item><paragraph><title_reference>R</title_reference> is <title_reference>antisymmetric</title_reference> if whenever <title_reference>aRb</title_reference>
and <title_reference>bRa</title_reference>, then <title_reference>a = b</title_reference>, for all
<title_reference>a, b in mathbf{S}</title_reference>.</paragraph></list_item><list_item><paragraph><title_reference>R</title_reference> is <title_reference>transitive</title_reference> if whenever <title_reference>aRb</title_reference> and
<title_reference>bRc</title_reference>, then <title_reference>aRc</title_reference>, for all
<title_reference>a, b, c in mathbf{S}</title_reference>.</paragraph></list_item></bullet_list><paragraph>As examples, for the natural numbers, <title_reference>&lt;</title_reference> is
irreflexive (because :math`aRa` is never true),
antisymmetric (because there is no case where <title_reference>aRb</title_reference> and
<title_reference>bRa</title_reference>), and transitive.
Relation <title_reference>leq</title_reference> is reflexive, antisymmetric, and transitive.
Relation <title_reference>=</title_reference> is reflexive, symmetric (and antisymmetric!),
and transitive.
For people, the relation "is a sibling of" is symmetric and
transitive.
If we define a person to be a sibling of himself, then it is
reflexive; if we define a person not to be a sibling of himself, then
it is not reflexive.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="SetTFrelation"
    long_name="SetTFrelation"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="equivalence-relations" names="equivalence\ relations"><title>Equivalence Relations</title><paragraph><title_reference>R</title_reference> is an <title_reference>equivalence relation</title_reference> on set <title_reference>mathbf{S}</title_reference>
if it is reflexive, symmetric, and transitive.
An equivalence relation can be used to partition a set into
<title_reference>equivalence classes &lt;equivalence class&gt;</title_reference>.
If two elements <title_reference>a</title_reference> and <title_reference>b</title_reference> are equivalent to each other,
we write <title_reference>a equiv b</title_reference>.
A <title_reference>partition</title_reference> of a set <title_reference>mathbf{S}</title_reference> is a collection of
subsets that are <title_reference>disjoint</title_reference> from each other and whose union is
<title_reference>mathbf{S}</title_reference>.
An <title_reference>equivalence relation</title_reference> on set <title_reference>mathbf{S}</title_reference> partitions
the set into disjoint subsets whose elements are equivalent.
The <title_reference>UNION/FIND &lt;UNION/FIND&gt; &lt;UnionFind&gt;</title_reference> algorithm efficiently
maintains equivalence classes on a set.
One application for such <title_reference>disjoint sets</title_reference>
computing a <title_reference>minimal cost spanning tree &lt;MCST&gt; &lt;MCST&gt;</title_reference>.</paragraph><topic><title>Example</title><paragraph>For the integers, <title_reference>=</title_reference> is an equivalence relation that
partitions each element into a distinct subset.
In other words, for any integer <title_reference>a</title_reference>, three things are true.</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph><title_reference>a = a</title_reference>,</paragraph></list_item><list_item><paragraph>if <title_reference>a = b</title_reference> then <title_reference>b = a</title_reference>, and</paragraph></list_item><list_item><paragraph>if <title_reference>a = b</title_reference> and <title_reference>b = c</title_reference>, then <title_reference>a = c</title_reference>.</paragraph></list_item></enumerated_list><paragraph>Of course, for distinct integers <title_reference>a</title_reference>, <title_reference>b</title_reference>, and <title_reference>c</title_reference>
there are never cases where <title_reference>a = b</title_reference>, <title_reference>b = a</title_reference>, or
<title_reference>b = c</title_reference>.
So the requirements for symmetry and transitivity are never
violated, and therefore the relation is symmetric and transitive.</paragraph></topic><topic><title>Example</title><paragraph>If we clarify the definition of sibling to mean that a person is
a sibling of him- or herself, then the sibling relation is an
equivalence relation that partitions the set of people.</paragraph></topic><topic><title>Example</title><paragraph>We can use the <title_reference>modulus &lt;MiscMath&gt;</title_reference> function
to define an equivalence relation.
For the set of integers, use the modulus function
to define a binary relation such that two numbers
<title_reference>x</title_reference> and <title_reference>y</title_reference> are in the relation if and only if
<title_reference>x bmod m = y bmod m</title_reference>.
Thus, for <title_reference>m = 4</title_reference>, <title_reference>langle1, 5rangle</title_reference> is in the
relation because <title_reference>1 bmod 4 = 5 bmod 4</title_reference>.
We see that modulus used in this way defines an equivalence
relation on the integers, and this relation can be used to
partition the integers into <title_reference>m</title_reference> equivalence classes.
This relation is an equivalence relation because</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph><title_reference>x bmod m = x bmod m</title_reference> for all <title_reference>x</title_reference>;</paragraph></list_item><list_item><paragraph>if <title_reference>x bmod m = y bmod m</title_reference>,
then <title_reference>y bmod m = x bmod m</title_reference>; and</paragraph></list_item><list_item><paragraph>if <title_reference>x bmod m = y bmod m</title_reference> and
<title_reference>y bmod m = z bmod m</title_reference>, then
<title_reference>x bmod m = z bmod m</title_reference>.</paragraph></list_item></enumerated_list></topic><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="SetTFequivrel"
    long_name="SetTFequivrel"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="partial-orders" names="partial\ orders"><title>Partial Orders</title><paragraph>A binary relation is called a
<title_reference>partial order</title_reference> if it is antisymmetric and transitive.
If the relation is reflexive, it is called a
<title_reference>non-strict partial order</title_reference>.
If the relation is <title_reference>irreflexive</title_reference>, it is called a
<title_reference>strict partial order</title_reference>.
The set on which the partial order is defined is called a
<title_reference>partially ordered set</title_reference> or a <title_reference>poset</title_reference>.
Elements <title_reference>x</title_reference> and <title_reference>y</title_reference> of a set are <title_reference>comparable</title_reference> under
a given relation <title_reference>R</title_reference> if either <title_reference>xRy</title_reference> or <title_reference>yRx</title_reference>.
If every pair of distinct elements in a partial order are comparable,
then the order is called a <title_reference>total order</title_reference> or <title_reference>linear order</title_reference>.</paragraph><topic><title>Example</title><paragraph>For the integers, relations <title_reference>&lt;</title_reference> and <title_reference>leq</title_reference> define
partial orders.
Operation <title_reference>&lt;</title_reference> is a total order because, for every pair of
integers <title_reference>x</title_reference> and <title_reference>y</title_reference> such that <title_reference>x neq y</title_reference>,
either <title_reference>x &lt; y</title_reference> or <title_reference>y &lt; x</title_reference>.
Likewise, <title_reference>leq</title_reference> is a total order because,
for every pair of integers <title_reference>x</title_reference> and <title_reference>y</title_reference> such that
<title_reference>x neq y</title_reference>, either <title_reference>x leq y</title_reference> or <title_reference>y leq x</title_reference>.</paragraph></topic><topic><title>Example</title><paragraph>For the powerset of the integers, the subset
operator defines a partial order (because it is antisymmetric and
transitive).
For example, <title_reference>{1, 2}subseteq{1, 2, 3}</title_reference>.
However, sets {1, 2} and {1, 3} are not comparable by the
subset operator, because neither is a subset of the other.
Therefore, the subset operator does not define a total order on the
powerset of the integers.</paragraph></topic><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="SetTFpartialorder"
    long_name="SetTFpartialorder"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section></document>