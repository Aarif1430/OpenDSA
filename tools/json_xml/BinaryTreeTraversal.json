{"document": {"@dupnames": "binary\\ tree\\ traversals", "@ids": "binary-tree-traversals", "@source": "<string>", "@title": "Binary Tree Traversals", "title": "Binary Tree Traversals", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Binary/BinExampCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Binary/BTCON.css"}], "section": [{"@dupnames": "binary\\ tree\\ traversals", "@ids": "id1", "title": "Binary Tree Traversals", "paragraph": {"title_reference": ["traversal", "enumeration"], "#text": "Often we wish to process a binary tree by \"visiting\" each of its\nnodes, each time performing a specific action such as printing the\ncontents of the node.\nAny process for visiting all of the nodes in some order is\ncalled a .\nAny traversal that lists every node in the tree exactly once is\ncalled an  of the tree's nodes.\nSome applications do not require that the nodes be visited in any\nparticular order as long as each node is visited precisely once.\nFor other applications, nodes must be visited in an order that\npreserves some relationship."}, "section": [{"@ids": "preorder-traversal", "@names": "preorder\\ traversal", "title": "Preorder Traversal", "paragraph": {"emphasis": "before", "title_reference": "preorder traversal", "#text": "For example, we might wish to make sure that we visit any given node\n we visit its children.\nThis is called a ."}, "target": {"@refid": "bintravexample"}, "raw": [{"@format": "xml", "@ids": "bintravexample", "@names": "bintravexample", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "BinExampCON", "@long_name": "BinExampCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "preorderCON", "@long_name": "preorderCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}], "topic": {"title": "Example", "paragraph": [{"title_reference": "Figure #BinTravExample", "strong": "A B D C E G F H I", "#text": "The preorder enumeration for the tree of\nFigure  is\n."}, "The first node printed is the root.\nThen all nodes of the left subtree are printed (in preorder) before\nany node of the right subtree."]}}, {"@ids": "postorder-traversal", "@names": "postorder\\ traversal", "title": "Postorder Traversal", "paragraph": {"emphasis": "after", "title_reference": "postorder traversal", "#text": "Alternatively, we might wish to visit each node only\n we visit its children (and their subtrees).\nFor example, this would be necessary if we wish to return all nodes\nin the tree to free store.\nWe would like to delete the children of a node before deleting the\nnode itself.\nBut to do that requires that the children's children be deleted\nfirst, and so on.\nThis is called a ."}, "topic": {"title": "Example", "paragraph": {"title_reference": "Figure #BinTravExample", "strong": "D B G E H I F C A", "#text": "The postorder enumeration for the tree of\nFigure  is\n."}}, "raw": {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "postorderCON", "@long_name": "postorderCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}}, {"@ids": "inorder-traversal", "@names": "inorder\\ traversal", "title": "Inorder Traversal", "paragraph": {"title_reference": ["inorder traversal", "binary search tree <binary search tree> <BST>"], "#text": "An  first visits the left child\n(including its entire subtree), then visits the node, and finally\nvisits the right child (including its entire\nsubtree).\nThe  makes use of\nthis traversal to print all nodes in ascending order of value."}, "topic": {"title": "Example", "paragraph": {"title_reference": "Figure #BinTravExample", "strong": "B D A G E C H F I", "#text": "The inorder enumeration for the tree of\nFigure  is\n."}}, "raw": {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "inorderCON", "@long_name": "inorderCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}}]}, {"@ids": "implementation", "@names": "implementation", "title": "Implementation", "paragraph": [{"literal": "BinNode", "#text": "Now we will discuss some implementations for the traversals, but we\nneed to define a node ADT to work with.\nJust as a linked list is composed of a collection of link objects, a\ntree is composed of a collection of node objects.\nHere is an ADT for binary tree nodes, called .\nThis class will be used by some of the binary tree structures\npresented later.\nMember functions are provided that set or return the element value,\nreturn a pointer to the left child,\nreturn a pointer to the right child,\nor indicate whether the node is a leaf."}, {"literal": ["rt", "rt", "rt"], "#text": "A traversal routine is naturally written as a recursive\nfunction.\nIts input parameter is a pointer to a node which we will call\n because each node can be viewed as the root of a some\nsubtree.\nThe initial call to the traversal function passes in a pointer to the\nroot node of the tree.\nThe traversal function visits  and its children (if any)\nin the desired order.\nFor example, a preorder traversal specifies that  be\nvisited before its children.\nThis can easily be implemented as follows."}, {"literal": ["preorder", "preorder", "preorder", "visit", "preorder", "preorder"], "#text": "Function  first checks that the tree is not\nempty (if it is, then the traversal is done and \nsimply returns).\nOtherwise,  makes  a call to ,\nwhich processes the root node (i.e., prints the value or performs\nwhatever computation as required by the application).\nFunction  is then called recursively on the left\nsubtree, which will visit all nodes in that subtree.\nFinally,  is called on the right subtree,\nvisiting all nodes in the right subtree.\nPostorder and inorder traversals are similar.\nThey simply change the order in which the node and its children are\nvisited, as appropriate."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "btTravInorderPRO", "@long_name": "btTravInorderPRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}]}, {"@ids": "postorder-traversal-practice", "@names": "postorder\\ traversal\\ practice", "title": "Postorder Traversal Practice", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "btTravPostorderPRO", "@long_name": "btTravPostorderPRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}}, {"@ids": "preorder-traversal-practice", "@names": "preorder\\ traversal\\ practice", "title": "Preorder Traversal Practice", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "btTravPreorderPRO", "@long_name": "btTravPreorderPRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}}, {"@ids": "summary-questions", "@names": "summary\\ questions", "title": "Summary Questions", "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "TravSumm", "@long_name": "TravSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/BinExampCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/inorderCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/preorderCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/postorderCON.js"}]}]}}