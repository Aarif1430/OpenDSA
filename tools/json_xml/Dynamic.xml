<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="dynamic\ storage\ allocation" ids="dynamic-storage-allocation" source="&lt;string&gt;" title="Dynamic Storage Allocation"><title>Dynamic Storage Allocation</title><subtitle dupnames="dynamic\ storage\ allocation" ids="id1">Dynamic Storage Allocation</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/MemManage/dynamicCON.css</odsalink></raw><paragraph>For the purpose of dynamic storage allocation, we view memory as a
single array broken into a series of variable-size blocks, where
some of the blocks are <title_reference>free blocks &lt;free block&gt;</title_reference> and some are
<title_reference>reserved blocks &lt;reserved block&gt;</title_reference> or already allocated.
The free blocks are linked together to form a <title_reference>freelist</title_reference> used
for servicing future <title_reference>memory requests &lt;memory request&gt;</title_reference>.
This figure illustrates the situation that can arise after
a series of memory allocations and deallocations.</paragraph><target refid="memmode"></target><raw format="xml" ids="memmode" names="memmode" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="freeblocklistCON"
    long_name="freeblocklistCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>When a memory request is received by the memory manager, some block
on the freelist must be found that is large enough to service the
request.
If no such block is found, then the memory manager must resort to a
<title_reference>failure policy &lt;failure policy&gt; &lt;Garbage&gt;</title_reference> such as
<title_reference>garbage collection</title_reference>.</paragraph><paragraph>If there is a request for <title_reference>m</title_reference> words, and no block exists of
exactly size <title_reference>m</title_reference>, then a larger block must be used instead.
One possibility in this case is that the entire block is given away
to the memory allocation request.
This might be desirable when the size of the block is only slightly
larger than the request.
This is because saving a tiny block that is too small to be useful for
a future memory request might not be worthwhile.
Alternatively, for a free block of size <title_reference>k</title_reference>,
with <title_reference>k &gt; m</title_reference>, up to <title_reference>k - m</title_reference> space may be
retained by the memory manager to form a new free
block, while the rest is used to service the request.</paragraph><paragraph>Memory managers can suffer from two types of fragmentation.
<title_reference>External fragmentation</title_reference>
occurs when a series of memory requests result in lots of small free
blocks, no one of which is useful for servicing typical requests.
<title_reference>Internal fragmentation</title_reference> occurs when more than <title_reference>m</title_reference> words
are allocated to a request for <title_reference>m</title_reference> words, wasting free storage.
The difference between internal and external fragmentation is
illustrated by this figure.
The small white block labeled "External fragmentation" is too small
to satisfy typical memory requests.
The small grey block labeled "Internal fragmentation" was allocated as
part of the grey block to its left, but it does not actually store
information.</paragraph><target refid="compfrag"></target><raw format="xml" ids="compfrag" names="compfrag" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="fragCON"
    long_name="fragCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Some memory management schemes sacrifice space to internal
fragmentation to make memory management easier (and perhaps reduce
external fragmentation).
For example, external fragmentation does not happen in file management
systems that allocate file space in clusters.
Another example of sacrificing space to internal fragmentation so as
to simplify memory management is the <title_reference>buddy method</title_reference>
described later in this chapter.</paragraph><paragraph>The process of searching the <title_reference>memory pool</title_reference> for a block large
enough to service the request, possibly reserving the remaining space
as a free block, is referred to as a <title_reference>sequential fit</title_reference> method.</paragraph><raw format="xml" xml:space="preserve"><odsascript>AV/MemManage/freeblocklistCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/MemManage/fragCON.js</odsascript></raw></document>