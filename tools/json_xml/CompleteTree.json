{"document": {"@dupnames": "array\\ implementation\\ for\\ complete\\ binary\\ trees", "@ids": "array-implementation-for-complete-binary-trees", "@source": "<string>", "@title": "Array Implementation for Complete Binary Trees", "title": "Array Implementation for Complete Binary Trees", "subtitle": {"@dupnames": "array\\ implementation\\ for\\ complete\\ binary\\ trees", "@ids": "id1", "#text": "Array Implementation for Complete Binary Trees"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@ids": "binarray", "@names": "binarray", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "CompleteFIB", "@long_name": "CompleteFIB", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "paragraph": [{"title_reference": ["full binary tree theorem <BinaryTreeFullThm>", "overhead", "complete binary trees <complete binary tree>", "heap <heap> <Heap>", "priority queues <priority queue>", "external sorting algorithms <external sort> <ExternalSort>"], "math": "n", "#text": "From the , we know\nthat a large fraction of the space in a typical binary tree node\nimplementation is devoted to structural , not to\nstoring data.\nThis module presents a simple, compact implementation\nfor .\nRecall that complete binary trees have all levels except the bottom\nfilled out completely, and the bottom level has all of its nodes filled\nin from left to right.\nThus, a complete binary tree of  nodes has only one possible\nshape.\nYou might think that a complete binary tree is such an unusual\noccurrence that there is no reason to develop a special\nimplementation for it.\nHowever, the complete binary tree has practical uses, the most\nimportant being the  data structure.\nHeaps are often used to implement\n and for\n."}, {"title_reference": ["Figure #BinArray", "Figure #BinArray"], "#text": "We begin by assigning numbers to the node positions in the complete\nbinary tree, level by level, from left to right as shown in\nFigure .\nAn array can store the tree's data values efficiently, placing\neach data value in the array position corresponding to that node's\nposition within the tree.\nThe table lists the array indices for the\nchildren, parent, and siblings of each node in\nFigure ."}, "Here is a table that lists, for each node position, the positions of\nthe parent, sibling, and children of the node.", {"math": ["R", "R", "n", "n"], "#text": "Looking at the table, you should see a pattern\nregarding the positions of a node's relatives within the array.\nSimple formulas can be derived for calculating the array index\nfor each relative of a node  from 's index.\nNo explicit pointers are necessary to reach a node's left or\nright child.\nThis means there is no overhead to the array implementation if the\narray is selected to be of size  for a tree of \nnodes."}, {"math": ["n", "r", "n-1"], "#text": "The formulae for calculating the array indices of the various\nrelatives of a node are as follows.\nThe total number of nodes in the tree is .\nThe index of the node in question is ,\nwhich must fall in the range 0 to ."}], "target": {"@refid": "binarray"}, "math_block": {"@xml:space": "preserve", "#text": "\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\n\\hline\n\\textrm{Position} & 0  & 1 & 2 & 3 &  4 &  5 & 6 & 7 & 8 &  9 & 10 & 11\\\\\n\\hline\n\\hline\n\\textrm{Parent} & \\,--\\, & 0 & 0 & 1 &  1 &  2 &  2 & 3 & 3 & 4 & 4 & 5\\\\\n\\hline\n\\textrm{Left Child} & 1  & 3 & 5 & 7 &  9 & 11 & \\,--\\, & \\,--\\, & \\,--\\, &\n\\,--\\, & \\,--\\, &  \\,--\\,\\\\\n\\hline\n\\textrm{Right Child} & 2  & 4 & 6 & 8 & 10 & \\,--\\, & \\,--\\, & \\,--\\, &\n\\,--\\, & \\,--\\, & \\,--\\, &  \\,--\\,\\\\\n\\hline\n\\textrm{Left Sibling} & \\,--\\, & \\,--\\, & 1 & \\,--\\, &  3 & \\,--\\, & 5 &\n\\,--\\, & 7 & \\,--\\, &  9 &  \\,--\\,\\\\\n\\hline\n\\textrm{Right Sibling} & \\,--\\, & 2 & \\,--\\, & 4 & \\,--\\, &  6 & \\,--\\, & 8 &\n\\,--\\, & 10 & \\,--\\, & \\,--\\,\\\\\n\\hline\n\\end{array}"}, "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": {"math": ["r", "= \\lfloor(r - 1)/2\\rfloor", "r \\neq 0"], "#text": "Parent() \nif ."}}, {"paragraph": {"math": ["r", "= 2r + 1", "2r + 1 \\leq n"], "#text": "Left child()  if ."}}, {"paragraph": {"math": ["r", "= 2r + 2", "2r + 2 \\leq n"], "#text": "Right child()  if ."}}, {"paragraph": {"math": ["r", "= r - 1", "r"], "#text": "Left sibling()  if  is even."}}, {"paragraph": {"math": ["r", "= r + 1", "r", "r + 1 \\leq n"], "#text": "Right sibling()  if \nis odd and ."}}]}}}