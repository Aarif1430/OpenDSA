{"document": {"@ids": "queues", "@names": "queues", "@source": "<string>", "@title": "Queues", "title": "Queues", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/List/aqueueCON.css"}], "section": [{"@ids": "queue-terminology", "@names": "queue\\ terminology", "title": "Queue Terminology", "paragraph": {"title_reference": ["queue", "enqueue", "dequeue"], "#text": "Like the stack, the  is a list-like structure that\nprovides restricted access to its elements.\nQueue elements may only be inserted at the back (called an\n operation) and removed from the\nfront (called a  operation).\nQueues operate like standing in line at a movie theater ticket\ncounter.\nIf nobody cheats, then newcomers go to the back of the line.\nThe person at the front of the line is the next to be served.\nThus, queues release their elements in order of arrival.\nIn Britain, a line of people is called a \"queue\",\nand getting into line to wait for service is called \"queuing up\".\nAccountants have used queues since long before the\nexistence of computers.\nThey call a queue a \"FIFO\" list, which stands for\n\"First-In, First-Out\".\nHere is a sample queue ADT.\nThis section presents two implementations for queues:\nthe array-based queue and the linked queue."}, "raw": {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}}, {"@ids": "array-based-queues", "@names": "array-based\\ queues", "title": "Array-Based Queues", "paragraph": "The array-based queue is somewhat tricky to implement effectively.\nA simple conversion of the array-based list implementation is not\nefficient.", "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "aqueueFirstCON", "@long_name": "aqueueFirstCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "aqueueDriftCON", "@long_name": "aqueueDriftCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "aqueueBadCON", "@long_name": "aqueueBadCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}], "line_block": [{"line": null}, {"line": null}], "section": {"@ids": "the-circular-queue", "@names": "the\\ circular\\ queue", "title": "The Circular Queue", "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "aqueueCircularCON", "@long_name": "aqueueCircularCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "aqueueEmptyCON", "@long_name": "aqueueEmptyCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}], "line_block": {"line": null}, "paragraph": [{"literal": ["front", "rear", "rear", "front", "rear"], "title_reference": ["n+1", "n+1", "n", "Pigeonhole Principle", "n", "n+1", "n+1", "n"], "#text": "If the value of  is fixed, then  different\nvalues for  are needed to distinguish among the \nstates.\nHowever, there are only  possible values for  unless\nwe invent a special case for, say, empty queues.\nThis is an example of the .\nThe Pigeonhole Principle states that, given  pigeonholes\nand  pigeons, when all of the pigeons go into the holes we\ncan be sure that at least one hole contains more than one pigeon.\nIn similar manner, we can be sure that two of the  states\nare indistinguishable by the  relative values of \nand .\nWe must seek some other way to distinguish full from empty queues."}, {"title_reference": ["n+1", "n", "n+1"], "#text": "One obvious solution is to keep an explicit count of the number of\nelements in the queue, or at least a Boolean variable that indicates\nwhether the queue is empty or not.\nAnother solution is to make the array be of size ,\nand only allow  elements to be stored.\nWhich of these solutions to adopt is purely a matter of the\nimplementor's taste in such affairs.\nOur choice here is to use an array of size ."}, "Here is an array-based queue implementation."]}}, {"@ids": "array-based-queue-implementation", "@names": "array-based\\ queue\\ implementation", "title": "Array-based Queue Implementation", "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "aqueueVarCON", "@long_name": "aqueueVarCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "AqueueEnqueuePRO", "@long_name": "AqueueEnqueuePRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "paragraph": {"literal": ["enqueue", "maxSize", "dequeue"], "#text": "In this implementation, the front of the queue is defined to be toward\nthe lower numbered positions in the array (in the counter-clockwise\ndirection in the circular array), and the rear is\ndefined to be toward the higher-numbered positions.\nThus,  increments the rear pointer (modulus ),\nand  increments the front pointer.\nImplementation of all member functions is straightforward."}}, {"@ids": "array-based-dequeue-practice", "@names": "array-based\\ dequeue\\ practice", "title": "Array-based Dequeue Practice", "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "AqueueDequeuePRO", "@long_name": "AqueueDequeuePRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "DataStructures/CircularQueue.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/List/aqueueFirstCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/List/aqueueDriftCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/List/aqueueBadCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/List/aqueueCircularCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/List/aqueueEmptyCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/List/aqueueVarCON.js"}]}]}}