{"document": {"@dupnames": "kd\\ trees", "@ids": "kd-trees", "@source": "<string>", "@title": "KD Trees", "title": "KD Trees", "subtitle": {"@dupnames": "kd\\ trees", "@ids": "id1", "#text": "KD Trees"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@ids": "kdexamp", "@names": "kdexamp", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "kdsearch", "@names": "kdsearch", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "incirc", "@names": "incirc", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "kd-treeAV", "@long_name": "kd-treeAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "kd-interact", "@long_name": "kd-interact", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}], "paragraph": [{"title_reference": ["kd tree", "BST", "multi-dimensional search keys <multi-dimensional search key>", "discriminator", "Figure #kdExamp"], "math": ["i", "i", "k", "k", "xy", "k:math:", "x", "y", "x", "y", "N", "x", "N_x", "x", "0 \\mod 2 = 0", "x", "N_x", "M", "y", "M_y", "M_x", "x", "M", "M", "y"], "#text": "The  is a modification to the  that allows\nfor efficient processing of\n.\nThe kd tree differs from the BST in that each level of the kd tree\nmakes branching decisions based on a particular search key associated\nwith that level, called the .\nIn principle, the kd tree could be used to unify key searching across\nany arbitrary set of keys such as name and zipcode.\nBut in practice, it is nearly always used to support search on\nmulti-dimensional coordinates, such as locations in 2D or 3D space.\nWe define the discriminator at level  to be\n mod  for  dimensions.\nFor example, assume that we store data organized by\n-coordinates.\nIn this case,  is 2 (there are two coordinates),\nwith the -coordinate field arbitrarily designated key 0,\nand the -coordinate field designated key 1.\nAt each level, the discriminator alternates between  and\n.\nThus, a node  at level 0 (the root) would have in its left\nsubtree only nodes whose  values are less than\n (because  is search key 0, and\n).\nThe right subtree would contain nodes whose  values are\ngreater than .\nA node  at level 1 would have in its left subtree only\nnodes whose  values are less than .\nThere is no restriction on the relative values of  and the\n values of  's descendants, because branching\ndecisions made at  are based solely on the \ncoordinate.\nFigure  shows an example of how a collection\nof two-dimensional points would be stored in a kd tree."}, {"title_reference": "Figure #kdExamp", "math": ["128 \\times 128", "x", "y"], "#text": "In Figure , the region containing the points\nis (arbitrarily) restricted to a  square, and\neach internal node splits the search space.\nEach split is shown by a line, vertical for nodes with\n discriminators and horizontal for nodes with \ndiscriminators.\nThe root node splits the space into two parts;\nits children further subdivide the space into smaller parts.\nThe children's split lines do not cross the root's split line.\nThus, each node in the kd tree helps to decompose the space into\nrectangles that show the extent of where nodes can fall in the\nvarious subtrees."}, "Searching a kd tree for the record with a specified xy-coordinate\nis like searching a BST, except that each level of the\nkd tree is associated with a particular discriminator.", {"literal": "NULL", "#text": "Inserting a new node into the kd tree is similar to\nBST insertion.\nThe kd tree search procedure is followed until a  pointer is\nfound, indicating the proper place to insert the new node."}, {"math": ["N", "N", "N", "N", "N", "N", "N", "N"], "literal": "NULL", "#text": "Deleting a node from a kd tree is similar to deleting from a BST,\nbut slightly harder.\nAs with deleting from a BST, the first step is to find the node\n(call it ) to be deleted.\nIt is then necessary to find a descendant of  which can be\nused to replace  in the tree.\nIf  has no children, then  is replaced with a\n pointer.\nNote that if  has one child that in turn has children, we\ncannot simply assign 's parent to point to 's\nchild as would be done in the BST.\nTo do so would change the level of all nodes in the subtree, and thus\nthe discriminator used for a search would also change.\nThe result is that the subtree would no longer be a kd tree because a\nnode's children might now violate the BST property for that\ndiscriminator."}, {"math": ["N", "N", "N", "N", "y", "N", "y", "Y_{min}", "y", "Y_{min}", "N"], "literal": "findmin", "#text": "Similar to BST deletion, the record stored in  should\nbe replaced either by the record in 's right subtree with\nthe least value of <var>N</var>'s discriminator, or by the record in\n's left subtree with the greatest value for this\ndiscriminator.\nAssume that  was at an odd level and therefore  is\nthe discriminator.\n could then be replaced by the record in its right subtree\nwith the least  value (call it ).\nThe problem is that <var>Y</var><sub>min</sub> is not necessarily the\nleftmost node, as it would be in the BST.\nA modified search procedure to find the least  value in the\nleft subtree must be used to find it instead.\nThe implementation for  is shown next.\nA recursive call to the delete routine will then remove\n:math`Y_{min}` from the tree.\nFinally, 's record is substituted for the\nrecord in node ."}, {"literal": ["findmin", "min"], "#text": "In , on levels using the minimum value's discriminator,\nbranching is to the left.\nOn other levels, both children's subtrees must be visited.\nHelper function  takes two nodes and a discriminator as\ninput, and returns the node with the smaller value in that\ndiscriminator."}, {"math": ["N", "N", "N", "N", "N"], "strong": "least", "#text": "Note that we can replace the node to be deleted with the least-valued\nnode from the right subtree only if the right subtree exists.\nIf it does not, then a suitable replacement must be found in the left\nsubtree.\nUnfortunately, it is not satisfactory to replace 's record\nwith the record having the greatest value for the discriminator in the\nleft subtree, because this new value might be duplicated.\nIf so, then we would have equal values for the discriminator in\n's left subtree, which violates the ordering rules for the\nkd tree.\nFortunately, there is a simple solution to the problem.\nWe first move the left subtree of node  to become the\nright subtree (i.e., we simply swap the values of 's left\nand right child pointers).\nAt this point, we proceed with the normal deletion process, replacing\nthe record of <var>N</var> to be deleted with the record containing\nthe  value of the discriminator from what is now\n's right subtree."}, {"math": ["d", "P", "P", "d", "N", "\\sqrt{(P_x - N_x)^2 + (P_y - N_y)^2} \\leq d."], "footnote_reference": {"@auto": "1", "@ids": "id2", "@refid": "id3", "#text": "1"}, "#text": "Assume that we want to print out a list of all records that are within\na certain distance  of a given point .\nWe will use Euclidean distance, that is, point  is defined\nto be within distance  of point \nif"}, {"math": ["d", "d", "d"], "#text": "If the search process reaches a node whose key value for the\ndiscriminator is more than  above the corresponding value in\nthe search key, then it is not possible that any record in the right\nsubtree can be within distance  of the search key because all\nkey values in that dimension are always too great.\nSimilarly, if the current node's key value in the discriminator\nis  less than that for the search key value, then no record in\nthe left subtree can be within the radius.\nIn~such cases, the subtree in question need not be searched,\npotentially saving much time.\nIn the average case, the number of nodes that must be visited during a\nrange query is linear on the number of data records that fall within\nthe query circle."}, "Here is an implementation for the region search method.", {"literal": "InCircle", "math": ["x", "y"], "title_reference": "Figure #InCirc", "#text": "When a node is visited, function  is used to\ncheck the Euclidean distance between the node's record and the query\npoint.\nIt is not enough to simply check that the differences between the\n- and -coordinates are each less than the query\ndistances because the the record could still be outside the search\ncircle, as illustrated by Figure ."}, "Here is a visualization of building a kd-tree.\n</p>", "Here is a version where you can click to get the node inserted."], "target": [{"@refid": "kdexamp"}, {"@refid": "kdsearch"}, {"@refid": "incirc"}], "topic": [{"title": "Example", "paragraph": [{"math": ["P = (69, 50)", "P", "A", "P", "A", "x", "A", "P", "A_x", "P", "x", "x", "A_y", "P", "C", "y", "P", "C", "1 \\mod 2 = 1", "y", "C_y", "P_y", "P", "D"], "title_reference": "Figure #kdExamp", "#text": "Consider searching the kd tree for a\nrecord located at .\nFirst compare  with the point stored at\nthe root (record  in Figure ).\nIf  matches the location of :math:A`,\nthen the search is successful.\nIn this example the positions do not match\n( 's location (40, 45) is not the same as (69, 50)),\nso the search must continue.\nThe  value of  is compared with that of\n to determine in which direction to branch.\nBecause 's value of 40 is less than\n's  value of 69, we branch to the right subtree\n(all cities with  value greater than or equal to 40 are in\nthe right subtree).\n does not affect the decision on which way to\nbranch at this level.\nAt the second level,  does not match record 's\nposition, so another branch must be taken.\nHowever, at this level we branch based on the relative \nvalues of point  and record \n(because , which corresponds to the\n-coordinate).\nBecause 's value of 10 is less than 's value\nof 50, we branch to the right.\nAt this point,  is compared against the position\nof .\nA match is made and the search is successful."}, {"literal": ["NULL", "findhelp", "KD", "D"], "#text": "If the search process reaches a  pointer, then\nthat point is not contained in the tree.\nHere is a kd tree search implementation,\nequivalent to the  function of the BST class.\n class private member  stores the key's dimension."}]}, {"title": "Example", "paragraph": {"title_reference": "Figure #kdExamp", "math": ["B", "B"], "#text": "Inserting a record at location (10, 50) in the\nkd tree of Figure  first requires a search\nto the node containing record .\nAt this point, the new record is inserted into 's left\nsubtree."}}, {"title": "Example", "paragraph": {"title_reference": "Figure #kdSearch", "math": ["A", "A", "B", "B", "A<", "C", "C", "C", "C", "y", "65-25 > 10", "C", "C", "C", "C", "D", "D", "25+25 < 69", "D<", "D", "E", "E"], "#text": "We will now find all cities in the kd tree of\nFigure  within 25 units of the point\n(25, 65).\nThe search begins with the root node, which contains record\n.\nBecause (40, 45) is exactly 25 units from the search point, it will\nbe reported.\nThe search procedure then determines which branches of the tree to\ntake.\nThe search circle extends to both the left and the right of\n's (vertical) dividing line, so both branches of the tree\nmust be searched.\nThe left subtree is processed first.\nHere, record  is checked and found to fall within the\nsearch circle.\nBecause the node storing  has no children, processing of\nthe left subtree is complete.\nProcessing of 's right subtree now begins.\nThe coordinates of record  are checked and found not to\nfall within the circle.\nThus, it should not be reported.\nHowever, it is possible that cities within 's subtrees\ncould fall within the search circle even if  does not.\nAs  is at level 1, the discriminator at this level is the\n-coordinate.\nBecause , no record in 's left subtree\n(i.e., records above ) could possibly be in the search\ncircle.\nThus, 's left subtree (if it had one) need not be\nsearched.\nHowever, cities in 's right subtree could fall within the\ncircle.\nThus, search proceeds to the node containing record .\nAgain,  is outside the search circle.\nBecause , no record in 's right subtree\ncould be within the search circle.\nThus, only 's left subtree need be searched.\nThis leads to comparing record 's coordinates against the\nsearch circle.\nRecord  falls outside the search circle, and processing is\ncomplete.\nSo we see that we only search subtrees whose rectangles fall within\nthe search circle."}}], "literal_block": [{"@xml:space": "preserve", "#text": "private E findhelp(KDNode<E> rt, int[] key, int level) {\n  if (rt == null) return null;\n  E it = rt.element();\n  int[] itkey = rt.key();\n  if ((itkey[0] == key[0]) && (itkey[1] == key[1]))\n    return rt.element();\n  if (itkey[level] > key[level])\n    return findhelp(rt.left(), key, (level+1)%D);\n  else\n    return findhelp(rt.right(), key, (level+1)%D);\n}"}, {"@xml:space": "preserve", "#text": "private KDNode<E>\nfindmin(KDNode<E> rt, int descrim, int level) {\n  KDNode<E> temp1, temp2;\n  int[] key1 = null;\n  int[] key2 = null;\n  if (rt == null) return null;\n  temp1 = findmin(rt.left(), descrim, (level+1)%D);\n  if (temp1 != null) key1 = temp1.key();\n  if (descrim != level) {\n    temp2 = findmin(rt.right(), descrim, (level+1)%D);\n    if (temp2 != null) key2 = temp2.key();\n    if ((temp1 == null) || ((temp2 != null) &&\n                   (key1[descrim] > key2[descrim])))\n    temp1 = temp2;\n    key1 = key2;\n  } // Now, temp1 has the smaller value\n  int[] rtkey = rt.key();\n  if ((temp1 == null) || (key1[descrim] > rtkey[descrim]))\n    return rt;\n  else\n    return temp1;\n}"}, {"@xml:space": "preserve", "#text": "private void rshelp(KDNode<E> rt, int[] point,\n                    int radius, int lev) {\n  if (rt == null) return;\n  int[] rtkey = rt.key();\n  if (InCircle(point, radius, rtkey))\n    System.out.println(rt.element());\n  if (rtkey[lev] > (point[lev] - radius))\n    rshelp(rt.left(), point, radius, (lev+1)%D);\n  if (rtkey[lev] < (point[lev] + radius))\n    rshelp(rt.right(), point, radius, (lev+1)%D);\n}"}], "footnote": {"@auto": "1", "@backrefs": "id2", "@ids": "id3", "@names": "1", "label": "1", "paragraph": {"math": "(P_x - N_x)^2 + (P_y - N_y)^{2} \\leq d^{2}", "#text": "A more efficient computation is\n.\nThis avoids performing a square root function."}}}}