{"document": {"@dupnames": "hash\\ function\\ principles", "@ids": "hash-function-principles", "@source": "<string>", "@title": "Hash Function Principles", "title": "Hash Function Principles", "subtitle": {"@dupnames": "hash\\ function\\ principles", "@ids": "id1", "#text": "Hash Function Principles"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "Birthday", "@long_name": "Birthday", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}], "paragraph": [{"emphasis": ["which", "which"], "#text": "Hashing generally takes records whose key values come from a\nlarge range and stores those records in a table\nwith a relatively small number of slots.\nCollisions occur when two records hash to the same slot in the\ntable.\nIf we are careful  or lucky  when selecting a hash function,\nthen the actual number of collisions will be few.\nUnfortunately, even under the best of circumstances, collisions are\nnearly unavoidable.\nTo illustrate, consider a classroom full of students.\nWhat is the probability that some pair of students\nshares the same birthday (i.e., the same day of the year, not\nnecessarily the same year)?\nIf there are 23 students, then the odds are about even that two will\nshare a birthday.\nThis is despite the fact that there are 365 days in which students\ncan have birthdays (ignoring leap years).\nOn most days, no student in the class has a birthday.\nWith more students, the probability of a shared birthday increases.\nThe mapping of students to days based on their birthday is similar to\nassigning records to slots in a table (of size 365) using the\nbirthday as a hash function.\nNote that this observation tells us nothing about \nstudents share a birthday, or on  days of the year shared\nbirthdays fall."}, "Try it for yourself.\nSelect several table sizes and several different numbers of records to\nbe inserted in the calculator below.\nIt will calculate the probability that there is a collision.\nTo get credit for the exercise, answer the following two questions:", {"title_reference": "around half full <HashAnal>", "#text": "To be practical, a database organized by hashing must store records in a\nhash table that is not so large that it wastes space.\nTo balance time and space efficiency, this means that the hash table\nshould be .\nBecause collisions are extremely likely to occur under these conditions\n(by chance, any record inserted into a table that is half full should\nhave a collision half of the time),\ndoes this mean that we need not worry about how well a hash function\ndoes at avoiding collisions?\nAbsolutely not.\nThe difference between using a good hash function and a bad hash function\nmakes a big difference in practice in the number of records that must be\nexamined when searching or inserting to the table.\nTechnically, any function that maps all possible key values to a\nslot in the hash table is a hash function.\nIn the extreme case, even a function that maps all records to the same\nslot in the array is a hash function, but it does nothing to help us\nfind records during a search operation."}, "We would like to pick a hash function that maps keys\nto slots in a way that makes each slot in the hash table have equal\nprobablility of being filled for the actual set keys being used.\nUnfortunately, we normally have no control over the distribution of\nkey values for the actual records in a given database or collection.\nSo how well any particular hash function does\ndepends on the actual distribution of the keys used within the\nallowable key range.\nIn some cases, incoming data are well distributed across their key\nrange.\nFor example, if the input is a set of random numbers selected\nuniformly from the key range,\nany hash function that assigns the key range so that each slot in the\nhash table receives an equal share of the range will likely also\ndistribute the input records uniformly within the table.\nHowever, in many applications the incoming records are highly\nclustered or otherwise poorly distributed.\nWhen input records are not well distributed throughout the key range\nit can be difficult to devise a hash function that does a good job of\ndistributing the records throughout the table, especially if the\ninput distribution is not known in advance.", "There are many reasons why data values might be poorly distributed.", "Note that for items 2 and 3 on this list,\neither high- or low-order bits of the key are poorly distributed.", "When designing hash functions, we are generally faced with one of two\nsituations:", "In the next module, you will see several examples of hash functions\nthat illustrate these points."], "bullet_list": {"@bullet": "-", "list_item": [{"paragraph": "What is the smallest number of people that must be in the room for\nthe probability to be at least 60% that two share a birthday?"}, {"paragraph": "In a hash table of 1000 slots, what is the smallest number of records\nthat must be inserted before the probability of a collision reaches 50%?"}]}, "enumerated_list": [{"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Natural frequency distributions tend to follow a common pattern where\na few of the entities occur frequently while most entities occur\nrelatively rarely.\nFor example, consider the populations of the 100 largest cities in\nthe United States.\nIf you plot these populations on a numberline, most of them\nwill be clustered toward the low side, with a few\noutliers on the high side.\nThis is an example of a Zipf distribution.\nViewed the other way, the home town for a given person is far more\nlikely to be a particular large city than a particular small town."}, {"paragraph": "Collected data are likely to be skewed in some way.\nField samples might be rounded to, say, the\nnearest 5 (i.e., all numbers end in 5 or 0)."}, {"paragraph": "If the input is a collection of common English words, the beginning\nletter will be poorly distributed."}]}, {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "We know nothing about the distribution of the incoming keys.\nIn this case, we wish to select a hash function that evenly\ndistributes the key range across the hash table,\nwhile avoiding obvious opportunities for clustering such as hash\nfunctions that are sensitive to the high- or low-order bits of the key\nvalue."}, {"paragraph": {"emphasis": "not", "#text": "We know something about the distribution of the incoming keys.\nIn this case, we should use a distribution-dependent hash function\nthat avoids assigning clusters of related key values to the same hash\ntable slot.\nFor example, if hashing English words, we should  hash on\nthe value of the first character because this is likely to be unevenly\ndistributed."}}]}]}}