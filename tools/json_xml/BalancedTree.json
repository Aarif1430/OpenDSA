{"document": {"@ids": "balanced-trees", "@names": "balanced\\ trees", "@source": "<string>", "@title": "Balanced Trees", "title": "Balanced Trees", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Development/treeIndexingCON.css"}, {"@format": "xml", "@ids": "balancebst", "@names": "balancebst", "@xml:space": "preserve", "odsafig": "null"}], "paragraph": [{"title_reference": "Binary Search Tree <BST> <BST>", "math": ["n", "n", "\\Theta(\\log n)"], "#text": "The  has a serious deficiency for\npractical use as a search structure.\nThat is the fact that it can easily become unbalanced, so that some\nnodes are deep in the tree.\nIn fact, it is possible for a BST with  nodes to have a depth\nof , making it no faster to search in the worst case than a\nlinked list.\nIf we could keep the tree balanced in some way, then search cost would\nonly be , a huge improvement."}, {"title_reference": ["2-3 Tree <2-3 Tree> <TwoThreeTree>", "B-Tree <B-tree> <BTree>"], "#text": "One solution to this problem is to adopt another search\ntree structure instead of using a BST at all.\nAn example of such an alternative tree structure is the\n\nor the .\nBut another alternative would be to modify the BST access functions in\nsome way to guarantee that the tree performs well.\nThis is an appealing concept, and the concept works well for heaps,\nwhose access functions maintain the heap in the shape of a complete\nbinary tree.\nUnfortunately, the heap keeps its balanced shape at the cost of weaker\nrestrictions on the relative values of a node and its children, making\nit a bad search structure.\nAnd requiring that the BST always be in the shape of a\ncomplete binary tree requires excessive modification to the tree\nduring update, as we see in this example."}, {"title_reference": "AVL tree <AVL Tree> <AVL>", "#text": "If we are willing to weaken the balance requirements, we can come up\nwith alternative update routines that perform well both in terms of\ncost for the update and in balance for the resulting tree structure.\nThe \nworks in this way, using insertion and deletion routines\naltered from those of the BST to ensure that, for every node, the\ndepths of the left and right subtrees differ by at most one."}, {"title_reference": ["UNION/FIND algorithm <UNION/FIND> <UnionFind>", "splay tree <Splay Tree> <Splay>"], "#text": "A different approach to improving the performance of the BST is to\nnot require that the tree always be balanced, but rather to expend\nsome effort toward making the BST more balanced every time it\nis accessed.\nThis is a little like the idea of path compression used by the\n.\nOne example of such a compromise is called the\n."}, {"title_reference": "Red-Black Tree <Red-Black Tree> <RedBlack>", "#text": "The  is also a binary\ntree, but it uses a different balancing mechanism."}], "target": {"@refid": "balancebst"}}}