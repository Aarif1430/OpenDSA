<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="semantics\ of\ the\ lambda\ calculus" ids="id1 semantics-of-the-lambda-calculus" names="semantics-of-the-lambda-calculus" source="&lt;string&gt;" title="Semantics of the Lambda Calculus"><title>Semantics of the Lambda Calculus</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-13 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><target refid="semantics-of-the-lambda-calculus"></target><section dupnames="semantics\ of\ the\ lambda\ calculus" ids="id2"><title>Semantics of the Lambda Calculus</title><paragraph>In the previous section, we covered the entirety of the syntax of the
lambda calculus. The rest of this chapter, including this section,
deals with the semantics of the lambda calculus, that is, the meaning
of lambda expressions, or in other words, how they are interpreted and what
their value is. Clearly, the expressive power of the lambda calculus
is outstanding: its tiny syntax will allow us to express a rich set of
computations, in fact, all possible computations (for more on this,
look up the Church-Turing thesis).</paragraph><paragraph>Note that all programs in the lambda calculus are expressions, that
is, programs that get evaluated for their value. The lambda calculus
does not contain any statements, that is, commands that get executed
for their side effects, for example, modifying the contents of memory
via assignment statements or sending a string to the standard output
stream via print statements. Therefore, the lambda calculus is a
purely functional language.</paragraph><paragraph>Now, we will explain the meaning of the three types of lambda
expressions whose syntax is given in the lambda calculus grammar.
For each type of lambda expressions, we will
describe its meaning using both an English statement and a JavaScript
code fragment.</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>A <emphasis>variable</emphasis> in the lambda calculus (the first production in the
Lambda Calculus grammar) is a placeholder for another lambda
expression. In other words, like in all programming languages, a
variable can be used to refer to some value that may or may not be
known yet. So variables <title_reference>x</title_reference> and <title_reference>p_1</title_reference> in the lambda
calculus can be represented by the variables <title_reference>x</title_reference> and
<title_reference>p1</title_reference>, respectively, in JavaScript.</paragraph><table><title>1 2 10 7</title><tgroup cols="4"><colspec colwidth="25"></colspec><colspec colwidth="25"></colspec><colspec colwidth="25"></colspec><colspec colwidth="25"></colspec><thead><row><entry><paragraph>Example</paragraph></entry><entry><paragraph><title_reference>lambda</title_reference> Expression</paragraph></entry><entry><paragraph>English Statement of the Semantics</paragraph></entry><entry><paragraph>JavaScript Implementation</paragraph></entry></row></thead><tbody><row><entry><paragraph>1</paragraph></entry><entry><paragraph><title_reference>x</title_reference></paragraph></entry><entry><paragraph>the variable named <title_reference>x</title_reference></paragraph></entry><entry><literal_block classes="code javascript" xml:space="preserve"><inline classes="name other">x</inline></literal_block></entry></row></tbody></tgroup></table><paragraph>The main difference between lambda calculus and JavaScript is
that, in the lambda calculus, each variable can only get bound to
one value during the execution of the whole program, whereas, in
JavaScript, the value of a variable can be changed multiple times
during execution using assignment statements. In conclusion,
variables in the lambda calculus are more like named constants
than variables in imperative programming languages. Furthermore,
in the lambda calculus, since the only values are functions, all
variables are placeholders for function values.</paragraph></list_item><list_item><paragraph>A <title_reference>lambda abstraction</title_reference> in the lambda calculus (the second
production in the grammar) is a function definition, that is, an
expression that defines a function, <emphasis>not</emphasis> a function call. Since
all functions of the lambda calculus are anonymous and only take
one parameter, all we need to define a function is the name of its
parameter (that is, the variable following the <title_reference>lambda</title_reference> in
the second production in the grammar) and its body (a lambda
expression).</paragraph><table><title>1 2 10 7</title><tgroup cols="4"><colspec colwidth="25"></colspec><colspec colwidth="25"></colspec><colspec colwidth="25"></colspec><colspec colwidth="25"></colspec><thead><row><entry><paragraph>Example</paragraph></entry><entry><paragraph><title_reference>lambda</title_reference> Expression</paragraph></entry><entry><paragraph>English Statement of the Semantics</paragraph></entry><entry><paragraph>JavaScript Implementation</paragraph></entry></row></thead><tbody><row><entry><paragraph>2</paragraph></entry><entry><paragraph><title_reference>lambda x.x</title_reference></paragraph></entry><entry><paragraph>the function of <title_reference>x</title_reference> that returns <title_reference>x</title_reference> (i.e., the identity function)</paragraph></entry><entry><literal_block classes="code" xml:space="preserve">function (x) { return x; }</literal_block></entry></row><row><entry><paragraph>3</paragraph></entry><entry><paragraph><title_reference>lambda y.y</title_reference></paragraph></entry><entry><paragraph>the function of <title_reference>y</title_reference> that returns <title_reference>y</title_reference> (i.e., the identity function)</paragraph></entry><entry><literal_block classes="code" xml:space="preserve">function (y) { return y; }</literal_block></entry></row><row><entry><paragraph>4</paragraph></entry><entry><paragraph><title_reference>lambda x.y</title_reference></paragraph></entry><entry><paragraph>the constant function (of <title_reference>x</title_reference>) that returns <title_reference>y</title_reference></paragraph></entry><entry><literal_block classes="code" xml:space="preserve">function (x) { return y; }</literal_block></entry></row><row><entry><paragraph>5</paragraph></entry><entry><paragraph><title_reference>lambda z.y</title_reference></paragraph></entry><entry><paragraph>the same function as above</paragraph></entry><entry><literal_block classes="code" xml:space="preserve">function (z) { return y; }</literal_block></entry></row><row><entry><paragraph>6</paragraph></entry><entry><paragraph><title_reference>lambda y.x</title_reference></paragraph></entry><entry><paragraph>the constant function (of <title_reference>y</title_reference>) that returns <title_reference>x</title_reference></paragraph></entry><entry><literal_block classes="code javascript" xml:space="preserve"><inline classes="keyword declaration">function</inline> <inline classes="punctuation">(</inline><inline classes="name other">y</inline><inline classes="punctuation">)</inline> <inline classes="punctuation">{</inline> <inline classes="keyword">return</inline> <inline classes="name other">x</inline><inline classes="punctuation">;</inline> <inline classes="punctuation">}</inline></literal_block></entry></row><row><entry><paragraph>7</paragraph></entry><entry><paragraph><title_reference>lambda x.lambda y.y</title_reference></paragraph></entry><entry><paragraph>the function of <title_reference>x</title_reference> that returns the function of <title_reference>y</title_reference> that
returns <title_reference>y</title_reference> (in other words, the function of <title_reference>x</title_reference> that
returns the identity function)</paragraph></entry><entry><literal_block classes="code" xml:space="preserve">function (x) {
       return function (y) { return y; };
}</literal_block></entry></row></tbody></tgroup></table><paragraph>Note that example 7 above is the <emphasis>curried</emphasis> function of two
arguments, namely <title_reference>x</title_reference> and <title_reference>y</title_reference>, that returns its second
argument.</paragraph></list_item><list_item><paragraph>A <emphasis>function application</emphasis> in the lambda calculus (the third
production in the grammar) is a function call, that is, an
expression that invokes a function on a single argument. The first
component in a function application is either a variable (see
example 8 below) or a more complex lambda expression that will
eventually evaluate to a function. In examples 9 and 10 below, the
first component of the function application is a lambda
abstraction, that is, a function that is being defined and called
right away. In JavaScript, this type of function application is a
common idiom sometimes referred to as an <title_reference>IIFE (Immediately
inviked Function Expression)</title_reference>.</paragraph><table><title>1 2 10 7</title><tgroup cols="4"><colspec colwidth="25"></colspec><colspec colwidth="25"></colspec><colspec colwidth="25"></colspec><colspec colwidth="25"></colspec><thead><row><entry><paragraph>Example</paragraph></entry><entry><paragraph><title_reference>lambda</title_reference> Expression</paragraph></entry><entry><paragraph>English Statement of the Semantics</paragraph></entry><entry><paragraph>JavaScript Implementation</paragraph></entry></row></thead><tbody><row><entry><paragraph>8</paragraph></entry><entry><paragraph><title_reference>(xy)</title_reference></paragraph></entry><entry><paragraph>the invocation of function <title_reference>x</title_reference> on argument  <title_reference>y</title_reference></paragraph></entry><entry><literal_block classes="code" xml:space="preserve">x(y)</literal_block></entry></row><row><entry><paragraph>9</paragraph></entry><entry><paragraph><title_reference>(lambda x.xy)</title_reference></paragraph></entry><entry><paragraph>the identity function applied to <title_reference>y</title_reference></paragraph></entry><entry><literal_block classes="code" xml:space="preserve">(function (x) { return x; })(y)</literal_block></entry></row><row><entry><paragraph>10</paragraph></entry><entry><paragraph><title_reference>(lambda z.xy)</title_reference></paragraph></entry><entry><paragraph>the constant function <title_reference>x</title_reference> applied to <title_reference>y</title_reference></paragraph></entry><entry><literal_block classes="code" xml:space="preserve">(function (z) { return x; })(y)</literal_block></entry></row><row><entry><paragraph>11</paragraph></entry><entry><paragraph><title_reference>lambda x.(xy)</title_reference></paragraph></entry><entry><paragraph>the function of <title_reference>x</title_reference> that returns the value returned when <title_reference>x</title_reference>
is called on <title_reference>y</title_reference></paragraph></entry><entry><literal_block classes="code" xml:space="preserve">function (x) { return x(y); }</literal_block></entry></row><row><entry><paragraph>12</paragraph></entry><entry><paragraph><title_reference>(lambda x.lambda y.yz)</title_reference></paragraph></entry><entry><paragraph>the function from example 7 above applied to
<title_reference>z</title_reference>. Since the curried function of two parameters is
being called with a single argument, the evaluation of this
application will return the identity function.</paragraph></entry><entry><literal_block classes="code" xml:space="preserve">(function (x) {
    return function (y) { return y; };
 })(z)</literal_block></entry></row><row><entry><paragraph>13</paragraph></entry><entry><paragraph><title_reference>( (lambda x.lambda y.yu)v)</title_reference></paragraph></entry><entry><paragraph>the function from example 7 above applied to <title_reference>u</title_reference> and
<title_reference>v</title_reference>. Since the curried function of two parameters is
being called with two arguments, the evaluation of this
application will return the value of the second argument,
namely <title_reference>v</title_reference>.</paragraph></entry><entry><literal_block classes="code" xml:space="preserve">(function (x) {
    return function (y) { return y; };
 })(u)(v)</literal_block></entry></row></tbody></tgroup></table></list_item></enumerated_list><block_quote><paragraph>Note that, in example 11 above, the top-level expression is a
lambda abstraction whose body is a function application.</paragraph></block_quote></section><section ids="rp-14-part-3" names="rp\ 14\ part\ 3"><title>RP 14 part 3</title><paragraph>This problem is about the semantic equivalence between lambda
expressions and JavaScript expressions.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP14part3"
    long_name="RP14part3"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section></document>