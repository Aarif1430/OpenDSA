{"document": {"@dupnames": "the\\ fast\\ fourier\\ transform", "@ids": "the-fast-fourier-transform", "@source": "<string>", "@title": "The Fast Fourier Transform", "title": "The Fast Fourier Transform", "subtitle": {"@dupnames": "the\\ fast\\ fourier\\ transform", "@ids": "id1", "#text": "The Fast Fourier Transform"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@ids": "unity", "@names": "unity", "@xml:space": "preserve", "odsafig": "null"}], "paragraph": [{"reference": {"@name": "FFT Storyboard", "@refuri": "../../../Storyboard/FFT.pptx", "#text": "FFT Storyboard"}, "target": {"@ids": "fft-storyboard", "@names": "fft\\ storyboard", "@refuri": "../../../Storyboard/FFT.pptx"}, "#text": "See the  for some more\nvisualizations of this material."}, {"math": ["n", "O(n^2)", "n", "O(n)"], "#text": "Multiplication is considerably more difficult than addition.\nThe cost to multiply two -bit numbers directly is\n, while addition of two -bit numbers is\n."}, {"math": "\\log nm = \\log n + \\log m", "#text": "Recall that one property of logarithms is that\n.\nThus, if taking logarithms and anti-logarithms were cheap, then we\ncould reduce multiplication to addition by taking the log of the two\noperands, adding, and then taking the anti-log of the sum."}, "Under normal circumstances, taking logarithms and anti-logarithms is\nexpensive, and so this reduction would not be considered practical.\nHowever, this reduction is precisely the basis for the\nslide rule.\nThe slide rule uses a logarithmic scale to measure the lengths of two\nnumbers, in effect doing the conversion to logarithms automatically.\nThese two lengths are then added together, and the inverse logarithm\nof the sum is read off another logarithmic scale.\nThe part normally considered expensive (taking logarithms and\nanti-logarithms) is cheap because it is a physical part of the\nslide rule.\nThus, the entire multiplication process can be done cheaply via a\nreduction to addition.\nIn the days before electronic calculators, slide rules were routinely\nused by scientists and engineers to do basic calculations of this\nnature.", {"math": ["\\mathbf a", "n", "n-1"], "#text": "Now consider the problem of  multiplying polynomials.\nA vector  of  values can uniquely represent\na polynomial of degree , expressed as"}, {"math": ["n", "n"], "title_reference": ["evaluation", "interpolation"], "#text": "Alternatively, a polynomial can be uniquely represented by a\nlist of its values at  distinct points.\nFinding the value for a polynomial at a given point is called\n.\nFinding the coefficients for the polynomial given the values at\n points is called ."}, {"math": ["n-1", "A", "B", "\\Theta(n^2)", "AB"], "#text": "To multiply two -degree polynomials  and \nnormally takes  coefficient multiplications.\nHowever, if we evaluate both polynomials (at the same points), we can\nsimply multiply the corresponding pairs of values to get the\ncorresponding values for polynomial ."}, {"math": ["AB", "c", "-c", "AB"], "#text": "Note that evaluating any polynomial at 0 is easy.\nIf we evaluate at 1 and -1, we can share a lot of the work\nbetween the two evaluations.\nBut we would need five points to nail down polynomial ,\nsince it is a degree-4 polynomial.\nFortunately, we can speed processing for any pair of values \nand .\nThis seems to indicate some promising ways to speed up the process of\nevaluating polynomials.\nBut, evaluating two points in roughly the same time as evaluating one\npoint only speeds the process by a constant factor.\nIs there some way to generalized these observations to speed things up\nfurther?\nAnd even if we do find a way to evaluate many points quickly, we will\nalso need to interpolate the five values to get the coefficients of\n back."}, {"math": ["\\Theta(n^2)", "2n - 1", "c", "-c", "P_a(x) = E_a(x) + O_a(x)", "E_a", "O_a"], "emphasis": "if", "#text": "So we see that we could multiply two polynomials in less than\n operations  a fast way could be\nfound to do evaluation/interpolation of  points.\nBefore considering further how this might be done, first observe again\nthe relationship between evaluating a polynomial at values \nand .\nIn general, we can write  where\n is the even powers and  is the odd powers.\nSo,"}, {"math": ["c", "c"], "#text": "The significance is that when evaluating the pair of values\n and , we get"}, {"math": ["E", "O"], "#text": "Thus, we only need to compute the  s and  s once instead\nof twice to get both evaluations."}, {"math": ["x", "-x"], "#text": "The key to fast polynomial multiplication is finding the right points\nto use for evaluation/interpolation to make the process efficient.\nIn particular, we want to take advantage of symmetries, such as the\none we see for evaluating  and .\nBut we need to find even more symmetries between points if we want to\ndo more than cut the work in half.\nWe have to find symmetries not just between pairs of values,\nbut also further symmetries between pairs of pairs, and then pairs of\npairs of pairs, and so on."}, {"title_reference": ["complex", "primitive nth root of unity"], "math": ["z", "z", "y"], "#text": "Recall that a  number \nhas a real component and an imaginary component.\nWe can consider the position of  on a number line if we use\nthe  dimension for the imaginary component.\nNow, we will define a  if"}, {"math": ["z^0, z^1, ..., z^{n-1}", "n=4", "z = i", "z = -i", "e^{i\\pi} = -1", "z^j = e^{2\\pi ij/n} = -1^{2j/n}"], "title_reference": ["nth roots of unity", "Figure #Unity"], "#text": "are called the\n.\nFor example, when , then  or .\nIn general, we have the identities ,\nand .\nThe significance is that we can find as many points on a unit circle\nas we would need\n(see Figure ).\nBut these points are special in that they will allow us to do just the\nright computation necessary to get the needed symmetries to speed up\nthe overall process of evaluating many points at once."}, {"math": ["n \\times n", "A_{z}", "i", "j"], "#text": "The next step is to define how the computation is done.\nDefine an  matrix  with row \nand column  as"}, {"math": ["i", "z^i", "n = 4", "z = i", "A_{z}"], "#text": "The idea is that there is a row for each root (row  for\n) while the columns correspond to the power of the exponent\nof the :math`x` value in the polynomial.\nFor example, when  we have .\nThus, the  array appears as follows."}, {"math": ["a = [a_0, a_1, ..., a_{n-1}]^T", "n", "A_{z}", "F_{z}"], "title_reference": ["Discrete Fourier Transform", "DFT"], "#text": "Let  be a vector that stores the\ncoefficients for the polynomial being evaluated.\nWe can then do the calculations to evaluate the polynomial at the\n th roots of unity by multiplying the  matrix by\nthe coefficient vector.\nThe resulting vector  is called the\n () for the polynomial."}, {"math": ["n = 8", "z = \\sqrt{i}", "\\sqrt{i}^8 = 1"], "#text": "When , then ,\nsince .\nSo, the corresponding matrix is as follows."}, {"math": "n^2", "#text": "We still have two problems.\nWe need to be able to multiply this matrix and the vector faster\nthan just by performing a standard matrix-vector multiplication,\notherwise the cost is still  multiplies to do the\nevaluation.\nEven if we can multiply the matrix and vector cheaply, we still\nneed to be able to reverse the process.\nThat is, after transforming the two input polynomials by evaluating\nthem, and then pair-wise multiplying the evaluated points, we must\ninterpolate those points to get the resulting polynomial back that\ncorresponds to multiplying the original input polynomials."}, "The interpolation step is nearly identical to the evaluation step.", {"math": "A_{z}^{-1}", "#text": "We need to find .\nThis turns out to be simple to compute, and is defined as follows."}, {"math": ["1/z", "z", "1/n"], "#text": "In other words, interpolation (the inverse transformation) requires\nthe same computation as evaluation, except that we substitute\n for  (and multiply by  at the end).\nSo, if we can do one fast, we can do the other fast."}, {"math": ["A_z", "n=8", "\\Theta(n \\log n)", "n"], "#text": "If you examine the example  matrix for ,\nyou should see that there are symmetries within the matrix.\nFor example, the top half is identical to the bottom half with\nsuitable sign changes on some rows and columns.\nLikewise for the left and right halves.\nAn efficient divide and conquer algorithm exists to perform both the\nevaluation and the interpolation in  time.\nThis is called DFT.\nIt is a recursive function that decomposes the matrix\nmultiplications, taking advantage of the symmetries made available by\ndoing evaluation at the  th roots of unity.\nThe algorithm is as follows:"}, {"math": ["A", "B"], "#text": "Thus, the full process for multiplying polynomials\n and  using the Fourier transform is as follows."}], "math_block": [{"@xml:space": "preserve", "#text": "P_{\\mathbf a}(x) = \\sum_{i=0}^{n-1} {\\mathbf a}_i x^i."}, {"@xml:space": "preserve", "#text": "P_a(x) = \\sum_{i=0}^{n/2-1} a_{2i} x^{2i} +\n        \\sum_{i=0}^{n/2-1} a_{2i+1} x^{2i+1}"}, {"@xml:space": "preserve", "#text": "\\begin{eqnarray*}\nE_a(c) + O_a(c) &=& E_a(c) - O_a(-c)\\\\\nO_a(c) &=& - O_a(-c)\n\\end{eqnarray*}"}, {"@xml:space": "preserve", "#text": "A_{z} = (z^{ij})."}, {"@xml:space": "preserve", "#text": "A_{z} =\n\\begin{array}{rrrr}\n1&1&1&1\\\\\n1&i&-1&-i\\\\\n1&-1&1&-1\\\\\n1&-i&-1&i\n\\end{array}"}, {"@xml:space": "preserve", "#text": "F_{z} = A_{z}a = b.\\]\n\\[b_i = \\sum_{k=0}^{n-1} a_kz^{ik}."}, {"@xml:space": "preserve", "#text": "A_{z} =\n\\begin{array}{rrrrrrrr}\n1&         1& 1&         1& 1&         1& 1&         1\\\\\n1&  \\sqrt{i}& i& i\\sqrt{i}&-1& -\\sqrt{i}&-i&-i\\sqrt{i}\\\\\n1&         i&-1&        -i& 1&         i&-1&        -i\\\\\n1& i\\sqrt{i}&-i&  \\sqrt{i}&-1&-i\\sqrt{i}& i& -\\sqrt{i}\\\\\n1&        -1& 1&        -1& 1&        -1& 1&        -1\\\\\n1& -\\sqrt{i}& i&-i\\sqrt{i}&-1&  \\sqrt{i}&-i& i\\sqrt{i}\\\\\n1&        -i&-1&         i& 1&        -i&-1&         i\\\\\n1&-i\\sqrt{i}&-i& -\\sqrt{i}&-1& i\\sqrt{i}& i&  \\sqrt{i}\n\\end{array}"}, {"@xml:space": "preserve", "#text": "F_{z}^{-1} = A_{z}^{-1}b' = a'."}, {"@xml:space": "preserve", "#text": "A_{z}^{-1} = \\frac{1}{n}A_{1/z}."}], "topic": {"title": "Example", "paragraph": [{"math": "x^2 + 1", "#text": "Polynomial A: ."}, {"math": "2x^2 - x + 1", "#text": "Polynomial B: ."}, {"math": "2x^4 - x^3 + 3x^2 - x + 1", "#text": "Polynomial AB: ."}, {"math": ["A", "B"], "#text": "When we multiply the evaluations of  and  at\npoints 0, 1, and -1, we get the following results."}, {"math": "AB", "#text": "These results are the same as when we evaluate polynomial\n at these points."}], "math_block": {"@xml:space": "preserve", "#text": "\\begin{eqnarray*}\nAB(-1) &=& (2)(4) = 8\\\\\nAB(0) &=& (1)(1) = 1\\\\\nAB(1) &=& (2)(2) = 4\n\\end{eqnarray*}"}}, "enumerated_list": [{"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"math": "z^n = 1", "#text": "and"}}, {"paragraph": {"math": ["z^k \\neq 1", "0 < k < n"], "#text": "for ."}}]}, {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"math": ["n-1", "2n-1"], "#text": "Represent an  -degree polynomial as \ncoefficients:"}, "math_block": {"@xml:space": "preserve", "#text": "[a_0, a_1, ..., a_{n-1}, 0, ..., 0]"}}, {"paragraph": {"literal": "Fourier_Transform", "math": ["A", "B"], "#text": "Perform  on the representations for \nand"}}, {"paragraph": {"math": "2n-1", "#text": "Pairwise multiply the results to get  values."}}, {"paragraph": {"literal": "Fourier_Transform", "math": ["2n-1", "AB"], "#text": "Perform the inverse  to get the \ndegree polynomial ."}}]}], "target": {"@refid": "unity"}, "literal_block": {"@xml:space": "preserve", "#text": "Fourier_Transform(double *Polynomial, int n) {\n  // Compute the Fourier transform of Polynomial\n  // with degree n. Polynomial is a list of\n  // coefficients indexed from 0 to n-1. n is\n  // assumed to be a power of 2.\n  double Even[n/2], Odd[n/2], List1[n/2], List2[n/2];\n\n  if (n==1) return Polynomial[0];\n\n  for (j=0; j&lt;=n/2-1; j++) {\n    Even[j] = Polynomial[2j];\n    Odd[j] = Polynomial[2j+1];\n  }\n  List1 = Fourier_Transform(Even, n/2);\n  List2 = Fourier_Transform(Odd, n/2);\n  for (j=0; j&lt;=n-1, J++) {\n    Imaginary z = pow(E, 2*i*PI*j/n);\n    k = j % (n/2);\n    Polynomial[j] = List1[k] + z*List2[k];\n  }\n  return Polynomial;\n}"}}}