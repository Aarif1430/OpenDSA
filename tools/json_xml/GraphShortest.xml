<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="shortest-paths\ problems" ids="shortest-paths-problems" source="&lt;string&gt;" title="Shortest-Paths Problems"><title>Shortest-Paths Problems</title><subtitle dupnames="shortest-paths\ problems" ids="id1">Shortest-Paths Problems</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>On a road map, a road connecting two towns is typically
labeled with its distance.
We can model a road network as a directed graph whose edges are
labeled with real numbers.
These numbers represent the distance (or other cost metric, such as
travel time) between two vertices.
These labels may be called <title_reference>weights &lt;weight&gt;</title_reference>,
<title_reference>costs &lt;cost&gt;</title_reference>, or <title_reference>distances &lt;distance&gt;</title_reference>,
depending on the application.
Given such a graph, a typical problem is to find the total
length of the shortest path between two specified vertices.
This is not a trivial problem, because the shortest path may not be
along the edge (if any) connecting two vertices, but rather may be
along a path involving one or more intermediate vertices.</paragraph><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>For example, in Figure <title_reference>Figure #DistExamp</title_reference>,
the cost of the path from <title_reference>A</title_reference> to <title_reference>B</title_reference> to <title_reference>D</title_reference> is 15.
The cost of the edge directly from <title_reference>A</title_reference> to <title_reference>D</title_reference> is 20.
The cost of the path from <title_reference>A</title_reference> to <title_reference>C</title_reference> to <title_reference>B</title_reference> to
<title_reference>D</title_reference> is 10.
Thus, the shortest path from <title_reference>A</title_reference> to <title_reference>D</title_reference> is 10
(rather than along the edge connecting <title_reference>A</title_reference> to <title_reference>D</title_reference>).
We use the notation <title_reference>mathbf{d}(A, D) = 10</title_reference> to indicate that the
shortest distance from <title_reference>A</title_reference> to <title_reference>D</title_reference> is 10.
In Figure <title_reference>Figure #DistExamp</title_reference>, there is no path from <title_reference>E</title_reference> to
<title_reference>B</title_reference>, so we set <title_reference>mathbf{d}(E, B) = infty</title_reference>.
We define <title_reference>mathbf{w}(A, D) = 20</title_reference> to be the weight of edge
<title_reference>(A, D)</title_reference>, that is, the weight of the direct connection
from <title_reference>A</title_reference> to <title_reference>D</title_reference>.
Because there is no edge from <title_reference>E</title_reference> to <title_reference>B</title_reference>,
<title_reference>mathbf{w}(E, B) = infty</title_reference>.
Note that <title_reference>mathbf{w}(D, A) = infty</title_reference> because the graph of
Figure <title_reference>Figure #DistExamp</title_reference> is directed.
We assume that all weights are positive.</paragraph><target refid="distexamp"></target><raw format="xml" ids="distexamp" names="distexamp" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="dijkstraCON"
    long_name="dijkstraCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><section ids="single-source-shortest-paths" names="single-source\ shortest\ paths"><title>Single-Source Shortest Paths</title><paragraph>We will now present an algorithm to solve the
<title_reference>single-source shortest paths problem</title_reference>.
Given Vertex <title_reference>S</title_reference> in Graph <title_reference>mathbf{G}</title_reference>,
find a shortest path from <title_reference>S</title_reference> to every other vertex in
<title_reference>mathbf{G}</title_reference>.
We might want only the shortest path between two vertices,
<title_reference>S</title_reference> and <title_reference>T</title_reference>.
However in the worst case, finding the shortest path from
<title_reference>S</title_reference> to <title_reference>T</title_reference> requires us to find the shortest paths from
<title_reference>S</title_reference> to every other vertex as well.
So there is no better algorithm (in the worst case) for
finding the shortest path to a single vertex than to find shortest
paths to all vertices.
The algorithm described here will only compute the distance to every
such vertex, rather than recording the actual path.
Recording the path requires only simple modifications to the algorithm.</paragraph><paragraph>Computer networks provide an application for the single-source
shortest-paths problem.
The goal is to find the cheapest way for one computer to broadcast
a message to all other computers on the network.
The network can be modeled by a graph with edge weights indicating
time or
cost to send a message to a neighboring computer.</paragraph><paragraph>For unweighted graphs (or whenever all edges have the same cost), the
single-source shortest paths can be found using a simple breadth-first
search.
When weights are added, BFS will not give the correct answer.</paragraph><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>One approach to solving this problem when the edges have
differing weights might be to process the
vertices in a fixed order.
Label the vertices <title_reference>v_0</title_reference> to <title_reference>v_{n-1}</title_reference>, with
<title_reference>S = v_0</title_reference>.
When processing Vertex <title_reference>v_1</title_reference>, we take the edge connecting
<title_reference>v_0</title_reference> and <title_reference>v_1</title_reference>.
When processing <title_reference>v_2</title_reference>, we consider the shortest distance from
<title_reference>v_0</title_reference> to <title_reference>v_2</title_reference> and compare that to the shortest
distance from <title_reference>v_0</title_reference> to <title_reference>v_1</title_reference> to <title_reference>v_2</title_reference>.
When processing Vertex <title_reference>v_i</title_reference>, we consider the shortest
path for Vertices <title_reference>v_0</title_reference> through <title_reference>v_{i-1}</title_reference> that have
already been processed.
Unfortunately, the true shortest path to <title_reference>v_i</title_reference> might go
through Vertex <title_reference>v_j</title_reference> for <title_reference>j &gt; i</title_reference>.
Such a path will not be considered by this algorithm.
However, the problem would not occur if we process the vertices in
order of distance from <title_reference>S</title_reference>.
Assume that we have processed in order of distance from <title_reference>S</title_reference> to
the first <title_reference>i-1</title_reference> vertices that are closest to <title_reference>S</title_reference>;
call this set of vertices <title_reference>mathbf{S}</title_reference>.
We are now about to process the <title_reference>i</title_reference> th closest vertex; call
it <title_reference>X</title_reference>.</paragraph><paragraph>A shortest path from <title_reference>S</title_reference> to <title_reference>X</title_reference> must have its next-to-last
vertex in <title_reference>S</title_reference>.
Thus,</paragraph><math_block xml:space="preserve">\mathbf{d}(S, X) =
\min_{U \in \mathbf{S}}(\mathbf{d}(S, U) + \mathbf{w}(U, X)).</math_block><paragraph>In other words, the shortest path from <title_reference>S</title_reference> to <title_reference>X</title_reference> is the
minimum over all paths that go from <title_reference>S</title_reference> to <title_reference>U</title_reference>, then have an
edge from <title_reference>U</title_reference> to <title_reference>X</title_reference>, where <title_reference>U</title_reference> is some vertex
in <title_reference>mathbf{S}</title_reference>.</paragraph><paragraph>This solution is usually referred to as Dijkstra's algorithm.
It works by maintaining a distance estimate
<title_reference>mathbf{D}(X)</title_reference> for all vertices <title_reference>X</title_reference> in <title_reference>mathbf{V}</title_reference>.
The elements of <title_reference>mathbf{D}</title_reference> are initialized to the value
<literal>INFINITE</literal>.
Vertices are processed in order of distance from <title_reference>S</title_reference>.
Whenever a vertex <title_reference>v</title_reference> is processed, <title_reference>mathbf{D}(X)</title_reference> is
updated for every neighbor <title_reference>X</title_reference> of <title_reference>V</title_reference>.
Here is an implementation for Dijkstra's
algorithm.
At the end, array <literal>D</literal> will contain the shortest distance values.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="DijkstraAV"
    long_name="DijkstraAV"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>There are two reasonable solutions to the key issue of finding the
unvisited vertex with minimum distance value during each pass through
the main <literal>for</literal> loop.
The first method is simply to scan through the list of
<title_reference>|mathbf{V}|</title_reference> vertices searching for the minimum value, as
follows:</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>Because this scan is done <title_reference>|mathbf{V}|</title_reference> times,
and because each edge requires a constant-time update to <literal>D</literal>,
the total cost for this approach
is <title_reference>Theta(|mathbf{V}|^2 + |mathbf{E}|) =
Theta(|mathbf{V}|^2)</title_reference>,
because <title_reference>|mathbf{E}|</title_reference> is in <title_reference>O(|mathbf{V}|^2)</title_reference>.</paragraph><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>An alternative approach is to store unprocessed vertices in a
min-heap ordered by their distance from the processed vertices.
The next-closest vertex can be found in the heap in
<title_reference>Theta(log |mathbf{V}|)</title_reference> time.
Every time we modify <title_reference>mathbf{D}(X)</title_reference>,
we could reorder <title_reference>X</title_reference> in
the heap by deleting and reinserting it.
This is an example of a <title_reference>priority queue &lt;priority queue&gt; &lt;Heaps&gt;</title_reference>
with priority update.
To implement true priority updating, we would need to store with each
vertex its position within the heap so that we can remove its old
distances whenever it is updated by processing new edges.
A simpler approach is to add the new (always smaller) distance value
for a given vertex as a new record in the heap.
The smallest value for a given vertex currently in the heap will be
found first, and greater distance values found later will be ignored
because the vertex will already be marked as <literal>VISITED</literal>.
The only disadvantage to repeatedly inserting distance values in this
way is that it will raise the number of elements in the heap from
<title_reference>Theta(|mathbf{V}|)</title_reference> to <title_reference>Theta(|mathbf{E}|)</title_reference>
in the worst case.
But in practice this only adds a slight increase to the depth of the
heap.
The time complexity is
<title_reference>Theta((|mathbf{V}| + |mathbf{E}|) log |mathbf{E}|)</title_reference>,
because for each edge that we process we must reorder the heap.
We use the <literal>KVPair</literal> class to store key-value pairs in the heap, with
the edge weight as the key and the target vertex as the value.
here is the implementation for Dijkstra's algorithm using a heap.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>Using <literal>MinVertex</literal> to scan the vertex list for the minimum value
is more efficient when the graph is dense, that is, when
<title_reference>|mathbf{E}|</title_reference> approaches <title_reference>|mathbf{V}|^2</title_reference>.
Using a heap is more efficient when the graph is sparse
because its cost is
<title_reference>Theta((|mathbf{V}| + |mathbf{E}|) log |mathbf{E}|)</title_reference>.
However, when the graph is dense, this cost can become as great as
<title_reference>Theta(|mathbf{V}|^2 log |mathbf{E}|) = Theta(|V|^2 log |V|)</title_reference>.</paragraph><raw format="xml" xml:space="preserve"><todo>null</todo></raw><paragraph>Now you can practice using Dijkstra's algorithm.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="DijkstraPE"
    long_name="DijkstraPE"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Graph/dijkstraCON.js</odsascript></raw></section></document>