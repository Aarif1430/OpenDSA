<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.2a -->
<document ids="binary-trees-chapter-introduction" names="binary\ trees\ chapter\ introduction" source="&lt;string&gt;" title="Binary Trees Chapter Introduction"><title>Binary Trees Chapter Introduction</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph><title_reference>Tree &lt;tree&gt;</title_reference> structures enable efficient access and efficient
update to large collections of data.
<title_reference>Binary trees &lt;binary tree&gt;</title_reference> in particular are widely used and
relatively easy to implement.
But binary trees are useful for many things besides searching.
Just a few examples of applications that trees can speed up include
<title_reference>prioritizing jobs &lt;priority queue&gt; &lt;Heaps&gt;</title_reference>,
<title_reference>describing mathematical expressions &lt;expression tree&gt; &lt;BinaryTreeImpl&gt;</title_reference>
and the syntactic elements of computer programs,
or organizing the information needed to drive
<title_reference>data compression algorithms &lt;Huffman codes&gt; &lt;Huffman&gt;</title_reference>.</paragraph><paragraph>This chapter covers terminology used for discussing binary trees,
<title_reference>tree traversals &lt;tree traversal&gt;</title_reference>, approaches to implementing
tree <title_reference>nodes &lt;node&gt;</title_reference>, and various examples of binary trees.</paragraph></document>