<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="software\ development\ processes" ids="software-development-processes" source="&lt;string&gt;" title="Software Development Processes"><title>Software Development Processes</title><subtitle dupnames="software\ development\ processes" ids="id1">Software Development Processes</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2015-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><index>null</index></raw><raw format="xml" xml:space="preserve"><index>null</index></raw><paragraph>A <strong>software development process</strong> is simply the division of a software project into
distinct stages or phases of work.
Each stage is characterized by specific activities which are used to help plan and
manage progress.
A software development process is implemented to improve quality, cost or schedule
performance, or all of these things.
While there as many software development processes as there are software practitioners,
a few have gained notoriety.
These more commonly encountered processes are the ones discussed in this section.</paragraph><paragraph>All software development processes are essentially variations on the <emphasis>Plan-Do-Check-Act</emphasis>
first described by Francis Bacon in 1620 [Bacon].  Yes, that’s right.
There are many software development processes, describing the  <emphasis>Plan-Do-Check-Act</emphasis> loop
in varying levels of detail.  Today, most of these processes are lumped into either
of two very broad categories: <emphasis>Agile</emphasis> or <emphasis>Plan Driven</emphasis>.</paragraph><paragraph>Plan Driven processes emerged in the 1960's.
As the size of software projects grew, several worrying trends emerged:</paragraph><block_quote><bullet_list bullet="-"><list_item><paragraph>Software projects routinely went over budget, or failed to deliver anything</paragraph></list_item><list_item><paragraph>Major defects and failures became more common</paragraph></list_item><list_item><paragraph>Software maintenance costs began increasing</paragraph></list_item></bullet_list></block_quote><paragraph>At the time, there was no professional class of programmers.
Engineers, mathematicians, and physicists wrote programs to support their work.
The first software development processes were adapted from manufacturing and engineering
processes.
Among the earliest was the systems development life cycle (SLDC).
The goals of the SDLC were
"to pursue the development of information systems in a very deliberate,
structured and methodical way, requiring each stage of the life cycle from
inception of the idea to delivery of the final system,
to be carried out rigidly and sequentially" <footnote_reference auto="1" ids="id2" refid="id4">1</footnote_reference>.
Plan-driven methods continue to be the 'traditional' way most software
continues to be developed today.</paragraph><paragraph>Agile methods grew out frustration with the rigidity of the plan-driven processes commonly used
in the 1990's just as the tech boom was heating up.
Technology was changing faster than projects could keep up and many projects failed because
by the time they were ready to deliver, the playing field had changed enough to make the product,
if not obsolete, at least a less compelling commercial success.</paragraph><paragraph>The practitioners of Agile methods tend to be a diverse and fraction group, but have, as a group
drafted a single statement that nearly all agile process models embrace.
It is known as the <emphasis>Agile Manifesto</emphasis> <footnote_reference auto="1" ids="id3" refid="id5">2</footnote_reference>.  Here it is in it's entirety:</paragraph><block_quote><line_block><line>We are uncovering better ways of developing
software by doing it and helping others do it.</line><line></line><line>Through this work we have come to value:</line><line></line><line><strong>Individuals and interactions</strong> over processes and tools</line><line><strong>Working software</strong> over comprehensive documentation</line><line><strong>Customer collaboration</strong> over contract negotiation</line><line><strong>Responding to change</strong> over following a plan</line><line></line><line>That is, while there is value in the items on the right, we value the items on the left <strong>more</strong>.</line></line_block></block_quote><paragraph>Much of the documentation available today implies that choosing a process is
an <emphasis>either - or</emphasis> proposition.  That a project must be either plan driven or agile.
The reality is a bit more nuanced and there can can be bitter disagreements
between proponents of different process models.
One way to summarize the differences between the two groups is to examine the
myths propagated about them.</paragraph><paragraph>Common misunderstandings directed at Plan-driven processes include:</paragraph><bullet_list bullet="-"><list_item><definition_list><definition_list_item><term>Can’t respond to change</term><definition><bullet_list bullet="-"><list_item><paragraph>Too big and complex</paragraph></list_item></bullet_list></definition></definition_list_item></definition_list></list_item><list_item><paragraph>Products cost more</paragraph></list_item><list_item><paragraph>Only for large organizations</paragraph></list_item><list_item><paragraph>Old-Fashioned</paragraph></list_item><list_item><paragraph>Universally Applicable
- Software development is uncertain and the <strong>X</strong> process improves predictability therefore all software developers should use process <strong>X</strong></paragraph></list_item></bullet_list><paragraph>Common misunderstandings directed at agile processes include:</paragraph><bullet_list bullet="-"><list_item><paragraph>Agile is synonymous with Hacking</paragraph></list_item><list_item><definition_list><definition_list_item><term>It’s a ‘silver bullet’</term><definition><bullet_list bullet="-"><list_item><paragraph>Easy to implement, Very effective</paragraph></list_item></bullet_list></definition></definition_list_item></definition_list></list_item><list_item><definition_list><definition_list_item><term>Do whatever you want</term><definition><bullet_list bullet="-"><list_item><paragraph>No cost or schedule commitments</paragraph></list_item></bullet_list></definition></definition_list_item></definition_list></list_item><list_item><definition_list><definition_list_item><term>Incompatible with traditional processes</term><definition><bullet_list bullet="-"><list_item><paragraph>No Documentation, Architecture, or Planning</paragraph></list_item><list_item><paragraph>Not appropriate for Firm Fixed Price Projects</paragraph></list_item></bullet_list></definition></definition_list_item></definition_list></list_item><list_item><definition_list><definition_list_item><term>Universally Applicable</term><definition><bullet_list bullet="-"><list_item><paragraph>The pace of IT change is accelerating and Agile methods adapt to change better than disciplined methods therefore Agile methods will take over the IT world.</paragraph></list_item></bullet_list></definition></definition_list_item></definition_list></list_item></bullet_list><paragraph>The truth is that many agile and plan-driven methods exist.
All are more or less plan-driven and some have more 'agile' characteristics than others.
Therefore, a more accurate characterisation is to think of processes
existing along a continuum, with the axis representing the relative
amount of willingness to embrace change (agility) at one and
the importance of comprehensive up front planning and adhering to that plan
at the opposite end.  No process exists at either extreme.</paragraph><raw format="xml" xml:space="preserve"><odsafig>null</odsafig></raw><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Scrum is not a complete software development process description as it covers only project management.</paragraph></list_item><list_item><paragraph>CMMI is a process improvement model, not a software development methodology, but is often considered one.</paragraph></list_item></enumerated_list><paragraph>Each group has a sweet-spot where it outperforms the other as the following table summarizes.</paragraph><table><tgroup cols="3"><colspec colwidth="15"></colspec><colspec colwidth="65"></colspec><colspec colwidth="95"></colspec><thead><row><entry><paragraph>Characteristics</paragraph></entry><entry><paragraph>Agile</paragraph></entry><entry><paragraph>Plan Driven</paragraph></entry></row></thead><tbody><row><entry><paragraph>Primary Goals</paragraph></entry><entry><paragraph>Rapid Value, respond to change</paragraph></entry><entry><paragraph>Predictability, stability, &amp; high assurance</paragraph></entry></row><row><entry><paragraph>Size</paragraph></entry><entry><paragraph>Small Teams and projects</paragraph></entry><entry><paragraph>Large teams and projects</paragraph></entry></row><row><entry><paragraph>Environment</paragraph></entry><entry><paragraph>Turbulent, project-focused</paragraph></entry><entry><paragraph>Stable, organization-focused</paragraph></entry></row><row><entry><paragraph>Requirements</paragraph></entry><entry><paragraph>Stories.  Rapid change expected.</paragraph></entry><entry><paragraph>Formal Specs for projects, capability, interfaces, quality &amp; similar.  Gradual change expected.</paragraph></entry></row><row><entry><paragraph>Development</paragraph></entry><entry><paragraph>Simple design, short increments. Refactoring assumed inexpensive.</paragraph></entry><entry><paragraph>Detailed architecture and design.  Refactoring assumed expensive.</paragraph></entry></row><row><entry><paragraph>Test</paragraph></entry><entry><paragraph>Executable tests validate requirements</paragraph></entry><entry><paragraph>Documented test plans validate requirements</paragraph></entry></row></tbody></tgroup></table><paragraph>Balancing the trade-offs between agility and discipline is a decision each
software development project has to make on their own.</paragraph><raw format="xml" xml:space="preserve"><odsafig>null</odsafig></raw><footnote auto="1" backrefs="id2" ids="id4" names="1"><label>1</label><paragraph>Geoffrey Elliott. <emphasis>Global Business Information Technology: an integrated systems approach</emphasis>. Pearson Education. 2004.</paragraph></footnote><footnote auto="1" backrefs="id3" ids="id5" names="2"><label>2</label><paragraph><reference refuri="http://www.agilealliance.org/">http://www.agilealliance.org/</reference></paragraph></footnote><section ids="waterfall-method" names="waterfall\ method"><title>Waterfall Method</title><paragraph>Initially described in 1970, the Waterfall process was another early
software development process adapted from manufacturing and construction processes.
The waterfall model is a sequential design process, in which progress is seen as
flowing steadily downwards (like a waterfall) through several distinct phases.</paragraph><raw format="xml" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>While many variations exist, most waterfall processes in use go through at least
the following phases:</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Requirements: System and software requirements, captured in a product requirements document.</paragraph></list_item><list_item><paragraph>Analysis: resulting in models, schema, and business rules</paragraph></list_item><list_item><paragraph>Design: resulting in the software architecture</paragraph></list_item><list_item><paragraph>Implementation: the development and integration of software</paragraph></list_item><list_item><paragraph>Verification: the systematic discovery and debugging of defects</paragraph></list_item><list_item><paragraph>Maintenance: the installation, migration, support, and maintenance of complete systems</paragraph></list_item></enumerated_list><paragraph>The waterfall model was simple to understand and was widely used throughout the 1980's,
but came under criticism primarily for it's lack of flexibility.
Although officially endorsed bu the US Department of Defense in 1985, the DoD supplanted
it with other process guidance 10 years later.</paragraph><footnote auto="1" ids="id6" names="3"><label>3</label><paragraph>Peter Kemp / Paul Smith, <emphasis>Waterfall model</emphasis>
(Adapted from Paul Smith's work at wikipedia)
[CC BY 3.0 (<reference refuri="http://creativecommons.org/licenses/by/3.0">http://creativecommons.org/licenses/by/3.0</reference>)], via Wikimedia Commons</paragraph></footnote></section><section ids="rational-unified-process" names="rational\ unified\ process"><title>Rational Unified Process</title><paragraph>The Unified Software Development Process or Unified Process is a popular iterative
and incremental software development process framework.
The best-known and extensively documented refinement of the Unified Process is the
Rational Unified Process (RUP).
Other examples are OpenUP and Agile Unified Process.</paragraph><paragraph>The Rational Unified Process (RUP) was created by the Rational Software Corporation in 1996.
RUP is not a single concrete prescriptive process, but rather an adaptable process framework,
intended to be tailored by the development organizations and software project teams that
will select the elements of the process that are appropriate for their needs.</paragraph><paragraph>RUP is based on a set of building blocks and content elements,
describing what is to be produced, the necessary skills required and
the step-by-step explanation describing how specific development goals are to be achieved.
The main building blocks, or content elements, are the following:</paragraph><definition_list><definition_list_item><term><strong>Roles (who)</strong></term><definition><paragraph>A role defines a set of related skills, competencies and responsibilities.</paragraph></definition></definition_list_item><definition_list_item><term><strong>Work products (what)</strong></term><definition><paragraph>A work product represents something resulting from a task,
including all the documents and models produced while working through the process.</paragraph></definition></definition_list_item><definition_list_item><term><strong>Tasks (how)</strong></term><definition><paragraph>A task describes a unit of work assigned to a Role that provides a meaningful result.</paragraph></definition></definition_list_item></definition_list><raw format="xml" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>The RUP defines a project as a series of <emphasis>iterations</emphasis>.
An iteration is a period of time in which project tasks are performed.
Within each iteration, the tasks are categorized into nine disciplines:</paragraph><bullet_list bullet="-"><list_item><paragraph>Six "engineering" disciplines</paragraph><block_quote><bullet_list bullet="-"><list_item><paragraph>Business modelling</paragraph></list_item><list_item><paragraph>Requirements</paragraph></list_item><list_item><paragraph>Analysis and design</paragraph></list_item><list_item><paragraph>Implementation</paragraph></list_item><list_item><paragraph>Test</paragraph></list_item><list_item><paragraph>Deployment</paragraph></list_item></bullet_list></block_quote></list_item><list_item><paragraph>And three "supporting" disciplines</paragraph><block_quote><bullet_list bullet="-"><list_item><paragraph>Configuration and change management</paragraph></list_item><list_item><paragraph>Project management</paragraph></list_item><list_item><paragraph>Environment</paragraph></list_item></bullet_list></block_quote></list_item></bullet_list><paragraph>Other Plan-Driven Approaches</paragraph><definition_list><definition_list_item><term>Military Methods (DoD)</term><definition><definition_list><definition_list_item><term>DoD-STD-2167</term><definition><paragraph>A document-driven approach that specified a large number of
"Data Item Descriptions" for deliverables.
Tailoring was encouraged, but infrequently done.</paragraph></definition></definition_list_item><definition_list_item><term>MIL-STD-1521</term><definition><paragraph>details a set of sequential reviews and audits required.</paragraph></definition></definition_list_item><definition_list_item><term>MIL-STD-498</term><definition><paragraph>revised 2167 to allow more flexibility in systems engineering, planning,
development, and integration.</paragraph></definition></definition_list_item><definition_list_item><term>MIL-STD-499B</term><definition><paragraph>defines the contents of a systems engineering management plan.</paragraph></definition></definition_list_item></definition_list></definition></definition_list_item><definition_list_item><term>General Process Standards (ISO, EIA, IEEE)</term><definition><definition_list><definition_list_item><term>EIA/IEEE J-STD-016</term><definition><paragraph>a generalization of MIL-STD-498 to include commercial software processes.</paragraph></definition></definition_list_item><definition_list_item><term>ISO 9000</term><definition><paragraph>a quality management standard that includes software.</paragraph></definition></definition_list_item><definition_list_item><term>ISO 12207 and 15504</term><definition><paragraph>address the software life cycle and ways to appraise software processes.</paragraph></definition></definition_list_item></definition_list></definition></definition_list_item><definition_list_item><term>Cleanroom (Harlan Mills, IBM)</term><definition><paragraph>Uses statistical process control and mathematically based verification to develop software
with certified reliability.</paragraph><paragraph>The name comes from physical clean rooms that prevent defects in precision electronics.</paragraph></definition></definition_list_item><definition_list_item><term>Capability Maturity Model for Software (SEI, Air Force, others)</term><definition><paragraph>A process improvement framework, SW-CMM grew out of the need for the Air Force to
select qualified software system developers.</paragraph><paragraph>Collects best practices into Key Practice Areas that are organized into
five levels of increasing process maturity.</paragraph></definition></definition_list_item><definition_list_item><term>Software Factories (Hitachi, GE, others)</term><definition><paragraph>A long-term, integrated effort to improve software quality, software reuse, and software
development productivity.</paragraph><paragraph>Highly process-driven, emphasizing early defect reduction.</paragraph></definition></definition_list_item><definition_list_item><term>CMM Integration (SEI, DoD, NDIA, others)</term><definition><paragraph>CMMI was established to integrate software and systems engineering CMMs, and improve
or extend the CMM concept to other disciplines.</paragraph><paragraph>Its a suite of models and appraisal methods that address a variety of disciplines using
a common architecture, vocabulary, and a core of process areas.</paragraph></definition></definition_list_item><definition_list_item><term>Personal Software Process (PSP)/Team Software Process (TSP) (Watts Humphrey, SEI)</term><definition><definition_list><definition_list_item><term>PSP</term><definition><paragraph>A structured framework of forms, guidelines, and procedures for developing software.
Directed toward the use of self-measurement to improve individual programming skills.</paragraph></definition></definition_list_item><definition_list_item><term>TSP</term><definition><paragraph>Builds on PSP and supports the development of industrial-strength software through
the use of team planning and control.</paragraph></definition></definition_list_item></definition_list></definition></definition_list_item></definition_list></section><section ids="extreme-programming-xp" names="extreme\ programming\ (xp)"><title>eXtreme Programming (XP)</title><paragraph>Established in the late 1990's by Kent Beck, XP is
regarded as perhaps the most famous agile method.
XP was certainly among the first to gain attention from mainstream
software development projects.
XP was refined from experience gained developing an information system for Daimler Chrysler
corporation.
As agile practices go, it is quite proscriptive, fairly rigorous and
initially expects all practices to be followed.
Kent Beck has been quoted as saying</paragraph><block_quote><paragraph>If you're not performing all 12 practices, then you're not doing XP.</paragraph></block_quote><paragraph>In <emphasis>Extreme Programming Explained</emphasis>, Kent Beck describes extreme programming as a
software development discipline that organizes people to produce higher quality
software more productively.
XP attempts to reduce the cost of changes in requirements by having multiple
short development cycles, rather than a long one.
Rather than a burden, changes are considered a natural, inescapable and desirable aspect of
software projects, and should be planned for, instead of attempting
to define a stable set of requirements.</paragraph><raw format="xml" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>XP is characterised by several core practices including
stories, pair programming, simple design,
test first, unit tests, and continuous integration.</paragraph><paragraph>The XP process describes four basic activities that are performed
within the software development process:
coding, testing, listening, and designing.</paragraph><definition_list><definition_list_item><term>Coding</term><definition><paragraph>XP argues that the only truly important product of the software
development process is code – software instructions that a computer can interpret.
Without code, there is no working product.</paragraph><paragraph>Coding can also be used to figure out the most suitable solution.
Coding can also help to communicate thoughts about programming problems.
A programmer dealing with a complex programming problem, or finding it hard to
explain the solution to fellow programmers, might code it in a simplified manner
and use the code to demonstrate what he or she means.
Code, say the proponents of this position, is always clear and concise
and cannot be interpreted in more than one way.
Other programmers can give feedback on this code by also coding their thoughts.</paragraph></definition></definition_list_item><definition_list_item><term>Testing</term><definition><paragraph>Unit tests determine whether a given feature works as intended.
A programmer writes as many automated tests as they can think of that might "break" the code;
if all tests run successfully, then the coding is complete.
Every piece of code that is written is tested before moving on to the next feature.</paragraph><paragraph>Acceptance tests verify that the requirements as understood by the programmers
satisfy the customer's actual requirements.</paragraph><paragraph>System-wide integration testing was encouraged, initially,
as a daily end-of-day activity, for early detection of incompatible interfaces,
to reconnect before the separate sections diverged widely from coherent functionality.</paragraph></definition></definition_list_item><definition_list_item><term>Listening</term><definition><paragraph>Programmers must listen to what the customers need the system to do,
what "business logic" is needed.
They must understand these needs well enough to give the customer feedback
about the technical aspects of how the problem might be solved, or cannot be solved.
Communication between the customer and programmer is further addressed in the planning game.</paragraph></definition></definition_list_item><definition_list_item><term>Designing</term><definition><paragraph>As software systems grow, the importance of design increases.
Small programs can be constructed with comparatively little design,
however as software size grows, the more design is required.
Often more upfront design is required as well as checking and revisiting
designs throughout the lifetime of the project.</paragraph></definition></definition_list_item></definition_list><footnote auto="1" ids="id7" names="4"><label>4</label><paragraph>Don Wells, <emphasis>Planning / Feedback Loops</emphasis>
(<reference refuri="https://en.wikipedia.org/wiki/File:XP-feedback.gif">https://en.wikipedia.org/wiki/File:XP-feedback.gif</reference>)
[CC BY-SA 3.0 (<reference refuri="http://creativecommons.org/licenses/by-sa/3.0">http://creativecommons.org/licenses/by-sa/3.0</reference>)], via Wikimedia Commons</paragraph></footnote></section><section ids="crystal" names="crystal"><title>Crystal</title><paragraph>Established in the late 1990's by Alistair Cockburn, Crystal is
conceived as a family of software development processes organized by color,
clear, yellow, orange, red.
To date, only Crystal Clear, the most light-weight in the family, has been completely documented.</paragraph><paragraph>Crystal provides different levels of “ceremony” depending on the size of the team and the
criticality of the project.
Crystal practices draw from agile and plan-driven methods as well as psychology
and organizational development research.</paragraph></section><section ids="scrum" names="scrum"><title>Scrum</title><paragraph>Scrum is an agile software management process.
That is, it describes how software development teams should be organised and
let's each team determine what technical software development activities they
should perform.</paragraph><paragraph>Projects are divided into 30-day work intervals (“sprints”) in which a
specific number of requirements from a prioritized list (“backlog”) are implemented.
Short (10-15 minute) “Scrum meetings”, held daily, maintain coordination within the team and with
project stakeholders (pigs and chickens).</paragraph></section><section ids="feature-driven-development-fdd" names="feature-driven\ development\ (fdd)"><title>Feature-Driven Development (FDD)</title><paragraph>FDD is a lightweight, architecturally based process that initially establishes
an overall object architecture and features list.
Projects then proceed to design-by-feature and build-by-feature activities.
Both design-by-feature and build-by-feature are incremental software
construction methodologies.
In FDD, the use of UML or other object-oriented design methods is strongly implied,
if not explicitly required.</paragraph></section></document>