<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="reference\ parameters" ids="reference-parameters" source="&lt;string&gt;" title="Reference Parameters"><title>Reference Parameters</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><section dupnames="reference\ parameters" ids="id1"><title>Reference Parameters</title><paragraph>In the simplest <title_reference>pass by value</title_reference> or <title_reference>value parameter</title_reference>
scheme, each function has separate, local memory and parameters are
copied from the caller to the callee at the moment of the function
call.
But what about the other direction?
How can the callee communicate back to its caller?
Using a "return" at the end of the callee to copy a result back to the
caller works for simple cases, but does not work well for all
situations.
Also, sometimes copying values back and forth is undesirable.
<title_reference>Pass by reference</title_reference> parameters solve all of these problems.
For the following discussion, the term "value of interest" will be a
value that the caller and callee wish to communicate between each
other.
A reference parameter passes a pointer to the value of interest
instead of a copy of the value of interest.
This technique uses the sharing property of pointers so that the
caller and callee can share the value of interest.</paragraph><section ids="bill-gates-example" names="bill\ gates\ example"><title>Bill Gates Example</title><paragraph>Suppose functions <literal>A()</literal> and <literal>B()</literal> both do computations involving Bill Gates' net worth
measured in billions of dollars  the value of interest for this problem. <literal>A()</literal> is the main
function and its stores the initial value (about 55 as of 1998). <literal>A()</literal> calls <literal>B()</literal> which tries to
add 1 to the value of interest.</paragraph></section><section ids="bill-gates-by-value" names="bill\ gates\ by\ value"><title>Bill Gates By Value</title><paragraph>Here is the code and memory drawing for a simple, but incorrect implementation where
<literal>A()</literal> and <literal>B()</literal> use pass by value. Three points in time, T1, T2, and T3 are marked in the
code and the state of memory is shown for each state...</paragraph><literal_block xml:space="preserve">void B(int worth) {
  worth = worth + 1;
  // T2
}

void A() {
  int netWorth;
  netWorth = 55;  // T1

  B(netWorth);
  // T3 -- B() did not change netWorth
}</literal_block><raw format="xml" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph><literal>B()</literal> adds 1 to its local <literal>worth</literal> copy, but when <literal>B()</literal> exits, <literal>worth</literal> is deallocated, so changing it was useless. The value of interest,
<title_reference>netWorth</title_reference>, rests unchanged the whole time in A()'s local storage. A function can change its local copy of the value of interest,
but that change is not reflected back in the original value. This is
really just the old "independence" property of local storage, but in
this case it is not what is wanted.</paragraph></section><section ids="by-reference" names="by\ reference"><title>By Reference</title><paragraph>The reference solution to the Bill Gates problem is to use a single
<literal>netWorth</literal> variable for the value of interest and never copy
it. Instead, each function can receives a pointer to <literal>netWorth</literal>.
Each function can see the current value of <title_reference>netWorth</title_reference> by dereferencing its pointer. More importantly, each function can change the net
<literal>worth</literal>   just dereference the pointer to the centralized  <literal>netWorth</literal> and change it directly. Everyone agrees what
the current value of <literal>netWorth</literal>  because it exists in only one place  everyone has a pointer to the one master copy. The following memory drawing shows <title_reference>A()</title_reference> and <title_reference>B()</title_reference>
functions changed to use <title_reference>reference parameters</title_reference>.
As before, T1, T2, and T3 correspond to points in the code (below),
but you can study the memory structure without looking at the code
yet.</paragraph><raw format="xml" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>The reference parameter strategy: <literal>B()</literal> receives a pointer to the value of interest instead of
a copy.</paragraph></section></section><section ids="passing-by-reference" names="passing\ by\ reference"><title>Passing By Reference</title><paragraph>Here are the steps to use in the code to use the pass-by-reference strategy:</paragraph><bullet_list bullet="*"><list_item><paragraph>Have a single copy of the value of interest.
The single "master" copy.</paragraph></list_item><list_item><paragraph>Pass pointers to that value to any function which wants to see or
change the value.</paragraph></list_item><list_item><paragraph>Functions can dereference their pointer to see or change the value
of interest.</paragraph></list_item><list_item><paragraph>Functions must remember that they do not have their own local
copies. If they dereference their pointer and change the value, they
really are changing the master value. If a function wants a local
copy to change safely, the function must explicitly allocate and
initialize such a local copy.</paragraph></list_item></bullet_list><section ids="syntax" names="syntax"><title>Syntax</title><paragraph>The syntax for by reference parameters  in the C language just uses pointer operations on
the parameters:</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Suppose a function wants to communicate about some value of
interest  <literal>int</literal> or <literal>float</literal> or <literal>struct fraction</literal>.</paragraph></list_item><list_item><paragraph>The function takes as its parameter a pointer to the value of
interest  an <literal>int*</literal>  or <literal>float*</literal> or <literal>struct fraction*</literal>.
Some programmers will add the word "ref" to the name of a reference
parameter as a reminder that it is a reference to the value of
interest instead of a copy.</paragraph></list_item><list_item><paragraph>At the time of the call, the caller computes a pointer to the value
of interest and passes that pointer. The type of the pointer
(pointer to the value of interest) will agree with the type in (2)
above. If the value of interest is local to the caller, then this
will often involve a use of the &amp; operator (Section 1).</paragraph></list_item><list_item><paragraph>When the callee is running, if it wishes to access the value of
interest, it must dereference its pointer to access the actual
value of interest. Typically, this equates to use of the
dereference operator (<literal>*</literal>) in the function to see the value of
interest.</paragraph></list_item></enumerated_list></section><section ids="bill-gates-by-reference" names="bill\ gates\ by\ reference"><title>Bill Gates By Reference</title><paragraph>Here is the Bill Gates example written to use reference
parameters. This code now matches the by-reference memory drawing
above.</paragraph><literal_block xml:space="preserve">     // B() now uses a reference parameter -- a pointer to
     // the value of  interest. B() uses a dereference (*) on the
     // reference parameter to get at the value of interest.
     void B(int* worthRef) {
     // reference parameter
     *worthRef = *worthRef + 1; // use * to get at value of interest
     // T2
     }

     void A() {
     int netWorth;
     netWorth = 55; // T1 -- the value of interest is local to A()
     B(&amp;netWorth);  // Pass a pointer to the value of interest.
                    // In this case using &amp;.
     // T3 -- B() has used its pointer to change the value of interest
}</literal_block></section><section ids="don-t-make-copies" names="don't\ make\ copies"><title>Don't Make Copies</title><paragraph>Reference parameters enable communication between the callee and its
caller.
Another reason to use reference parameters is to avoid making
copies.
For efficiency, making copies may be undesirable if the value of
interest is large, such as an array.
Making the copy requires extra space for the copy itself and extra
time to do the copying.
From a design point of view, making copies may be undesirable because
as soon as there are two copies, it is unclear which one is the
"correct" one if either is changed.
Proverb: "A person with one watch always knows what time it is.
A person with two watches is never sure."
Avoid making copies.</paragraph></section></section><section ids="simple-reference-parameter-example-swap" names="simple\ reference\ parameter\ example:\ swap()"><title>Simple Reference Parameter Example: Swap()</title><paragraph>The standard example of reference parameters is a <literal>Swap()</literal> function
that exchanges the values of two <literal>ints</literal>.
It's a simple function, but it does need to change the caller's memory
which is the key feature of pass by reference.</paragraph><section ids="swap-function" names="swap()\ function"><title>Swap() Function</title><paragraph>The values of interest for <literal>Swap()</literal> are two <literal>ints</literal>.
Therefore, <literal>Swap()</literal> does not take <literal>ints</literal> as its parameters.
It takes pointers to <literal>int</literal>  (<literal>int*</literal>)'s.
In the body of <literal>Swap()</literal> the parameters, <literal>a</literal> and <literal>b</literal>, are
dereferenced with <literal>*</literal> to get at the actual (<literal>int</literal>) values of
interest.</paragraph><literal_block xml:space="preserve">void Swap(int* a, int* b) {
  int temp;

  temp = *a;
  *a = *b;
  *b = temp;
}</literal_block></section><section ids="swap-caller" names="swap()\ caller"><title>Swap() Caller</title><paragraph>To call Swap(), the caller must pass pointers to the values of interest.</paragraph><literal_block xml:space="preserve">void SwapCaller() {
  int x = 1;
  int y = 2;

  Swap(&amp;x, &amp;y); // Use &amp; to pass pointers to the int values of interest
                //  (x and y).
}</literal_block><raw format="xml" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>The parameters to <literal>Swap()</literal> are pointers to values of interest which are back in the caller's
locals. The <literal>Swap()</literal> code can dereference the pointers to get back to the caller's memory to
exchange the values. In this case, <literal>Swap()</literal> follows the pointers to exchange the values in
the variables x and y back in <literal>SwapCaller()</literal>. <literal>Swap()</literal> will exchange any two ints given
pointers to those two ints.</paragraph></section><section ids="swap-with-arrays" names="swap()\ with\ arrays"><title>Swap() With Arrays</title><paragraph>Just to demonstrate that the value of interest does not need to be a simple variable, here's
a call to <literal>Swap()</literal> to exchange the first and last <literal>int``s in an array. ``Swap()</literal> takes <literal>int*</literal>'s, but
the <literal>ints</literal> can be anywhere. An <literal>int</literal> inside an array is still an <literal>int</literal>.</paragraph><literal_block xml:space="preserve">void SwapCaller2() {
  int scores[10];
  scores[0] = 1;
  scores[9[ = 2;
  Swap(&amp;(scores[0]), &amp;(scores[9]));// the ints of interest do not need to be
         // simple variables -- they can be any int. The caller is responsible
         // for computing a pointer to the int.</literal_block><paragraph>The above call to <literal>Swap()</literal> can be written equivalently as
<literal>Swap(scores, scores+9)</literal> due to the array syntax in C. You can</paragraph><paragraph>ignore this case if it is not familiar to you
it's
not an important area of the language and both forms compile to the exact same thing anyway.</paragraph></section></section><section ids="more-syntax" names="more\ syntax"><title>More Syntax</title><section ids="is-the-always-necessary" names="is\ the\ &amp;\ always\ necessary?"><title>Is The &amp; Always Necessary?</title><paragraph>When passing by reference, the caller does not always need to use &amp; to compute a new
pointer to the value of interest. Sometimes the caller already has a pointer to the value of
interest, and so no new pointer computation is required. The pointer to the value of
interest can be passed through unchanged.</paragraph><paragraph>For example, suppose B() is changed so it calls a C() function which adds 2 to the value
of interest...</paragraph><literal_block xml:space="preserve">    // Takes the value of interest by reference and adds 2.
    void C(int* worthRef) {
      *worthRef = *worthRef + 2;
    }

    // Adds 1 to the value of interest, and calls C().
    void B(int* worthRef) {
      *worthRef = *worthRef + 1; // add 1 to value of interest as before

      C(worthRef);    // NOTE no &amp; required. We already have
                      // a pointer to the value of interest, so
                      // it can be passed through directly.
}</literal_block></section><section ids="what-about-the-bug-tab" names="what\ about\ the\ &amp;\ bug\ tab?"><title>What About The &amp; Bug TAB?</title><paragraph>All this use of &amp; might make you nervous  are we committing the &amp; bug from Section
2? No, it turns out the above uses of &amp; are fine. The &amp; bug happens when an &amp; passes a
pointer to local storage from the callee back to its caller. When the callee exits, its local
memory is deallocated and so the pointer no longer has a pointee. In the above, correct
cases, we use &amp; to pass a pointer from the caller to the callee. The pointer remains valid
for the callee to use because the caller locals continue to exist while the callee is running.
The pointees will remain valid due to the simple constraint that the caller can only exit
sometime after its callee exits. Using &amp; to pass a pointer to local storage from the caller
to the callee is fine. The reverse case, from the callee to the caller, is the &amp; bug.</paragraph></section><section ids="the-case" names="the\ **\ case"><title>The ** Case</title><paragraph>What if the value of interest to be shared and changed between the caller and callee is
already a pointer, such as an <literal>int*</literal> or a <literal>struct fraction*</literal>?
Does that change the rules for setting  up reference parameters? No.
In that case, there is no change in the rules.
They operate just as before. The reference parameter is still a pointer to the value of
interest, even if the value of interest is itself a pointer. Suppose the value of interest is
<literal>int*</literal>. This means there is an <literal>int*</literal> value which the caller and callee want to share and change. Then the reference parameter should be an
<literal>int**</literal>. For a <literal>struct fraction*</literal>  value of interest, the reference parameter is <literal>struct fraction**</literal>.
A single dereference (<literal>*</literal>) operation on the reference parameter yields the value of interest as it did in the simple cases. Double pointer (<literal>**</literal>) parameters are common in linked list or
other pointer manipulating code were the value of interest to share and change is itself a pointer, such as a linked list head pointer.</paragraph></section></section><section ids="reference-parameter-summary" names="reference\ parameter\ summary"><title>Reference Parameter Summary</title><paragraph>Passing by value (copying) does not allow the callee to communicate back to its caller
and has also has the usual disadvantages of making copies. Pass by reference uses
pointers to avoid copying the value of interest, and allow the callee to communicate back
to the caller.</paragraph><paragraph>For pass by reference, there is only one copy of the value of interest, and pointers to that
one copy are passed. So if the value of interest is an int, its reference parameter is an <literal>int*</literal>.
If the value of interest is a <title_reference>struct fraction*</title_reference>, its reference parameters is a <literal>struct fraction**</literal>.
Functions use the dereference operator (<literal>*</literal>) on the reference parameter to see or change the
value of interest.</paragraph></section><section ids="reference-parameters-in-java" names="reference\ parameters\ in\ java"><title>Reference Parameters in Java</title><paragraph>Because Java has no <literal>*</literal>/<literal>&amp;</literal> operators, it is not possible to implement reference parameters
in Java directly. Maybe this is ok  in the OOP paradigm, you should change objects by
sending them messages which makes the reference parameter concept unnecessary. The caller passes the callee a (shallow) reference to the value of interest (object of interest?),
and the callee can send it a message to change it. Since all objects are intrinsically
shallow, any change is communicated back to the caller automatically since the object of
interest was never copied.</paragraph></section><section ids="reference-parameters-in-c" names="reference\ parameters\ in\ c++"><title>Reference Parameters in C++</title><paragraph>Reference parameters are such a common programming task that they have been added as
an official feature to the C++ language. So programming reference parameters in C++ is
simpler than in C. All the programmer needs to do is syntactically indicate that they wish
for a particular parameter to be passed by reference, and the compiler takes care of it. The
syntax is to append a single <literal>&amp;</literal> to right hand side of the parameter type. So an  <literal>int</literal>
parameter passes an integer by value, but an <title_reference>int&amp;</title_reference> parameter passes an integer value by
reference. The key is that the compiler takes care of it. In the source code, there's no
additional fiddling around with <literal>&amp;</literal>'s or <literal>*</literal>'s. So <literal>Swap()</literal> and <literal>SwapCaller()</literal> written with C++
look simpler than in C, even though they accomplish the same thing..</paragraph><literal_block xml:space="preserve">void Swap(int&amp; a, int&amp; b) {
  // The &amp; declares pass by reference
  int temp;
  temp = a;
  // No *'s required -- the compiler takes care of it
  a = b;
  b = temp;
}

void SwapCaller() {
  int x = 1;
  int y = 2;
  Swap(x, y);
  // No &amp;'s required -- the compiler takes care of it
}</literal_block><paragraph>The types of the various variables and parameters operate simply as they are declared
(<literal>int</literal> in this case). The complicating layer of pointers required to implement the
reference parameters is hidden. The compiler takes care of it without allowing the
complication to disturb the types in the source code.</paragraph></section></document>