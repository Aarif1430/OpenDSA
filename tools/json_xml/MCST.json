{"document": {"@dupnames": "minimal\\ cost\\ spanning\\ trees", "@ids": "minimal-cost-spanning-trees", "@source": "<string>", "@title": "Minimal Cost Spanning Trees", "title": "Minimal Cost Spanning Trees", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@dupnames": "minimal\\ cost\\ spanning\\ trees", "@ids": "id1", "title": "Minimal Cost Spanning Trees", "paragraph": [{"title_reference": "minimal-cost spanning tree", "math": ["\\mathbf{G}", "\\mathbf{G}", "\\mathbf{G}"], "#text": "The  (MCST)\nproblem takes as input a connected, undirected graph\n, where each edge has a distance or weight measure\nattached.\nThe MCST is the graph containing the vertices of \nalong with the subset of  's edges that\n(1) has minimum total cost as measured by summing the values for all\nof the edges in the subset, and\n(2) keeps the vertices connected.\nApplications where a solution to this problem is\nuseful include soldering the shortest set of wires needed to connect a\nset of terminals on a circuit board, and connecting a set of cities by\ntelephone lines in such a way as to require the least amount of cable."}, {"math": "|\\mathbf{V}| - 1", "title_reference": "Figure #MCSTdgm", "#text": "The MCST contains no cycles.\nIf a proposed MCST did have a cycle, a cheaper MCST could be\nhad by removing any one of the edges in the cycle.\nThus, the MCST is a free tree with  edges.\nThe name \"minimum-cost spanning tree\" comes from the fact that the\nrequired set of edges forms a tree, it spans the vertices (i.e., it\nconnects them together), and it has minimum cost.\nFigure  shows the MCST for an example graph."}], "target": {"@refid": "mcstdgm"}, "raw": [{"@format": "xml", "@ids": "mcstdgm", "@names": "mcstdgm", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "MCSTCON", "@long_name": "MCSTCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}]}, {"@ids": "prim-s-algorithm", "@names": "prim's\\ algorithm", "title": "Prim's Algorithm", "paragraph": [{"title_reference": "Prim's algorithm", "math": ["N", "N", "N", "N", "M", "M", "(N, M)", "N", "M"], "#text": "The first of our two algorithms for finding MCSTs is commonly\nreferred to as .\nPrim's algorithm is very simple.\nStart with any Vertex  in the graph, setting the MCST\nto be  initially.\nPick the least-cost edge connected to .\nThis edge connects  to another vertex; call this .\nAdd Vertex  and Edge  to the MCST.\nNext, pick the least-cost edge coming from either  or\n to any other vertex in the graph.\nAdd this edge and the new vertex it reaches to the MCST.\nThis process continues, at each step expanding the MCST by selecting\nthe least-cost edge from a vertex currently in the MCST to a vertex\nnot currently in the MCST."}, "Prim's algorithm is quite similar to Dijkstra's algorithm for finding\nthe single-source shortest\npaths.\nThe primary difference is that we are seeking not the next closest\nvertex to the start vertex, but rather the next closest vertex to any\nvertex currently in the MCST.\nThus we replace the lines:", "in Djikstra's algorithm with the lines:", "in Prim's algorithm.", "The following code shows an implementation for Prim's algorithm\nthat searches the distance matrix for the next closest vertex.", {"math": ["I", "I", "I", "I"], "literal": ["V[I]", "AddEdgetoMST"], "title_reference": "I", "#text": "For each vertex , when  is processed by Prim's\nalgorithm, an edge going to  is added to the MCST that we are\nbuilding.\nArray  stores the previously visited vertex that is\nclosest to Vertex .\nThis information lets us know which edge goes into the MCST when\nVertex  is processed.\nThe implementation above also contains calls to\n to indicate which edges are actually added to the\nMCST."}], "literal_block": [{"@xml:space": "preserve", "#text": "if (D[w] > (D[v] + G.weight(v, w)))\n  D[w] = D[v] + G.weight(v, w);"}, {"@xml:space": "preserve", "#text": "if (D[w] > G.weight(v, w))\n  D[w] = G.weight(v, w);"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "PrimAV", "@long_name": "PrimAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}], "section": {"@ids": "prim-s-algorithm-alternative-implementation", "@names": "prim's\\ algorithm\\ alternative\\ implementation", "title": "Prim's Algorithm Alternative Implementation", "paragraph": [{"title_reference": ["priority queue", "heap"], "literal": "DijkElem", "#text": "Alternatively, we can implement Prim's algorithm using a\n to find the next closest vertex, as\nshown next.\nAs with the priority queue version of Dijkstra's algorithm,\nthe  stores  objects."}, "Here is an AV that lets you try Prim's algorithm on other graphs.", {"literal": ["for", "for"], "#text": "Prim's algorithm is an example of a greedy\nalgorithm.\nAt each step in the  loop, we select the least-cost edge that\nconnects some marked vertex to some unmarked vertex.\nThe algorithm does not otherwise check that the MCST really should\ninclude this least-cost edge.\nThis leads to an important question:\nDoes Prim's algorithm work correctly?\nClearly it generates a spanning tree (because each pass through the\n loop adds one edge and one unmarked vertex to the spanning tree\nuntil all vertices have been added), but does this tree have minimum\ncost?"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "PrimAVPQ", "@long_name": "PrimAVPQ", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@ids": "primproof", "@names": "primproof", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "PrimAVPE", "@long_name": "PrimAVPE", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Graph/MCSTCON.js"}], "block_quote": {"paragraph": [{"strong": "Theorem:", "#text": "Prim's algorithm produces a minimum-cost spanning tree."}, {"strong": "Proof:", "math": ["\\mathbf{G} = (\\mathbf{V}, \\mathbf{E})", "v_0, v_1, ..., v_{n-1}", "e_i", "(v_x, v_i)", "x < i", "i \\leq 1", "e_j", "\\mathbf{G}", "e_j", "\\mathbf{T}", "\\v_p (p<j)", "e_j", "e_j = (v_p, v_j)"], "emphasis": ["not", "cannot"], "#text": "We will use a proof by contradiction.\nLet  be a graph for which\nPrim's algorithm does  generate an MCST.\nDefine an ordering on the vertices according to the order in which\nthey were added by Prim's algorithm to the MCST:\n.\nLet edge  connect  for\nsome  and .\nLet  be the lowest numbered (first) edge added\nby Prim's algorithm such that the set of edges selected so\nfar  be extended to form an MCST for .\nIn other words,  is the first edge where Prim's algorithm\n\"went wrong.\"\nLet  be the \"true\" MCST.\nCall  the vertex connected by edge\n, that is, ."}, {"math": ["\\mathbf{T}", "\\mathbf{T}", "v_p", "v_j", "e'", "v_u", "v_w", "u < j", "w \\geq j", "e_j", "\\mathbf{T}", "e_j", "\\mathbf{T}", "e'", "e_j", "e'", "e_j"], "title_reference": "Figure #PrimProof", "#text": "Because  is a tree, there exists some path in\n connecting  and .\nThere must be some edge  in this path connecting vertices\n and , with  and .\nBecause  is not part of , adding edge\n to  forms a cycle.\nEdge  must be of lower cost than\nedge , because Prim's algorithm did not generate an MCST.\nThis situation is illustrated in Figure .\nHowever, Prim's algorithm would have selected the least-cost edge\navailable.\nIt would have selected , not .\nThus, it is a contradiction that Prim's algorithm would have selected\nthe wrong edge, and thus, Prim's algorithm must be correct. BOX HERE"}]}, "target": {"@refid": "primproof"}}}]}}