{"document": {"@dupnames": "0/1\\ knapsack\\ problem", "@ids": "knapsack-problem", "@source": "<string>", "@title": "0/1 Knapsack Problem", "title": "0/1 Knapsack Problem", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@dupnames": "0/1\\ knapsack\\ problem", "@ids": "id1", "title": "0/1 Knapsack Problem", "paragraph": ["The 0/1 Knapsack problem can be defined in terms of a thief who enters the\nplace they will rob with a single knapsack to carry away their spoils. This\nknapsack has a specified limit on the weight it can support without tearing.\nThis weight capacity will be refered to as CAP. After cracking open a safe, the\ntheif finds that the safe contains N items, each with a specific weight and\nvalue (both are integers). The thief's goal is to maximize the total value of\nset of items they take without going over the weight limit, CAP. The \"0/1\"\nbinary qualifier in the name of this problem denotes that each item must be\nentirely accepted or rejected, that is, the theif can't subdivide an item.", "The first step in solving this problem is to formulate a recurcive solution,\nthen see if the solution can be made more efficent using dynamic programming.\nTo provide some insight into the problem, the following notation will be used", {"emphasis": ["i", "c", "i", "N", "c", "CAP", "i", "N", "c", "CAP", "i", "c"], "#text": "The key to solving this algorithm will be to define V(, ) recursively for all\n <= ,  <= . Note that when  =  and  =   in V(, ), the problem has been\nsolved."}, {"emphasis": ["i", "c", "i", "c", "i", "c"], "#text": "To create a solution for this problem, it would be best to start simple.\nConsider the how V(, ) can be defined when  = 1. In this case, we are asking\nfor the total value of an optimal solution when only the first item is involved\nand the knapsack has a capacity of . A definition of V(, ) is:"}, {"emphasis": ["i", "c", "i", "c", "c", "i"], "#text": "Another simple case to consider would be if  = 0 or  = 0. If  = 0,\nthere are no items to consider so V(0, ) = 0. If  = 0, the knapsack\ncan not hold anything else, so V( ,0) = 0."}, {"emphasis": ["i", "c", "i"], "#text": "Next consider how to define V(, ) in terms of small parameter values when\n > 1. A good way to break this down is as follows:"}, "Using the definitions given above, An implementation of this algorithm in a java\nlike language would look something like this:", {"emphasis": ["i", "c", "N", "N"], "#text": "The efficency of this recusive approach would not be very good. Most call to this\nalgorithm would result in 2 additional recursive calls until a base case is\nencountered. To demonstrate this, click the show button below to view a\nvisualization of the call tree this algorithm would produce working on a set of\nthree items. Every node in the tree represents a call to V(, ).It should\nbe very apparent from the tree that the algorithm is of exponential efficency,\nO(2 ^ ), where  is the number of items."}, "Now, consider what makes a problem suited to dynamic programing.", {"emphasis": ["i", "c"], "#text": "The recursive solution to the 0/1 Knapsack problem definatly meets all three\nof the criterion above. The call tree visualization above clearly shows that\nlarge amounts of work is being repeated. The value returned by our V(, )\nare simple integers,that could easily be stored in a two dimensional array.\nThe following visualization shows how dynamic programming could be used to\ngreatly increase the efficency of the original recursive algorithm."}, {"emphasis": ["is not", "is"], "#text": "One important thing to notice is, although this algorithm finds the optimal value,\nit does not find the item set that produced the value. To answer the 0/1\nKnapsack problem, some additional work is required. Recall that the larger\nof the two values, A or B, shows what action is taken on a particular item.\nIf A was larger or equal, the item  in the solution set. If B was larger\nthe item  part of the solution. In the visualization below, the optimal\nsolution set is recovered from a complete table of optimal values for the\nset of items."}, {"emphasis": ["i", "c", "i", "c", "i"], "#text": "But how would a complete table of values be easily obtained? Recall that the two\nfunction calls are V(-1, ) and V(-1, -WT()). As it turns out,\neach row in the table only depends on the row above it. With this fact known,\nit is simple to see that the table can be filled in with an iterative approach.\nThe code below shows how the table could be generated in a java like language."}, {"emphasis": ["N", "CAP", "N"], "#text": "The algorithm above creates the full table and returns the value of a particular\noptimal solution. A small bit of code could be added to the end of the algorithm\nto obtain the item set of the solution with little trouble. As an exercise,\ntry modifing the function above to obtain and return the optimal solution set,\nand implement it in you language of choice. The efficency of the algorithm\nabove is O( * ), because each cell in the table requires constant\nwork to fill. This is a huge improvement over the orignal efficency of\nO(2 ^ )."}, "A series of exercises are provided to help you test your knowlege of the\n0/1 Knapsack algorithm. Some of the exercises are easier if you have some\nscratch paper to work on."], "table": {"tgroup": {"@cols": "2", "colspec": [{"@colwidth": "10"}, {"@colwidth": "38"}], "thead": {"row": {"entry": [{"paragraph": "Symbol"}, {"paragraph": "Definition"}]}}, "tbody": {"row": [{"entry": [{"paragraph": "N"}, {"paragraph": "is the number of items in the safe"}]}, {"entry": [{"paragraph": "CAP"}, {"paragraph": "is the weight capacity of the knapsack"}]}, {"entry": [{"paragraph": "WT(i)"}, {"paragraph": "is the weight of the ith item"}]}, {"entry": [{"paragraph": "VALUE(i)"}, {"paragraph": "is the value of the ith item"}]}, {"entry": [{"paragraph": "V(i,c)"}, {"paragraph": "i<=n c<=cap denotes the total value of\nthe optimal solution to a version of\nthe problem in which c is the capacity\nof the knapsack and only items\n1, 2, 3, ... , i are considered."}]}]}}}, "line_block": {"line": [{"emphasis": ["c", "i", "i", "c"], "strong": "IF", "#text": "V(1, ) = VALUE()  WT() <="}, {"emphasis": "c", "#text": "V(1, ) = 0 otherwise since the knapsack cannot accommodate the items weight"}]}, "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"emphasis": ["i", "i", "c", "i", "c", "i"], "#text": "If WT() > c then V(, ) must be the same as V(-1, )\nsince the knapsack is capacity is not large enough to contain the item"}}, {"paragraph": {"emphasis": "i", "#text": "Otherwise to determine whether of not the solution contains item , we must compare:"}, "enumerated_list": {"@enumtype": "loweralpha", "@prefix": "", "@suffix": ")", "list_item": [{"paragraph": {"emphasis": ["c", "i", "i", "c"], "#text": "A) The optimal solution to the capaciy  version when only items 1,2,3 ... -1 are used, that is, V(-1, ))"}}, {"paragraph": [{"emphasis": ["i", "c", "i", "i"], "#text": "B) The optimal solution to V(-1, -WT()) + VALUE()."}, {"emphasis": ["i", "i", "i", "c", "i", "i", "i", "i", "c", "i", "i", "ith"], "#text": "Why is this true? If an item  is included in the knapsack, the remaining capacity\nof the knapsack drops by WT(). So V(-1, -WT()) represents\nthe best vale that can be obtained from the remaining items with this new capacity.\nSince we are including item  in the knapsack, VALUE() is added.\nhence V(-1, -WT()) + VALUE() represents the optimal value if\nthe  item is taken."}, {"emphasis": ["c", "i"], "strong": "dont include the item in the\nknapsack", "#text": "Whichever is the larger of (A) and (B) above represents the solution\nto the capacity  problem for items chosen from among 1, 2, 3, ..., .\nIf (A) is larger, the item should not be included in the knapsack. If\n(B) is larger, the item should be included in the knapsack. If the numbers\nare equal it does not matter if the item is included or not. For the rest of the\ndiscusion on this page, if (A) and (B) are equal, . In the equal case it does not matter if the item is taken or left, so to\nremain consistent it will always be left out of the solution set."}]}]}}]}, "literal_block": [{"@xml:space": "preserve", "#text": "//this function behaves like the V(i,c) method defined previously\n//in this chapter\nint V(int i, int c){\n    //base cases\n    if(i == 0 || c == 0){\n        return 0;\n    }\n    //item does not fit case\n    if(wt(i) > c){\n        return V(i-1, c);\n    }\n    //compare best case if item i is taken or left behind.\n    //and return the larger number.\n    int B = V(i-1, c-wt(i)) + value(i);\n    int A = V(i-1, c);\n    if(A >= B){\n        return A;\n    }\n    else{\n        return B;\n    }\n}"}, {"@xml:space": "preserve", "#text": "int v(int n, int cap)\n{\n    int table[][] = new int[n+1][cap+1];\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= cap; j++){\n            //base case\n            if(i == 0 || j == 0)\n                table[i][j] = 0;\n            else{\n                //item wont fit case\n                if(wt(i) > j)\n                    table[i][j] = table[i-1][j];\n                else{\n                    int A,B;\n                    B = table[i-1][j-wt(i)] + value(i);\n                    A = table[i-1][j];\n                    if(A >= B)\n                        table[i][j] = A;\n                    else\n                        table[i][j] = B;\n                }\n            }\n        }\n    }\n    //some code could go here to recover the solution set.\n\n    //return the optimal value\n    return table[i][j];\n}"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "sackCallTree", "@long_name": "sackCallTree", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "sackTreePluck", "@long_name": "sackTreePluck", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "sackTraceBack", "@long_name": "sackTraceBack", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}], "bullet_list": {"@bullet": "-", "list_item": [{"paragraph": "The problems solution is initially formulated in a recursive fashion."}, {"paragraph": "The recursion involved in the solution typically results in making multiple\nrecursive calls using the same values for parameters to the function. That is,\nto solve the original problem, it is necessary to have the solution to particular\nsmaller versions of the problem computed many times. This is the key of nearly\nall problems to which dynamic programming can be applied."}, {"paragraph": "the value returned by the recursive function is of a type that can be stored\nin a data structure capable of being indexed by critical parameters of the\nfunction. This data structure can be used to stor previously computed\ninstances of the solution to the problem, thereby replacing recursive\nrecomputation with fast O(1) recall of previously computed values."}]}}, {"@ids": "exercise-1", "@names": "exercise\\ 1", "title": "Exercise 1", "paragraph": "In the exercise below, you are provided a row of the table from the previous\nalgorithm. Determine if the item with weigh and value given on the left should\nbe taken as part of the optimal solution.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "knapsackSelect", "@long_name": "knapsackSelect", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "exercise-2", "@names": "exercise\\ 2", "title": "Exercise 2", "paragraph": "This next exercise has you fill in an entire row of the table. Enter the answer\nas a list of integers sparated by spaces or commas. Clicking a cell in the table\nwill hilight the cell, alowing you to keep your place as you progress", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "knapsackFillRow", "@long_name": "knapsackFillRow", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "exercise-3", "@names": "exercise\\ 3", "title": "Exercise 3", "paragraph": "In this exercise you must determine the correct set of items to produce the\noptimal solution. To select an item, click on the item's column in the item table\non the left. You can also select cells in the main table like you could in the\nprevious exercise.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "knapsackSolution", "@long_name": "knapsackSolution", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "exercise-4", "@names": "exercise\\ 4", "title": "Exercise 4", "paragraph": "For a final proficency exercise, you will be required to select values from the\n\"choices\" list and put them into the correct location in the table. You must\nfollow the order that the recursive algorithm would use to enter fill in cells,\nor your grade will not increase. You can check your grade at any time by clicking\non the grade button. If you make a mistake, the undo button can be used as much\nas you like. A new set of data can be generated by clicking the reset button.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "sackProficiency", "@long_name": "sackProficiency", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}}]}}