{"document": {"@ids": "other-memory-allocation-methods", "@names": "other\\ memory\\ allocation\\ methods", "@source": "<string>", "@title": "Other Memory Allocation Methods", "title": "Other Memory Allocation Methods", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@ids": "buddy-methods", "@names": "buddy\\ methods", "title": "Buddy Methods", "paragraph": [{"title_reference": ["Theta(n)", "n"], "#text": "Sequential-fit methods rely on a linked list of free blocks, which\nmust be searched for a suitable block at each memory request.\nThus, the time to find a suitable free block would be\n in the worst case for a freelist containing\n blocks.\nMerging adjacent free blocks is somewhat complicated.\nFinally, we must either use additional space for the linked list, or\nuse space within the memory pool to support the memory manager\noperations.\nIn the second option,\nboth free and reserved blocks require tag and size fields.\nFields in free blocks do not cost any space (because they are stored\nin memory that is not otherwise being used), but fields in reserved\nblocks create additional overhead."}, {"title_reference": ["2^N", "N", "2^k", "k < N", "N", "N"], "#text": "The buddy system solves most of these problems.\nSearching for a block of the proper size is efficient,\nmerging adjacent free blocks is simple,\nand no tag or other information fields need be stored within reserved\nblocks.\nThe buddy system assumes that memory is of size  for some\ninteger .\nBoth free and reserved blocks will always be of size  for\n.\nAt any given time, there might be both free and reserved blocks of\nvarious sizes.\nThe buddy system keeps a separate list for free blocks of each size.\nThere can be at most  such lists, because there can only be\n distinct block sizes.\n</p>"}, {"title_reference": ["m", "k", "2^k > m", "2^k", "2^k"], "#text": "<p>\nWhen a request comes in for  words, we first determine the\nsmallest value of  such that .\nA block of size  is selected from the free list for\nthat block size if one exists.\nThe buddy system does not worry about internal fragmentation:\nThe entire block of size  is allocated."}, {"title_reference": ["2^k", "2^k"], "#text": "If no block of size  exists,\nthe next larger block is located.\nThis block is split in half (repeatedly if necessary) until the\ndesired block of size  is created.\nAny other blocks generated as a by-product of this splitting process\nare placed on the appropriate freelists."}, "The disadvantage of the buddy system is that it allows internal\nfragmentation.\nFor example, a request for 257 words will require a block of size 512.\nThe primary advantages of the buddy system are:", {"title_reference": ["buddy", "2^k", "k"], "#text": "The reason why this method is called the buddy system is because\nof the way that merging takes place.\nThe  for any block of size  is another\nblock of the same size, and with the same address\n(i.e., the byte position in memory, read as a binary value)\nexcept that the  th bit is reversed.\nFor example, the block of size 8 with beginning address 0000\nin the figure below, has buddy with address 1000.\nLikewise the block of size 4 with\naddress 0000 has buddy 0100.\nIf free blocks are sorted by address value, the buddy can be found by\nsearching the correct block size list.\nMerging simply requires that the address for the combined buddies be\nmoved to the freelist for the next larger\nblock size."}], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "There is less external fragmentation."}, {"paragraph": {"title_reference": "2^k", "#text": "Search for a block of the right size is\ncheaper than, say, best fit because we need only find the first\navailable block on the block list for blocks of size ."}}, {"paragraph": "Merging adjacent free blocks is easy."}]}, "raw": {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, "comment": [{"@xml:space": "preserve", "#text": ".. raw:: html"}, {"@xml:space": "preserve", "#text": "<center>"}, {"@xml:space": "preserve", "#text": "<iframe id=\"FirstFit_iframe\""}, {"@xml:space": "preserve", "#text": "src=\"http://research.cs.vt.edu/AVresearch/MMtutorial/buddy.html\""}, {"@xml:space": "preserve", "#text": "width=\"1000\" height=\"600\""}, {"@xml:space": "preserve", "#text": "frameborder=\"1\" marginwidth=\"0\" marginheight=\"0\""}, {"@xml:space": "preserve", "#text": "scrolling=\"no\">"}, {"@xml:space": "preserve", "#text": "</iframe>"}, {"@xml:space": "preserve", "#text": "</center>"}]}, {"@ids": "other-methods", "@names": "other\\ methods", "title": "Other Methods", "paragraph": [{"title_reference": "zones <zone>", "#text": "In addition to sequential-fit and buddy methods, there are many\nad hoc approaches to memory management.\nIf the application is sufficiently complex, it might be\ndesirable to break available memory into several memory\n, each with a different memory management scheme.\nFor example, some zones might have a simple memory access pattern of\nfirst-in, first-out.\nThis zone can therefore be managed efficiently by using a simple\nstack.\nAnother zone might allocate only records of fixed size, and so can be\nmanaged with a simple freelist.\nOther zones might need one of the general-purpose memory allocation\nmethods discussed in this section.\nThe advantage of zones is that some portions of memory can be managed\nmore efficiently.\nThe disadvantage is that one zone might fill up while other zones have\nexcess memory if the zone sizes are chosen poorly."}, "Another approach to memory management is to impose a standard size on\nall memory requests.\nWe have seen an example of this concept already in disk file\nmanagement, where all files are allocated in multiples of the\ncluster size.\nThis approach leads to internal fragmentation,\nbut managing files composed of clusters is easier than managing\narbitrarily sized files.\nThe cluster scheme also allows us to relax the restriction that the\nmemory request be serviced by a contiguous block of memory.\nMost disk file managers and\noperating system main memory managers\nwork on a cluster or page system.\nBlock management is usually done with a buffer pool\nto allocate available blocks in main memory efficiently."]}]}}