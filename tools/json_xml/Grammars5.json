{"document": {"@ids": "grammars-part-5", "@names": "grammars\\ -\\ part\\ 5", "@source": "<string>", "@title": "Grammars - Part 5", "title": "Grammars - Part 5", "subtitle": {"@ids": "rp-5-part-1", "@names": "rp\\ 5\\ part\\ 1", "#text": "RP 5 part 1"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}, {"@xml:space": "preserve", "#text": "(W 2/10/16)"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP5part1", "@long_name": "RP5part1", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "paragraph": ["This is a very short module in which we give an overview of how to add\nannotations to a Jison grammar to produce an interpreter, rather than\njust a parser.  By an interpreter we mean that, instead of merely\nreturning a signal indicating whether or not the parsed expression is\nvalid or not, we actually want to \"evaluate\" valid expressions in some\nway and return the result of doing that evaluation.", {"reference": {"@refuri": "http://zaa.ch/jison/demos/calc", "#text": "http://zaa.ch/jison/demos/calc"}, "#text": "Consider the following Jison grammar, which is a scaled-down version\nof the demo at , as made available by\nJison developer Zach Carter:"}, {"reference": {"@refuri": "http://zaa.ch/jison/try", "#text": "http://zaa.ch/jison/try"}, "math": "6.4 - 3.2 * (42.6/13)", "emphasis": "Parse", "#text": "This grammar produces a parser/interpreter that evaluates simple arithmetic expressions.  To try it, merely cut-and-paste it into the online version of Jison at .  Let Jison produce the parser/interpreter for you, and then see what happens when you type in expressions like  and click Jison's  button.  When you give this grammar to Jison, you get back an interpreter that is a simple calculator."}, "What are new features of Jison that are introduced by the annotations in this grammar?   First consider the lexical specification given by the line:", {"emphasis": "regular expression", "math": ["+", "?"], "#text": "This specification is officially called a , but we are already familiar with the symbols it uses from our discussion of EBNF.   Remember that  in EBNF means one-or-more,  means zero-or-one, and parentheses are used for grouping.   Hence the above regular expression says that a number is \"one or more digits followed optionally by a group consisting of a decimal point and one or more digits\"."}, "Next consider the annotation in the following portion of the grammar:", {"strong": ["$1", "$3", "exp", "$$", "{ $$ = $1 + $3; }", "exp", "term", "program", "{ return $1; }", "$1", "exp", "program"], "#text": "Here the notations  and  refer to what the parser/interpreter returns from evaluating the first and third non-terminals on the right of one of the  productions.   The  notation is what the parser/interpreter recursively returns to the previous level of the parse.   So  indicates the interpreter should add what was returned from parsing an  (the first non-terminal) and a  (the third non-terminal) and consequently return that sum to the prior level of recursion in the parse.   At the top-level associated with the  non-terminal, the notation  indicates that, when end-of-input is found, the parser/interpreter should return , that is, whatever it received from the parse of the  on the right side of the  production."}, "The review problem set for this module consists of just one problem,\nwhich will help you understand how annotated Jison grammars can be\nused to generate interpreters."], "literal_block": [{"@xml:space": "preserve", "#text": "/*\n    description: Parse and interpret simple arithmetic expressions\n                 and evaluates them\n    source:      this grammar is adapted from:\n                 http://zaach.github.io/jison/demos/calc/\n*/\n\n// lexical section of the grammar\n// ==============================\n\n%lex\n%%\n\\s+                   /* no return statement, so skip whitespace */\n[0-9]+(\".\"[0-9]+)?    return \"NUMBER\"\n\"*\"                   return \"TIMES\"\n\"/\"                   return \"DIV\"\n\"-\"                   return \"MINUS\"\n\"+\"                   return \"PLUS\"\n\"(\"                   return \"LPAREN\"\n\")\"                   return \"RPAREN\"\n<<EOF>>               return \"EOF\"\n.                     return \"INVALID\"\n\n/lex\n\n%start program\n\n// phrase-structure section of the grammar\n// =======================================\n\n%%\n\nprogram\n    : exp \"EOF\"\n      { return $1; }\n    ;\nexp\n    : term\n      { $$ = $1; }\n    | exp \"PLUS\" term\n      { $$ = $1 + $3; }\n    | exp \"MINUS\" term\n      { $$ = $1 - $3; }\n    ;\n\nterm\n    : factor\n      { $$ = $1; }\n    | term \"TIMES\" factor\n      { $$ = $1 * $3; }\n    | term \"DIV\" factor\n      { $$ = $1 / $3; }\n    ;\nfactor\n    :  \"NUMBER\"\n      { $$ = Number( $1 ); }\n    | \"LPAREN\" exp \"RPAREN\"\n      { $$ = $2; }\n    ;"}, {"@xml:space": "preserve", "#text": "[0-9]+(\".\"[0-9]+)?    return \"NUMBER\""}, {"@xml:space": "preserve", "#text": "program\n    : exp \"EOF\"\n      { return $1; }\n    ;\nexp\n    : term\n      { $$ = $1; }\n    | exp \"PLUS\" term\n      { $$ = $1 + $3; }\n    | exp \"MINUS\" term\n      { $$ = $1 - $3; }\n    ;"}]}}