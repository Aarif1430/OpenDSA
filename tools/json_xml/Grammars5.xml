<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="grammars-part-5" names="grammars\ -\ part\ 5" source="&lt;string&gt;" title="Grammars - Part 5"><title>Grammars - Part 5</title><subtitle ids="rp-5-part-1" names="rp\ 5\ part\ 1">RP 5 part 1</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-13 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><comment xml:space="preserve">(W 2/10/16)</comment><paragraph>This is a very short module in which we give an overview of how to add
annotations to a Jison grammar to produce an interpreter, rather than
just a parser.  By an interpreter we mean that, instead of merely
returning a signal indicating whether or not the parsed expression is
valid or not, we actually want to "evaluate" valid expressions in some
way and return the result of doing that evaluation.</paragraph><paragraph>Consider the following Jison grammar, which is a scaled-down version
of the demo at <reference refuri="http://zaa.ch/jison/demos/calc">http://zaa.ch/jison/demos/calc</reference>, as made available by
Jison developer Zach Carter:</paragraph><literal_block xml:space="preserve">/*
    description: Parse and interpret simple arithmetic expressions
                 and evaluates them
    source:      this grammar is adapted from:
                 http://zaach.github.io/jison/demos/calc/
*/

// lexical section of the grammar
// ==============================

%lex
%%
\s+                   /* no return statement, so skip whitespace */
[0-9]+("."[0-9]+)?    return "NUMBER"
"*"                   return "TIMES"
"/"                   return "DIV"
"-"                   return "MINUS"
"+"                   return "PLUS"
"("                   return "LPAREN"
")"                   return "RPAREN"
&lt;&lt;EOF&gt;&gt;               return "EOF"
.                     return "INVALID"

/lex

%start program

// phrase-structure section of the grammar
// =======================================

%%

program
    : exp "EOF"
      { return $1; }
    ;
exp
    : term
      { $$ = $1; }
    | exp "PLUS" term
      { $$ = $1 + $3; }
    | exp "MINUS" term
      { $$ = $1 - $3; }
    ;

term
    : factor
      { $$ = $1; }
    | term "TIMES" factor
      { $$ = $1 * $3; }
    | term "DIV" factor
      { $$ = $1 / $3; }
    ;
factor
    :  "NUMBER"
      { $$ = Number( $1 ); }
    | "LPAREN" exp "RPAREN"
      { $$ = $2; }
    ;</literal_block><paragraph>This grammar produces a parser/interpreter that evaluates simple arithmetic expressions.  To try it, merely cut-and-paste it into the online version of Jison at <reference refuri="http://zaa.ch/jison/try">http://zaa.ch/jison/try</reference>.  Let Jison produce the parser/interpreter for you, and then see what happens when you type in expressions like <title_reference>6.4 - 3.2 * (42.6/13)</title_reference> and click Jison's <emphasis>Parse</emphasis> button.  When you give this grammar to Jison, you get back an interpreter that is a simple calculator.</paragraph><paragraph>What are new features of Jison that are introduced by the annotations in this grammar?   First consider the lexical specification given by the line:</paragraph><literal_block xml:space="preserve">[0-9]+("."[0-9]+)?    return "NUMBER"</literal_block><paragraph>This specification is officially called a <emphasis>regular expression</emphasis>, but we are already familiar with the symbols it uses from our discussion of EBNF.   Remember that <title_reference>+</title_reference> in EBNF means one-or-more, <title_reference>?</title_reference> means zero-or-one, and parentheses are used for grouping.   Hence the above regular expression says that a number is "one or more digits followed optionally by a group consisting of a decimal point and one or more digits".</paragraph><paragraph>Next consider the annotation in the following portion of the grammar:</paragraph><literal_block xml:space="preserve">program
    : exp "EOF"
      { return $1; }
    ;
exp
    : term
      { $$ = $1; }
    | exp "PLUS" term
      { $$ = $1 + $3; }
    | exp "MINUS" term
      { $$ = $1 - $3; }
    ;</literal_block><paragraph>Here the notations <strong>$1</strong> and <strong>$3</strong> refer to what the parser/interpreter returns from evaluating the first and third non-terminals on the right of one of the <strong>exp</strong> productions.   The <strong>$$</strong> notation is what the parser/interpreter recursively returns to the previous level of the parse.   So <strong>{ $$ = $1 + $3; }</strong> indicates the interpreter should add what was returned from parsing an <strong>exp</strong> (the first non-terminal) and a <strong>term</strong> (the third non-terminal) and consequently return that sum to the prior level of recursion in the parse.   At the top-level associated with the <strong>program</strong> non-terminal, the notation <strong>{ return $1; }</strong> indicates that, when end-of-input is found, the parser/interpreter should return <strong>$1</strong>, that is, whatever it received from the parse of the <strong>exp</strong> on the right side of the <strong>program</strong> production.</paragraph><paragraph>The review problem set for this module consists of just one problem,
which will help you understand how annotated Jison grammars can be
used to generate interpreters.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP5part1"
    long_name="RP5part1"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></document>