{"document": {"@dupnames": "sequential\\ tree\\ representations", "@ids": "sequential-tree-representations", "@source": "<string>", "@title": "Sequential Tree Representations", "title": "Sequential Tree Representations", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Binary/BinExampCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/General/SequentialTreeCON.css"}], "section": [{"@dupnames": "sequential\\ tree\\ representations", "@ids": "id1", "title": "Sequential Tree Representations", "paragraph": [{"title_reference": "sequential tree representation", "math": "\\Theta(\\log n)", "#text": "Next we consider a fundamentally different approach to implementing\ntrees.\nThe goal is to store a series of node values with the minimum\ninformation needed to reconstruct the tree structure.\nThis approach, known as a , has\nthe advantage of saving space because no pointers are stored.\nIt has the disadvantage that accessing any node in the tree requires\nsequentially processing all nodes that appear before\nit in the node list.\nIn other words, node access must start at the beginning of the node\nlist, processing nodes sequentially in whatever order they are stored\nuntil the desired node is reached.\nThus, one primary virtue of the other implementations discussed in\nthis section is lost: efficient access\n(typically  time) to arbitrary nodes in the\ntree.\nSequential tree implementations are ideal for archiving trees on disk\nfor later use because they save space, and the tree structure can\nbe reconstructed as needed for later processing."}, {"title_reference": "serialize <serialization>", "#text": "Sequential tree implementations can be used to\n a tree structure.\nSerialization is the process of storing an object as a series of\nbytes, typically so that the data structure can be transmitted between\ncomputers.\nThis capability is important when using data structures in a\ndistributed processing environment."}, "A sequential tree implementation typically stores the node values as\nthey would be enumerated by a preorder\ntraversal, along with sufficient information to describe the tree's\nshape.\nIf the tree has restricted form, for example if it is a full binary\ntree, then less information about structure typically needs to be\nstored.\nA general tree, because it has the most flexible shape, tends to require\nthe most additional shape information.\nThere are many possible sequential tree implementation schemes.\nWe will begin by describing methods appropriate to binary trees,\nthen generalize to an implementation appropriate to a general tree\nstructure.", "Because every node of a binary tree is either a leaf or has two\n(possibly empty) children, we can take advantage of this fact to\nimplicitly represent the tree's structure.\nThe most straightforward sequential tree implementation lists every\nnode value as it would be enumerated by a preorder traversal.\nUnfortunately, the node values alone do not provide enough information\nto recover the shape of the tree.\nIn particular, as we read the series of node values, we do not\nknow when a leaf node has been reached.\nHowever, we can treat all non-empty nodes as internal nodes with two\n(possibly empty) children.\nOnly NULL values will be interpreted as leaf nodes, and these can be\nlisted explicitly.\nSuch an augmented node list provides enough information to recover\nthe tree structure."], "target": {"@refid": "binexampb"}, "raw": [{"@format": "xml", "@ids": "binexampb", "@names": "binexampb", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "BinExampCON", "@long_name": "BinExampCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "SequentialTreeCON", "@long_name": "SequentialTreeCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "SequentialTreePRO", "@long_name": "SequentialTreePRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "alternative-sequential-representation", "@names": "alternative\\ sequential\\ representation", "title": "Alternative Sequential Representation", "paragraph": ["To illustrate the difficulty involved in using the sequential tree\nrepresentation for processing, consider searching for the right child\nof the root node.\nWe must first move sequentially through the node list of the left\nsubtree.\nOnly at this point do we reach the value of the root's right child.\nClearly the sequential representation is space efficient, but not time\nefficient for descending through the tree along some arbitrary path.", {"literal": ["null", "null", "null"], "title_reference": "Full Binary Tree Theorem <full binary tree theorem> <BinaryTreeFullThm>", "math": ["X", "X", "X", "X", "X", "X"], "#text": "Assume that each node value takes a constant amount of space.\nAn example would be if the node value is a positive integer and\n is indicated by the value zero.\nFrom the\n,\nwe know that the size of the node list will be about twice the number\nof nodes (i.e., the overhead fraction is 1/2).\nThe extra space is required by the  pointers.\nWe should be able to store the node list more compactly.\nHowever, any sequential implementation must recognize when a leaf node\nhas been reached, that is, a leaf node indicates the end of a subtree.\nOne way to do this is to explicitly list with each node whether it is\nan internal node or a leaf.\nIf a node  is an internal node, then we know that its two\nchildren (which may be subtrees) immediately follow  in the\nnode list.\nIf  is a leaf node, then the next node in the list is the\nright child of some ancestor of , not the right child\nof .\nIn particular, the next node will be the child of  's most\nrecent ancestor that has not yet seen its right child.\nHowever, this assumes that each internal node does in fact have two\nchildren, in other words, that the tree is\nfull.\nEmpty children must be indicated in the node list explicitly.\nAssume that internal nodes are marked with a prime (') and that\nleaf nodes show no mark.\nEmpty children of internal nodes are indicated by \"/\", but the (empty)\nchildren of leaf nodes are not represented at all.\nNote that a full binary tree stores no  values with this\nimplementation, and so requires less overhead."}, {"math": ["n", "n"], "literal": "null", "#text": "Storing  extra bits can be a considerable savings over\nstoring   values.\nIn the example above, each node was shown with a\nmark if it is internal, or no mark if it is a leaf.\nThis requires that each node value has space to store the mark bit.\nThis might be true if, for example, the node value were stored as a\n4-byte integer but the range of the values sored was small enough so\nthat not all bits are used.\nAn example would be if all node values must be positive.\nThen the high-order (sign) bit of the integer value could be used as\nthe mark bit."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "SequentialTreeAltCON", "@long_name": "SequentialTreeAltCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "SequentialTreeAltPRO", "@long_name": "SequentialTreeAltPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "bit-vector-representation", "@names": "bit\\ vector\\ representation", "title": "Bit Vector Representation", "paragraph": "Another approach is to store a separate bit vector to represent the\nstatus of each node.\nIn this case, each node of the tree corresponds to one bit in the bit\nvector.\nA value of \"1\" could indicate an internal node, and \"0\" could indicate\na leaf node.", "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "SequentialTreeBitsCON", "@long_name": "SequentialTreeBitsCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "SequentialTreeBitVectorPRO", "@long_name": "SequentialTreeBitVectorPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "general-tree-sequential-representation", "@names": "general\\ tree\\ sequential\\ representation", "title": "General Tree Sequential Representation", "paragraph": ["Storing general trees by means of a sequential implementation requires\nthat more explicit structural information be included with the node\nlist.\nNot only must the general tree implementation indicate whether a node\nis leaf or internal, it must also indicate how many children the\nnode has.\nAlternatively, the implementation can indicate when a node's child\nlist has come to an end.\nThe next example dispenses with marks for internal or leaf nodes.\nInstead it includes a special mark (we will use the \")\" symbol) to\nindicate the end of a child list.\nAll leaf nodes are followed by a \")\" symbol because they have no\nchildren.\nA leaf node that is also the last child for its parent would indicate\nthis by two or more successive \")\" symbols.", {"math": ["D", "B"], "title_reference": "Figure #BinExampb", "#text": "Note that this representation for serializing general trees cannot be\nused for binary trees.\nThis is because a binary tree is not merely a restricted form of\ngeneral tree with at most two children.\nEvery binary tree node has a left and a right child, though either or\nboth might be empty.\nSo this representation cannot let us distinguish whether node\n in Figure  is the left or right\nchild of node ."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "SequentialGenTreeCON", "@long_name": "SequentialGenTreeCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "SequentialTreeGenTreePRO", "@long_name": "SequentialTreeGenTreePRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/BinExampCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/General/SequentialTreeCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/General/SequentialTreeAltCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/General/SequentialTreeBitsCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/General/SequentialGenTreeCON.js"}]}]}}