<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="chapter-introduction-search" names="chapter\ introduction:\ search" source="&lt;string&gt;" title="Chapter Introduction: Search"><title>Chapter Introduction: Search</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>Organizing and retrieving information is at the heart of most computer
applications, and searching is surely the most frequently performed
of all computing tasks.
Search can be viewed abstractly as a process to determine if
an element with a particular value is a member of a particular set.
The more common view of searching is an attempt to
find the record within a collection of records that has
a particular key value, or those records in a collection whose key
values meet some criterion such as falling within a range of
values.</paragraph><paragraph>We can define searching formally as follows.
Suppose that we have a collection <strong>L</strong> of <title_reference>n</title_reference> records of the
form</paragraph><math_block xml:space="preserve">(k_1, I_1), (k_2, I_2), ..., (k_n, I_n)</math_block><paragraph>where <title_reference>I_j</title_reference> is information associated with key <title_reference>k_j</title_reference>
from record <title_reference>j</title_reference> for <title_reference>1 leq j leq n</title_reference>.
Given a particular key value <title_reference>K</title_reference>,
the <title_reference>search problem</title_reference> is to locate a record
<title_reference>(k_j, I_j)</title_reference> in <strong>L</strong> such that <title_reference>k_j = K</title_reference>
(if one exists).
<title_reference>Searching</title_reference> is a systematic method for
locating the record (or records) with key value <title_reference>k_j = K</title_reference>.</paragraph><paragraph>A <title_reference>successful search</title_reference> is one in which a record with key
<title_reference>k_j = K</title_reference> is found.
An <title_reference>unsuccessful search</title_reference> is one in which no record with
<title_reference>k_j = K</title_reference> is found (and no such record exists).</paragraph><paragraph>An <title_reference>exact-match query</title_reference> is a search for the record whose key
value matches a specified key value.
A <title_reference>range query</title_reference> is a search for all records whose key value
falls within a specified range of key values.</paragraph><paragraph>We can categorize search algorithms into three general
approaches:</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Sequential and list methods.</paragraph></list_item><list_item><paragraph>Direct access by key value (hashing).</paragraph></list_item><list_item><paragraph>Tree indexing methods.</paragraph></list_item></enumerated_list><paragraph>Any of these approaches are potentially suitable for implementing the
<title_reference>Dictionary &lt;dictionary&gt; &lt;Dictionary&gt;</title_reference> ADT.
However, each has different performance characteristics that make it
the method of choice in particular circumstances.</paragraph><paragraph>The current chapter considers methods for searching data stored in
lists.
List in this context means any list implementation including a
linked list or an array.
Most of these methods are appropriate for sequences
(i.e., duplicate key values are allowed), although there are special
techniques applicable to <title_reference>sets &lt;set&gt; &lt;SetSearch&gt;</title_reference>.
The techniques from the first three sections of this chapter are most
appropriate for searching a collection of records stored in RAM.
Chapter <title_reference>Hashing</title_reference> introduces hashing, a technique for
organizing data in an array such that the location of each record
within the array is a function of its key value.
Hashing is appropriate when records are stored either in RAM or on
disk.</paragraph><paragraph>Chapter <title_reference>Indexing</title_reference> discusses tree-based methods for organizing
information on disk, including a commonly used file structure called
the B-tree.
Nearly all programs that must organize large collections of records
stored on disk use some variant of either hashing or the B-tree.
Hashing is practical for only certain access applications
(exact-match queries) and is generally appropriate only when duplicate
key values are not allowed.
B-trees are the method of choice for dynamic disk-based
applications anytime hashing is not appropriate.</paragraph></document>