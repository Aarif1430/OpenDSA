<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="kmp\ string\ search\ algorithm" ids="kmp-string-search-algorithm" source="&lt;string&gt;" title="KMP String Search Algorithm"><title>KMP String Search Algorithm</title><subtitle dupnames="kmp\ string\ search\ algorithm" ids="id1">KMP String Search Algorithm</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-13 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>This apparently more efficient string search algorithm was discovered
in the 1970s by D. E. Knuth, J. H. Morris, and V. R. Pratt.
Consequently, it is known as the Knuth‑Morris‑Pratt (or KMP)
algorithm.  The key to its search efficiency is the following.  When a
mismatch occurs in a particular alignment at index <math>p</math> of
<math>sub</math>, then we must look to the character matches that occurred
in the portion of <math>sub</math> preceding index <math>p</math>.  We are
seeking a substring of sub in the portion of <math>sub</math> immediately
prior to index <math>p</math> that matches a leading substring of
<math>sub</math>.  Once found, <math>sub</math> may be realigned so that this
leading substring overlays what had been the matching substring
immediately prior to index <math>p</math>. The character‑by‑character
comparison can then proceed from the position of the prior mismatch.</paragraph><paragraph>Its use requires an initial pass through the string sub to determine
the appropriate amount of realignment when a mismatch occurs at
position <math>p</math> in <math>sub</math>. Note that this determination is
dependent only on <math>sub</math>, not at all on <math>master</math>. In
effect, for each index <math>p</math>, we seek the longest sequence of
characters immediately preceding position <math>p</math> that matches a
sequence at the beginning of <math>sub</math>. We must qualify this
slightly to avoid problems in the degenerate case, in which all
characters preceding position <math>p</math> are the same.  When this
occurs, we restart the matching pass through sub at position <math>p
‑ 1</math>.  In other words, we specifically seek the maximum sequence of
characters immediately preceding index <math>p</math> with length less than
<math>p</math> such that this sequence matches a sequence at the beginning
of <math>sub</math>.  We will store, for each index <math>p</math>, the length
of such a sequence in an array called <math>align</math>.  Given this
definition of the <math>align</math> array, the following slideshow
indicates how the KMP algorithm would work with a particular
<math>master</math> and <math>sub</math> string.</paragraph><comment xml:space="preserve">Slideshow for KMP search algorithm</comment><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="KMP_Slideshow"
    long_name="KMP_Slideshow"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>The preceding slideshow has unveiled the following pseudocode
for the KMP algorithm::</paragraph><literal_block xml:space="preserve">input: master string, sub string, align array
m = 0
s = 0
while((s &lt; sub.length) and (sub.length - s &lt;= master.length - m)):
  if(master[m] == sub[s]): m++, s++
  else if(s == 0): m++
  else: s = align[s]
if(s == sub.length): return m - sub.length
else: return -1</literal_block><paragraph>See if you can predict how one step in this KMP algorithm would
progress by trying the following exercise.</paragraph><comment xml:space="preserve">Exercise in tracing one step of the KMP algorithm</comment><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="KMP_Exercise"
    long_name="KMP_Exercise"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><paragraph>The creation of the <math>align</math> is itself an interesting algorithm
and requires some explanation.  Since <math>align[p]</math> must be less
than <math>p</math>, we start by initializing <math>align[0]</math> to ‑1 and
<math>align[1]</math> to 0.  Since the align array is computed for
successive values of <math>p</math>, <math>align[p ‑ 1]</math> will have been
computed by the time we attempt to compute <math>align[p]</math>, allowing
us to iterate through the computation of the <math>align</math> array as
indicated in the following slideshow.</paragraph><comment xml:space="preserve">If the test indicated in Figure 2.17 fails, we will then seek a</comment><comment xml:space="preserve">leading substring of the shaded portion on the left of Figure 2.17</comment><comment xml:space="preserve">that matches a substring ending at position p ‑ 1.  Working within the</comment><comment xml:space="preserve">shaded portion on the left of Figure 2.17 (that is, with the</comment><comment xml:space="preserve">characters at the beginning of sub) we know that the leading align[q]</comment><comment xml:space="preserve">characters on the left of this shaded portion exactly match the</comment><comment xml:space="preserve">characters in the align[q] positions preceding q.  This follows from</comment><comment xml:space="preserve">the definition of the values already stored in the align array.  We</comment><comment xml:space="preserve">also know that the two shaded substrings in Figure 2.17 must</comment><comment xml:space="preserve">match. Combining these facts, we conclude that the first align[q]</comment><comment xml:space="preserve">characters in sub exactly match the sequence of align[q] characters</comment><comment xml:space="preserve">preceding position p ‑ 1 in Figure 2.17.  Consequently, if we reset q</comment><comment xml:space="preserve">to align[q], then align[p] will equal q + 1 provided sub.charAt(q)</comment><comment xml:space="preserve">equals sub.charAt(p – 1).  This logic is iterated until sub.charAt(q)</comment><comment xml:space="preserve">equals sub.charAt(p – 1) or until q becomes negative, as indicated in</comment><comment xml:space="preserve">Figure 2.18.</comment><comment xml:space="preserve"></comment><comment xml:space="preserve"></comment><comment xml:space="preserve"></comment><comment xml:space="preserve">Slideshow for creation of alignment array</comment><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="KMP_align_array_slideshow"
    long_name="KMP_align_array_slideshow"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>The preceding slideshow has illustrated the following pseudocode
for the computation of the <math>align</math> array in the KMP algorithm::</paragraph><literal_block xml:space="preserve">align[0] = -1
align[1] = 0
L = string.length
for(p = 2; p &lt; L; p++):
  q = align[p-1]
  while((q&gt;= 0) and (string[q] != string[p-1])):
    q = align[q]
  align[p] = q+1</literal_block><paragraph>See if you can predict how one step in this <math>align</math> algorithm would
progress by trying the following exercise.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="KMP_Alignment_Array_Exercise"
    long_name="KMP_Alignment_Array_Exercise"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><paragraph>To indicate that you have fully mastered the intricacies of the KMP
algorithm, you must now succeed in working your way through the
following three exercises:</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Proficiency Exercise in tracing entire KMP algorithm</paragraph></list_item></enumerated_list><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="KMP_EX_PRO"
    long_name="KMP_EX_PRO"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw><enumerated_list enumtype="arabic" prefix="" start="2" suffix="."><list_item><paragraph>Exercise in counting shifts and compares needed by KMP algorithm</paragraph></list_item></enumerated_list><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="KMP_Compares_Shifts_Exercise"
    long_name="KMP_Compares_Shifts_Exercise"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><enumerated_list enumtype="arabic" prefix="" start="3" suffix="."><list_item><paragraph>Exercise in determining strings with specified number of shifts and compares</paragraph></list_item></enumerated_list><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="KMP_Users_Choice"
    long_name="KMP_Users_Choice"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></document>