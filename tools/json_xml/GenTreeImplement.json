{"document": {"@ids": "general-tree-implementations", "@names": "general\\ tree\\ implementations", "@source": "<string>", "@title": "General Tree Implementations", "title": "General Tree Implementations", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "paragraph": {"title_reference": "<GenTreeIntro>", "#text": "We now tackle the problem of devising an implementation for general\ntrees that allows efficient processing for all member functions of the\nADTs of Module .\nThis section presents several approaches to implementing general\ntrees.\nEach implementation yields  advantages and disadvantages in the amount\nof space required to store a node and the relative ease with which\nkey operations can be performed.\nGeneral tree implementations should place no restriction on how many\nchildren a node may have.\nIn some applications, once a node is created the number of children\nnever changes.\nIn such cases, a fixed amount of space can be allocated for the\nnode when it is created, based on the number of children for the node.\nMatters become more complicated if children can be added to or deleted\nfrom a node, requiring that the node's space allocation be adjusted\naccordingly."}, "section": [{"@ids": "list-of-children", "@names": "list\\ of\\ children", "title": "List of Children", "paragraph": [{"title_reference": "Figure #ChildList", "#text": "Our first attempt to create a general tree implementation is called\nthe \"list of children\" implementation for general trees.\nIt simply stores with each internal node a\nlinked list of its children.\nThis is illustrated by Figure ."}, {"math": ["M", "P", "M", "P", "M", "M", "M", "M"], "#text": "The \"list of children\" implementation stores the tree nodes in an\narray.\nEach node contains a value, a pointer (or index) to its parent, and a\npointer to a linked list of the node's children, stored in order from\nleft to right.\nEach linked list element contains a pointer to one child.\nThus, the leftmost child of a node can be found directly because it is\nthe first element in the linked list.\nHowever, to find the right sibling for a node is more difficult.\nConsider the case of a node  and its parent .\nTo find  's right sibling, we must move down the child list\nof  until the linked list element storing the pointer\nto  has been found.\nGoing one step further takes us to the linked list element that stores\na pointer to  'sright sibling.\nThus, in the worst case, to find  's right sibling requires\nthat all children of  's parent be searched."}, {"math": ["\\mathbf{T}", "R", "\\mathbf{T}", "R"], "#text": "Combining trees using this representation is difficult if each tree\nis stored in a separate node array.\nIf the nodes of both trees are stored in a single node array, then\nadding tree  as a subtree of node  is done\nby simply adding the root of  to  's list\nof children."}], "target": {"@refid": "childlist"}, "raw": {"@format": "xml", "@ids": "childlist", "@names": "childlist", "@xml:space": "preserve", "odsafig": "null"}}, {"@ids": "the-left-child-right-sibling-implementation", "@names": "the\\ left-child/right-sibling\\ implementation", "title": "The Left-Child/Right-Sibling Implementation", "paragraph": {"title_reference": ["Figure #Explicit", "Figure #AddExplicit"], "#text": "With the \"list of children\" implementation, it is difficult to\naccess a node's right sibling.\nFigure  presents an improvement.\nHere, each node stores its value and pointers to its parent, leftmost\nchild, and right sibling.\nThus, each of the basic ADT operations can be implemented by reading a\nvalue directly from the node.\nIf two trees are stored within the same node array, then adding one\nas the subtree of the other simply requires setting three pointers.\nCombining trees in this way is illustrated by\nFigure .\nThis implementation is more space efficient than the\n\"list of children\" implementation, and each node requires a fixed\namount of space in the node array."}, "target": [{"@refid": "explicit"}, {"@refid": "addexplicit"}], "raw": [{"@format": "xml", "@ids": "explicit", "@names": "explicit", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "addexplicit", "@names": "addexplicit", "@xml:space": "preserve", "odsafig": "null"}]}, {"@ids": "dynamic-node-implementations", "@names": "dynamic\\ node\\ implementations", "title": "Dynamic Node Implementations", "paragraph": ["The two general tree implementations just described use an\narray to store the collection of nodes.\nIn contrast, our standard implementation for binary trees stores each\nnode as a separate dynamic object containing its value and pointers to\nits two children.\nUnfortunately, nodes of a general tree can have any number of\nchildren, and this number may change during the life of the node.\nA general tree node implementation must support these properties.\nOne solution is simply to limit the number of children permitted for\nany node and allocate pointers for exactly that number of children.\nThere are two major objections to this.\nFirst, it places an undesirable limit on the number of children, which\nmakes certain trees unrepresentable by this implementation.\nSecond, this might be extremely wasteful of space because most\nnodes will have far fewer children and thus leave some pointer\npositions empty.", {"title_reference": ["Figure #GenLinkedFixed", "Memory Management", "<Freelist>", "Figure #GenLinkedFixed"], "math": ["M", "M", "M", "M"], "literal": ["size", "size"], "#text": "The alternative is to allocate variable space for each node.\nThere are two basic approaches.\nOne is to allocate an array of child pointers as part of the node.\nIn essence, each node stores an array-based list of child pointers.\nFigure  illustrates the concept.\nThis approach assumes that the number of children is known when the\nnode is created, which is true for some applications but not for\nothers.\nIt also works best if the number of children does not change.\nIf the number of children does change (especially if it increases),\nthen some special recovery mechanism must be provided to support\na change in the size of the child pointer array.\nOne possibility is to allocate a new node of the correct size from\nfree store and return the old copy of the node to free store for\nlater reuse.\nThis works especially well in a language with built-in garbage\ncollection such as Java.\nFor example, assume that a node  initially has two children,\nand that space for two child pointers is allocated when  is\ncreated.\nIf a third child is added to , space for a new node with\nthree child pointers can be allocated, the contents of  is\ncopied over to the new space, and the old space is then returned to\nfree store.\nAs an alternative to relying on the system's garbage collector,\na memory manager for variable size storage units can be implemented,\nas described in Chapter .\nAnother possibility is to use a collection of free lists, one for each\narray size, as described in Module .\nNote in Figure  that the current number\nof children for each node is stored explicitly in a  field.\nThe child pointers are stored in an array with  elements."}, {"title_reference": "Figure #GenLinkedLinked", "#text": "Another approach that is more flexible, but which requires more space,\nis to store a linked list of child pointers with each node\nas illustrated by Figure .\nThis implementation is essentially the same as the \"list of\nchildren\" implementation, but with\ndynamically allocated nodes rather than storing the nodes in an\narray."}], "target": [{"@refid": "genlinkedfixed"}, {"@refid": "genlinkedlinked"}], "raw": [{"@format": "xml", "@ids": "genlinkedfixed", "@names": "genlinkedfixed", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "genlinkedlinked", "@names": "genlinkedlinked", "@xml:space": "preserve", "odsafig": "null"}]}, {"@ids": "dynamic-left-child-right-sibling-implementation", "@names": "dynamic\\ \"left-child/right-sibling\"\\ implementation", "title": "Dynamic \"Left-Child/Right-Sibling\" Implementation", "paragraph": {"title_reference": ["Figure #FortoBin", "Figure #GenBin", "Figure #GenLinkedLinked", "Figure #GenBin", "Figure #GenBin"], "#text": "The \"left-child/right-sibling\" implementation\nstores a fixed number of pointers with each node.\nThis can be readily adapted to a dynamic implementation.\nIn essence, we substitute a binary tree for a\ngeneral tree.\nEach node of the \"left-child/right-sibling\" implementation points to\ntwo \"children\" in a new binary tree structure.\nThe left child of this new structure is the node's first child\nin the general tree.\nThe right child is the node's right sibling.\nWe can easily extend this conversion to a forest of general trees,\nbecause the roots of the trees can be considered siblings.\nConverting from a forest of general trees to a single binary tree is\nillustrated by Figure .\nHere we simply include links from each node to its right sibling and\nremove links to all children except the leftmost child.\nFigure  shows how this might look in an\nimplementation with two pointers at each node.\nCompared with the implementation illustrated by\nFigure  which requires overhead of three\npointers/node, the implementation of Figure  only\nrequires two pointers per node.\nThe representation of Figure  is likely to be\neasier to implement, space efficient, and more flexible than the other\nimplementations presented in this section."}, "target": [{"@refid": "fortobin"}, {"@refid": "genbin"}], "raw": [{"@format": "xml", "@ids": "fortobin", "@names": "fortobin", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@ids": "genbin", "@names": "genbin", "@xml:space": "preserve", "odsafig": "null"}]}]}}