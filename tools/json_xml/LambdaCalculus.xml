<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="lambda-calculus" names="lambda\ calculus" source="&lt;string&gt;" title="Lambda Calculus"><title>Lambda Calculus</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-13 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>The lambda calculus is a small language defined by the following BNF
grammar.</paragraph><math_block xml:space="preserve">\begin{eqnarray*}
&lt;\mathrm{LambdaExp}&gt; &amp;::=&amp; &lt;\mathrm{var}&gt;\\
                     &amp;|&amp; \lambda &lt;\mathrm{var}&gt; . &lt;\mathrm{LambdaExp}&gt;\\
                     &amp;|&amp; (&lt;\mathrm{LambdaExp}&gt; &lt;\mathrm{LambdaExp}&gt;)\\
\end{eqnarray*}</math_block><paragraph>The above BNF grammar tells us that expressions in the lambda calculus come in one of three flavors:</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>A <title_reference>variable</title_reference> (the first production).   For example <math>x</math>.</paragraph></list_item></enumerated_list><block_quote><paragraph>Typically we will use single letters or letters followed by a digit - <math>x, y, a_1, b, p_2</math> - to represent variables.</paragraph></block_quote><enumerated_list enumtype="arabic" prefix="" start="2" suffix="."><list_item><paragraph>A <title_reference>function abstraction</title_reference> (the second production). For example   <math>\lambda x.y</math>.  Think of this as the "function whose formal   parameter is <math>x</math> and whose return value is <math>y</math>".   The equivalent in JavaScript would be:</paragraph></list_item></enumerated_list><literal_block xml:space="preserve">function(x){
  return y;
}</literal_block><paragraph>3. An <title_reference>application</title_reference> (the third production). For example
<math>(y \; z)</math>.  Think of this as "the application of <math>y</math> to
<math>z</math>".  This represents a "function call" in the lambda calculus.
In JavaScript, such a function call would appear as <literal>y(z)</literal>.  The
formal name of an application whose first component is a function
abstraction is a <title_reference>beta-redex</title_reference>.  We will soon explain why this
terminology is appropriate in the context of the operations we perform
to "evaluate" expressions in the lambda calculus.</paragraph><paragraph>For example, to apply the identity function <math>\lambda x.x</math> to the
variable <math>y</math>, we would write <math>(\lambda x.x \; y)</math>.   In
JavaScript, this would be:</paragraph><literal_block xml:space="preserve">(
function(x){
  return x;
}
)(y)</literal_block><paragraph>The expression that would apply the identity function to the
application of <math>a</math> to <math>b</math> would appear as <math>(\lambda x.x \; (a \; b))</math>.  Note how essential the parentheses are in this
notation.  Every parenthesis means something very specific, so using
gratuitous extra parentheses  will inevitably result in a lambda calculus expression with a totally different meaning or an expression  that
violates the BNF grammar.</paragraph><paragraph>A variable is <title_reference>bound</title_reference> in an expression if it refers to the formal
parameter (the variable immediately following the <math>\lambda</math> symbol) in a
function abstraction.  A variable is <title_reference>free</title_reference> in an expression if it is
not bound.  In terms of a more precise recursive definition, a
variable <math>x</math> occurs free in expression E if:</paragraph><bullet_list bullet="-"><list_item><paragraph>E is a variable and E is identical to <math>x</math> , or</paragraph></list_item><list_item><paragraph>E is of the form (E1 E2) and <math>x</math> occurs free in E1 or E2, or</paragraph></list_item><list_item><paragraph>E is of the form <math>\lambda y.E'</math> where <math>y</math> is different from <math>x</math> and <math>x</math> occurs free in E'.</paragraph></list_item></bullet_list><paragraph>To illustrate the difference between free and bound variables.</paragraph><comment xml:space="preserve">Slideshow for Free/Bound Vars</comment><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="FreeBoundCON"
    long_name="FreeBoundCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Note that it is possible for a variable to occur both free and bound
in the same expression.  Consider <math>(\lambda x.x \; x)</math>.  Here
the first occurrence of <math>x</math> is the formal parameter of the
function abstraction, the second occurrence is bound to that formal
parameter, and the third occurrence is free.</paragraph><paragraph>Before seeing how lambda calculus expressions are evaluated, we need
some practice in identifying free and bound variables.  Try the following two exercises:</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="LambdaCalcFree"
    long_name="LambdaCalcFree"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="LambdaCalcBound"
    long_name="LambdaCalcBound"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><paragraph>How should one evaluate a lambda expression?  We first need to realize
that, if by evaluate we mean to "call a function and see what it
returns", then it only makes sense to evaluate a beta-redex, that is,
an application in which the first expression is a function
abstraction.  For instance <math>(\lambda x.(x \; y) \; z)</math> is a
beta-redex, but <math>((x \; y) \; z)</math> is not.  In the lambda
calculus, we evaluate a beta-redex by substituting the second
component of the application expression for the formal parameter of
the function abstraction in the "body" of the function, that is, in the expression following the dot that occurs in the syntax of the
function abstraction.  For instance, carrying out this substitution in
<math>(\lambda x.(x \; y) \; z)</math> would result in <math>(z \; y)</math></paragraph><paragraph>It is important to realize this idea of substitution makes sense in terms of the way we think about calling functions in everyday programming.   For example, suppose we had the JavaScript function</paragraph><literal_block xml:space="preserve">var foobar = function(x,y,z) { return  z * (x - y); }</literal_block><paragraph>and we called it by:</paragraph><literal_block xml:space="preserve">foobar(8,6,4)</literal_block><paragraph>A reasonable way to describe the value returned would be to say "substitute 8 for x, 6 for y, and 4 for z in the expression <math>z * (x - y)</math>.</paragraph><paragraph>The act of doing this substitution is called <title_reference>beta-reducing</title_reference> the
lambda expression.   Hence we now see the rationale for the term
beta-redex that we introduced earlier.   A beta-redex is the one and
only type of lambda expression that can be beta-reduced.</paragraph><paragraph>What can go wrong when we do this substitution to carry out a
beta-reduction in the lambda calculus?  By substituting one
variable for another, a variable that was free in an expression may
become bound.  For instance, in the expression <math>(\lambda
x.\lambda y.(y \; x) \; y)</math>, the last occurrence of y in this
application is free.  But if we beta-reduce, the result will be
<math>\lambda y.(y \; y)</math> and the free y that was substituted for the
formal parameter x is now bound.  This is a result we need to avoid.
To see why consider the following simple example:</paragraph><paragraph><math>(\lambda x.z \; x)</math></paragraph><paragraph>Here <math>\lambda x.z</math> is the function that always returns
<math>z</math>, which here is a free variable.  If we beta-reduce by
substituting the last free occurrence of <math>x</math> for <math>z</math>, the free <math>x</math> is now bound and the function becomes the identity function, which is very different from the function that always returns <math>z</math>,</paragraph><paragraph>To keep from capturing a free variable in this fashion, we must <title_reference>alpha-convert</title_reference> the expression that would cause
the <math>y</math> to become bound.  The intuitive justification of alpha-conversion
is that we do not change the function abstraction <math>\lambda y.(y \; x)</math> if we choose a different variable, say <math>w</math>, to use as the formal
parameter for the function.  That is, as a function definition,
<math>\lambda w.(w \; x)</math> is equivalent to <math>\lambda y.(y \; x)</math>.   To carry out alpha-conversion on a function abstraction like <math>\lambda p.b</math>, we
simply replace each free occurrence of p (the formal parameter) in b (the "body" of the function) by a new variable symbol not occurring anywhere in the body.    To illustrate this, consider:</paragraph><comment xml:space="preserve">Slideshow for Alpha Conversion</comment><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="AlphaConversionCON"
    long_name="AlphaConversionCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Practice alpha conversion with the following exercise:</paragraph><comment xml:space="preserve">Exercise for AlphaConversion</comment><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="AlphaConversionChoice"
    long_name="AlphaConversionChoice"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><paragraph>You can get some more alpha conversion practice with the following exercise:</paragraph><comment xml:space="preserve">Exercise for AlphaConversion</comment><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="AlphaConversionHighlight"
    long_name="AlphaConversionHighlight"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><paragraph>The  rule to remember here is that, before substituting in a lambda
expression to carry out a beta-reduction, be sure to check whether
that substitution will capture any free variable, making it become a
bound variable.  If it will, alpha-convert the expression before
beta-reducing it.</paragraph><comment xml:space="preserve">A fundamental tool in evaluating expressions in the lambda calculus is</comment><comment xml:space="preserve">the notion of substitution.  For the application of a function to its</comment><comment xml:space="preserve">argument, we need merely substitute the argument for the formal</comment><comment xml:space="preserve">parameter in the expression that defines the function, being careful</comment><comment xml:space="preserve">to first alpha convert if doing this would capture a free variable.</comment><comment xml:space="preserve">This is called beta conversion, and</comment><paragraph>To fully evaluate a lambda calculus expression, we may have to perform
multiple beta reductions.  This must be done until there are no more
beta-redexes left in the expression.  At that point, the expression,
fully evaluated, is said to be in <title_reference>beta-normal</title_reference> form.  Since this
involves potentially multiple beta reductions, we have a choice for
the order in which the individual beta conversions are performed.</paragraph><section ids="applicative-order-reduction" names="applicative\ order\ reduction"><title>Applicative Order Reduction</title><paragraph>The strategy is characterized by first evaluating the beta-redexes
that are inside an application expression.  That is, we only perform
an application when each of the internal beta-redexes has been
beta-reduced and there are no beta-redexes left except the topmost
application.  If there is more than one internal beta-redex to choose
from, we select the leftmost innermost beta-redex first.  Consider:</paragraph><comment xml:space="preserve">Slideshow for Applicative order</comment><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="BetaAppCON"
    long_name="BetaAppCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Practice an applicative order reduction in the following exercise:</paragraph><comment xml:space="preserve">Exercise for Applicative</comment><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="BetaReductionAppNextStep"
    long_name="BetaReductionAppNextStep"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><paragraph>For some more practice, try:</paragraph><comment xml:space="preserve">Exercise for Applicative</comment><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="BetaReductionAppHighlight"
    long_name="BetaReductionAppHighlight"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="normal-order-reduction" names="normal\ order\ reduction"><title>Normal Order Reduction</title><paragraph>This strategy reduces the leftmost outermost beta-redex first before reducing
the beta-redexes inside of it and those that follow it.  While
applicative order proceeds by evaluating the internal beta-redexes and then
applying the function, normal order evaluation proceeds by applying
the function first and then evaluating the internal beta-redexes.  Consider
the following example:</paragraph><comment xml:space="preserve">Slideshow for Normal Order</comment><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="BetaNormCON"
    long_name="BetaNormCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Practice a normal order reduction in the following exercise:</paragraph><comment xml:space="preserve">Exercise for Normal</comment><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="BetaReductionNormNextStep"
    long_name="BetaReductionNormNextStep"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><paragraph>For some more practice, try:</paragraph><comment xml:space="preserve">Exercise for Applicative</comment><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="BetaReductionNormHighlight"
    long_name="BetaReductionNormHighlight"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><paragraph>As a final test of your proficiency in doing beta reductions, try doing</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>All the steps in a complete applicative order reduction:</paragraph></list_item></enumerated_list><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="BetaAppPro"
    long_name="BetaAppPro"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw><enumerated_list enumtype="arabic" prefix="" start="2" suffix="."><list_item><paragraph>All the steps in a complete normal order reduction</paragraph></list_item></enumerated_list><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="BetaNormPro"
    long_name="BetaNormPro"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Development/FreeBoundCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Development/AlphaConversionCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Development/BetaAppCON.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Development/BetaNormCON.js</odsascript></raw></section></document>