{"document": {"@dupnames": "kmp\\ string\\ search\\ algorithm", "@ids": "kmp-string-search-algorithm", "@source": "<string>", "@title": "KMP String Search Algorithm", "title": "KMP String Search Algorithm", "subtitle": {"@dupnames": "kmp\\ string\\ search\\ algorithm", "@ids": "id1", "#text": "KMP String Search Algorithm"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}, {"@xml:space": "preserve", "#text": "Slideshow for KMP search algorithm"}, {"@xml:space": "preserve", "#text": "Exercise in tracing one step of the KMP algorithm"}, {"@xml:space": "preserve", "#text": "If the test indicated in Figure 2.17 fails, we will then seek a"}, {"@xml:space": "preserve", "#text": "leading substring of the shaded portion on the left of Figure 2.17"}, {"@xml:space": "preserve", "#text": "that matches a substring ending at position p \u2011 1.  Working within the"}, {"@xml:space": "preserve", "#text": "shaded portion on the left of Figure 2.17 (that is, with the"}, {"@xml:space": "preserve", "#text": "characters at the beginning of sub) we know that the leading align[q]"}, {"@xml:space": "preserve", "#text": "characters on the left of this shaded portion exactly match the"}, {"@xml:space": "preserve", "#text": "characters in the align[q] positions preceding q.  This follows from"}, {"@xml:space": "preserve", "#text": "the definition of the values already stored in the align array.  We"}, {"@xml:space": "preserve", "#text": "also know that the two shaded substrings in Figure 2.17 must"}, {"@xml:space": "preserve", "#text": "match. Combining these facts, we conclude that the first align[q]"}, {"@xml:space": "preserve", "#text": "characters in sub exactly match the sequence of align[q] characters"}, {"@xml:space": "preserve", "#text": "preceding position p \u2011 1 in Figure 2.17.  Consequently, if we reset q"}, {"@xml:space": "preserve", "#text": "to align[q], then align[p] will equal q + 1 provided sub.charAt(q)"}, {"@xml:space": "preserve", "#text": "equals sub.charAt(p \u2013 1).  This logic is iterated until sub.charAt(q)"}, {"@xml:space": "preserve", "#text": "equals sub.charAt(p \u2013 1) or until q becomes negative, as indicated in"}, {"@xml:space": "preserve", "#text": "Figure 2.18."}, {"@xml:space": "preserve"}, {"@xml:space": "preserve"}, {"@xml:space": "preserve"}, {"@xml:space": "preserve", "#text": "Slideshow for creation of alignment array"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "KMP_Slideshow", "@long_name": "KMP_Slideshow", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "KMP_Exercise", "@long_name": "KMP_Exercise", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "KMP_align_array_slideshow", "@long_name": "KMP_align_array_slideshow", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "KMP_Alignment_Array_Exercise", "@long_name": "KMP_Alignment_Array_Exercise", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "KMP_EX_PRO", "@long_name": "KMP_EX_PRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "KMP_Compares_Shifts_Exercise", "@long_name": "KMP_Compares_Shifts_Exercise", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "KMP_Users_Choice", "@long_name": "KMP_Users_Choice", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "paragraph": [{"title_reference": ["p", "sub", "sub", "p", "sub", "p", "sub", "sub", "p"], "#text": "This apparently more efficient string search algorithm was discovered\nin the 1970s by D. E. Knuth, J. H. Morris, and V. R. Pratt.\nConsequently, it is known as the Knuth\u2011Morris\u2011Pratt (or KMP)\nalgorithm.  The key to its search efficiency is the following.  When a\nmismatch occurs in a particular alignment at index  of\n, then we must look to the character matches that occurred\nin the portion of  preceding index .  We are\nseeking a substring of sub in the portion of  immediately\nprior to index  that matches a leading substring of\n.  Once found,  may be realigned so that this\nleading substring overlays what had been the matching substring\nimmediately prior to index . The character\u2011by\u2011character\ncomparison can then proceed from the position of the prior mismatch."}, {"title_reference": ["p", "sub", "sub", "master", "p", "p", "sub", "p", "p\n\u2011 1", "p", "p", "sub", "p", "align", "align", "master", "sub"], "#text": "Its use requires an initial pass through the string sub to determine\nthe appropriate amount of realignment when a mismatch occurs at\nposition  in . Note that this determination is\ndependent only on , not at all on . In\neffect, for each index , we seek the longest sequence of\ncharacters immediately preceding position  that matches a\nsequence at the beginning of . We must qualify this\nslightly to avoid problems in the degenerate case, in which all\ncharacters preceding position  are the same.  When this\noccurs, we restart the matching pass through sub at position .  In other words, we specifically seek the maximum sequence of\ncharacters immediately preceding index  with length less than\n such that this sequence matches a sequence at the beginning\nof .  We will store, for each index , the length\nof such a sequence in an array called .  Given this\ndefinition of the  array, the following slideshow\nindicates how the KMP algorithm would work with a particular\n and  string."}, "The preceding slideshow has unveiled the following pseudocode\nfor the KMP algorithm::", "See if you can predict how one step in this KMP algorithm would\nprogress by trying the following exercise.", {"title_reference": ["align", "align[p]", "p", "align[0]", "align[1]", "p", "align[p \u2011 1]", "align[p]", "align"], "#text": "The creation of the  is itself an interesting algorithm\nand requires some explanation.  Since  must be less\nthan , we start by initializing  to \u20111 and\n to 0.  Since the align array is computed for\nsuccessive values of ,  will have been\ncomputed by the time we attempt to compute , allowing\nus to iterate through the computation of the  array as\nindicated in the following slideshow."}, {"title_reference": "align", "#text": "The preceding slideshow has illustrated the following pseudocode\nfor the computation of the  array in the KMP algorithm::"}, {"title_reference": "align", "#text": "See if you can predict how one step in this  algorithm would\nprogress by trying the following exercise."}, "To indicate that you have fully mastered the intricacies of the KMP\nalgorithm, you must now succeed in working your way through the\nfollowing three exercises:"], "literal_block": [{"@xml:space": "preserve", "#text": "input: master string, sub string, align array\nm = 0\ns = 0\nwhile((s < sub.length) and (sub.length - s <= master.length - m)):\n  if(master[m] == sub[s]): m++, s++\n  else if(s == 0): m++\n  else: s = align[s]\nif(s == sub.length): return m - sub.length\nelse: return -1"}, {"@xml:space": "preserve", "#text": "align[0] = -1\nalign[1] = 0\nL = string.length\nfor(p = 2; p < L; p++):\n  q = align[p-1]\n  while((q>= 0) and (string[q] != string[p-1])):\n    q = align[q]\n  align[p] = q+1"}], "enumerated_list": [{"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": {"paragraph": "Proficiency Exercise in tracing entire KMP algorithm"}}, {"@enumtype": "arabic", "@prefix": "", "@start": "2", "@suffix": ".", "list_item": {"paragraph": "Exercise in counting shifts and compares needed by KMP algorithm"}}, {"@enumtype": "arabic", "@prefix": "", "@start": "3", "@suffix": ".", "list_item": {"paragraph": "Exercise in determining strings with specified number of shifts and compares"}}]}}