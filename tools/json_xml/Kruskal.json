{"document": {"@dupnames": "kruskal's\\ algorithm", "@ids": "kruskal-s-algorithm", "@source": "<string>", "@title": "Kruskal's Algorithm", "title": "Kruskal's Algorithm", "subtitle": {"@dupnames": "kruskal's\\ algorithm", "@ids": "id1", "#text": "Kruskal's Algorithm"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "KruskalUFAV", "@long_name": "KruskalUFAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "KruskalPE", "@long_name": "KruskalPE", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/MCSTCON.js"}], "paragraph": [{"title_reference": ["Kruskal's algorithm", "disjoint sets <UNION/FIND> <UnionFind>"], "math": "|\\mathbf{V}|", "#text": "Our next MCST algorithm is commonly referred to as\n.\nKruskal's algorithm is also a simple, greedy algorithm.\nFirst partition the set of vertices into \n,\neach consisting of one vertex.\nThen process the edges in order of weight.\nAn edge is added to the MCST, and two disjoint sets combined,\nif the edge connects two vertices in different disjoint sets.\nThis process is repeated until only one disjoint set remains."}, {"title_reference": "few smallest elements <HeapSort>", "#text": "The edges can be processed in order of weight by using a\nmin-heap.\nThis is generally faster than sorting the edges first, because in\npractice we need only visit a small fraction of the edges before\ncompleting the MCST.\nThis is an example of finding only a\n in a list."}, {"title_reference": "UNION/FIND <UNION/FIND> <UnionFind>", "literal": "KruskalElem", "#text": "The only tricky part to this algorithm is determining if two vertices\nbelong to the same equivalence class.\nFortunately, the ideal algorithm is available for the purpose ---\nthe .\nHere is an implementation for Kruskal's algorithm.\nClass  is used to store the edges on the min-heap."}, {"literal": ["differ", "UNION"], "math": ["\\Theta(|\\mathbf{E}| \\log |\\mathbf{E}|)", "|\\mathbf{V}|", "\\Theta(|\\mathbf{V}| \\log |\\mathbf{E}|)"], "#text": "Kruskal's algorithm is dominated by the time required to\nprocess the edges.\nThe  and  functions are nearly\nconstant in time if path compression and weighted union is used.\nThus, the total cost of the algorithm is\n in the worst case,\nwhen nearly all edges must be processed before all the edges of the\nspanning tree are found and the algorithm can stop.\nMore often the edges of the spanning tree are the shorter ones,and\nonly about  edges must be processed.\nIf so, the cost is often close to\n in the average case."}]}}