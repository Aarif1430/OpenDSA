{
  "document": {
    "@ids": "unsolveable-problems",
    "@names": "unsolveable\\ problems",
    "@source": "<string>",
    "@title": "Unsolveable Problems",
    "title": "Unsolveable Problems",
    "comment": [{
      "@xml:space": "preserve",
      "#text": "This file is part of the OpenDSA eTextbook project. See"
    }, {
      "@xml:space": "preserve",
      "#text": "http://algoviz.org/OpenDSA for more details."
    }, {
      "@xml:space": "preserve",
      "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"
    }, {
      "@xml:space": "preserve",
      "#text": "distributed under an MIT open source license."
    }],
    "raw": {
      "@format": "xml",
      "@xml:space": "preserve",
      "avmetadata": "null"
    },
    "section": [{
      "@ids": "introduction",
      "@names": "introduction",
      "title": "Introduction",
      "paragraph": ["Even the best programmer sometimes writes a program that goes into an\ninfinite loop.\nOf course, when you run a program that has not stopped, you do not\nknow for sure if it is just a slow program or a program in an infinite\nloop.\nAfter \"enough time\", you shut it down.\nWouldn't it be great if your compiler could look at your program and\ntell you before you run it that it will get into an infinite loop?\nTo be more specific, given a program and a particular input, it would\nbe useful to know if executing the program on that input will result\nin an infinite loop without actually running the program.", {
        "title_reference": ["Halting Problem", "P", "P", "P", "I"],
        "#text": "Unfortunately, the , as this is called, cannot\nbe solved.\nThere will never be a computer program that can positively determine,\nfor an arbitrary program , if \nwill halt for all input.\nNor will there even be a computer program that can positively\ndetermine if arbitrary program  will halt for a specified\ninput .\nHow can this be?\nProgrammers look at programs regularly to determine if they will\nhalt.\nSurely this can be automated.\nAs a warning to those who believe any program can be analyzed in this\nway, carefully examine the following code fragment before reading on."
      }, {
        "title_reference": ["n", "Collatz sequence", "n", "n", "Omega(log n)"],
        "#text": "This is a famous piece of code.\nThe sequence of values that is assigned to  by this code is\nsometimes called the  for input value\n.\nDoes this code fragment halt for all values of ?\nNobody knows the answer.\nEvery input that has been tried halts.\nBut does it always halt?\nNote that for this code fragment, because we do not know if it halts,\nwe also do not know an upper bound for its running time.\nAs for the lower bound, we can easily show\n."
      }, {
        "title_reference": ["n", "computability"],
        "#text": "Personally, I have faith that someday some smart person will\ncompletely analyze the Collatz function, proving once and for all\nthat the code fragment halts for all values of .\nDoing so may well give us techniques that advance our ability to do\nalgorithm analysis in general.\nUnfortunately, proofs from   the branch of\ncomputer science that studies what is impossible to do with a computer\n&mdash; compel us to believe that there will always be another\nbit of program code that we cannot analyze.\nThis comes as a result of the fact that the Halting Problem is\nunsolvable."
      }],
      "raw": [{
        "@format": "xml",
        "@xml:space": "preserve",
        "codeinclude": "null"
      }, {
        "@format": "xml",
        "@xml:space": "preserve",
        "todo": "null"
      }]
    }, {
      "@ids": "uncountability",
      "@names": "uncountability",
      "title": "Uncountability",
      "paragraph": ["Before proving that the Halting Problem is unsolvable, we first prove\nthat not all functions can be implemented as a computer program.\nThis must be so because the number of programs is much smaller than\nthe number of possible functions.", {
        "title_reference": ["countable", "countably infinite", "uncountable", "uncountably infinite"],
        "#text": "A set is said to be  (or \nif it is a set with an infinite number of members)\nif every member of the set can be uniquely assigned to a positive\ninteger.\nA set is said to be \n(or ) if it is not possible to\nassign every member of the set to its own positive integer."
      }, {
        "title_reference": ["i", "i/2", "i", "i", "i", "2i"],
        "#text": "To understand what is meant when we say \"assigned to a positive\ninteger\", imagine that there is an infinite row of bins, labeled 1,\n2, 3, and so on.\nTake a set and start placing members of the set into bins, with at\nmost one member per bin.\nIf we can find a way to assign all of the set members to bins, then the\nset is countable.\nFor example, consider the set of positive even integers 2, 4, and so\non.\nWe can assign an integer  to bin \n(or, if we don't mind skipping some bins, then we can assign even\nnumber  to bin ).\nThus, the set of even integers is countable.\nThis should be no surprise, because intuitively there are \"fewer\"\npositive even integers than there are positive integers,\neven though both are infinite sets.\nBut there are not really any more positive integers than\nthere are positive even integers, because we can uniquely assign every\npositive integer to some positive even integer by simply assigning\npositive integer  to positive even integer ."
      }, {
        "title_reference": ["i", "2i", "-i", "2i+1"],
        "#text": "On the other hand, the set of all integers is also countable, even\nthough this set appears to be bigger than the set of positive\nintegers.\nThis is true because we can assign 0 to positive integer 1, 1 to\npositive integer 2, -1 to positive integer 3, 2 to positive integer 4,\n-2 to positive integer 5, and so on.\nIn general, assign positive integer value  to positive\ninteger\nvalue , and assign negative integer value  to\npositive integer value .\nWe will never run out of positive integers to assign, and we know\nexactly which positive integer every integer is assigned to.\nBecause every integer gets an assignment, the set of integers is\ncountably infinite."
      }, {
        "title_reference": ["P", "P", "P", "P^2"],
        "#text": "Are the number of programs countable or uncountable?\nA program can be viewed as simply a string of characters (including\nspecial punctuation, spaces, and line breaks).\nLet us assume that the number of different characters that can appear\nin a program is .\n(Using the ASCII character set,  must be less than 128,\nbut the actual number does not matter).\nIf the number of strings is countable, then surely the number of\nprograms is also countable.\nWe can assign strings to the bins as follows.\nAssign the null string to the first bin.\nNow, take all strings of one character, and assign them to the next\n bins in \"alphabetic\" or ASCII code order.\nNext, take all strings of two characters, and assign them to the next\n bins, again in ASCII code order working from left to\nright.\nStrings of three characters are likewise assigned to bins, then\nstrings of length four, and so on.\nIn this way, a string of any given length can be assigned\nto some bin."
      }, {
        "strong": "do",
        "#text": "By this process, any string of finite length is assigned\nto some bin.\nSo any program, which is merely a string of finite length, is\nassigned to some bin.\nBecause all programs are assigned to some bin, the set of all programs\nis countable.\nNaturally most of the strings in the bins are not legal programs, but\nthis is irrelevant.\nAll that matters is that the strings that , correspond to\nprograms are also in the bins."
      }, {
        "title_reference": "integer functions",
        "#text": "Now we consider the number of possible functions.\nTo keep things simple, assume that all functions take a single\npositive integer as input and yield a single positive integer as\noutput.\nWe will call such functions .\nA function is simply a mapping from input values to output values.\nOf course, not all computer programs literally take integers as input\nand yield integers as output.\nHowever, everything that computers read and write is\nessentially a series of numbers, which may be interpreted as letters\nor something else.\nAny useful computer program's input and output can be coded as integer\nvalues, so our simple model of computer input and output is\nsufficiently general to cover all possible computer programs."
      }, "We now wish to see if it is possible to assign all of the integer\nfunctions to the infinite set of bins.\nIf so, then the number of functions is countable, and it might then be\npossible to assign every integer function to a program.\nIf the set of integer functions cannot be assigned to bins, then\nthere will be integer functions that must have no corresponding program.", {
        "title_reference": "function table",
        "#text": "Imagine each integer function as a table with two columns and an\ninfinite number of rows.\nThe first column lists the positive integers starting at 1.\nThe second column lists the output of the function when given the value\nin the first column as input.\nThus, the table explicitly describes the mapping from input to output\nfor each function.\nCall this a ."
      }, {
        "title_reference": "Figure #FuncAssign",
        "#text": "Next we will try to assign function tables to bins.\nTo do so we must order the functions, but it does not matter what\norder we choose.\nFor example, Bin 1 could store the function that always returns 1\nregardless of the input value.\nBin 2 could store the function that returns its input.\nBin 3 could store the function that doubles its input and adds 5.\nBin 4 could store a function for which we can see no simple\nrelationship between input and output.\nThese four functions as assigned to the first four bins are shown in\nFigure ."
      }, {
        "title_reference": ["F_1(1)", "F_2(2)", "F_{new}(i) = F_i(i) + 1", "i", "F_i", "i", "diagonalization", "Figure #Diag"],
        "strong": "must",
        "#text": "Can we assign every function to a bin?\nThe answer is no, because there is always a way to create a new\nfunction that is not in any of the bins.\nSuppose that somebody presents a way of assigning functions to bins\nthat they claim includes all of the functions.\nWe can build a new function that has not been assigned to any bin, as\nfollows.\nTake the output value for input 1 from the function in the first bin.\nCall this value .\nAdd 1 to it, and assign the result as the output of a new\nfunction for input value 1.\nRegardless of the remaining values assigned to our new function, it\nmust be different from the first function in the table, because the\ntwo give different outputs for input 1.\nNow take the output value for 2 from the second function in the table\n(known as ).\nAdd 1 to this value and assign it as the output for 2 in our new\nfunction.\nThus, our new function must be different from the function of Bin 2,\nbecause they will differ at least at the second value.\nContinue in this manner, assigning  for\nall values .\nThus, the new function must be different from any function \nat least at position .\nThis procedure for constructing a new function not already in the\ntable is called .\nBecause the new function is different from every other function, it\nmust not be in the table.\nThis is true no matter how we try to assign functions to\nbins, and so the number of integer functions is uncountable.\nThe significance of this is that not all functions can possibly be\nassigned to programs, so there  be functions with no\ncorresponding program.\nFigure  illustrates this argument."
      }],
      "target": [{
        "@refid": "funcassign"
      }, {
        "@refid": "diag"
      }],
      "raw": [{
        "@format": "xml",
        "@ids": "funcassign",
        "@names": "funcassign",
        "@xml:space": "preserve",
        "odsafig": "null"
      }, {
        "@format": "xml",
        "@ids": "diag",
        "@names": "diag",
        "@xml:space": "preserve",
        "odsafig": "null"
      }]
    }, {
      "@ids": "the-halting-problem-is-unsolvable",
      "@names": "the\\ halting\\ problem\\ is\\ unsolvable",
      "title": "The Halting Problem Is Unsolvable",
      "paragraph": [{
        "strong": ["some", "useful"],
        "title_reference": "Figure #FuncAssign",
        "#text": "There might be intellectual appeal to knowing\nthat there exists  function that cannot be computed by a\ncomputer program\nBut does it really matter if no program can compute a\n\"nonsense\" function such as the one shown in Bin 4 of\nFigure ?\nThat alone doesn't have to mean that there is a  function\nthat cannot be computed.\nAfter all, the universe should not be this perverse, should it?\nPerhaps the very fact that we can easily specify the function that we\nwant to compute implies that there must be an algorithm to compute\nit."
      }, "Unfortunately, not so.\nNow we will prove that the Halting Problem cannot be computed by any\ncomputer program.\nThe proof is by contradiction.", {
        "literal": ["halt", "halt", "halt", "PROGRAM_HALTS", "halt"],
        "#text": "We begin by assuming that there is a function named  that\ncan solve the Halting Problem.\nObviously, it is not possible to write out something that does not\nexist, but here is a plausible sketch of what a function to solve the\nHalting Problem might look like if it did exist.\nFunction  takes two inputs: a string representing the\nsource code for a program or function, and another string\nrepresenting the input that we wish to determine if the input program\nor function halts on.\nFunction  does some work to make a decision (which is\nencapsulated into some fictitious function named ).\nFunction  then returns TRUE if the input program or\nfunction does halt on the given input, and FALSE otherwise."
      }, "We now will examine two simple functions that clearly can exist\nbecause the complete code for them is presented here.", {
        "literal": ["contrary", "selfhalt", "TRUE", "selfhalt", "contrary", "contrary", "selfhalt", "halt", "contrary", "contrary", "contrary", "halt"],
        "#text": "What happens if we make a program whose sole purpose is to execute\nthe function  and run that program with itself as\ninput?\nOne possibility is that the call to  returns ;\nthat is,  claims that  will halt when run on\nitself.\nIn that case,  goes into an infinite loop\n(and thus does not halt).\nOn the other hand, if  returns FALSE, then\n is proclaiming that  does not halt on itself,\nand   then returns, that is, it halts.\nThus,  does the contrary of what\n says that it will do."
      }, {
        "literal": ["contrary", "halt", "halt"],
        "#text": "The action of  is logically inconsistent with the\nassumption that  solves the Halting Problem correctly.\nThere are no other assumptions we made that might cause this\ninconsistency.\nThus, by contradiction, we have proved that  cannot\nsolve the Halting Problem correctly, and thus there is no program that\ncan solve the Halting Problem."
      }, "Now that we have proved that the Halting Problem is unsolvable, we\ncan use reduction arguments to prove that other problems are also\nunsolvable.\nThe strategy is to assume the existence of a computer program that\nsolves the problem in question and use that program to solve another\nproblem that is already known to be unsolvable.", "There are many things that we would like to have a computer do\nthat are unsolvable.\nMany of these have to do with program behavior.\nFor example, proving that an arbitrary program is \"correct\", that\nis, proving that a program computes a particular function, is a proof\nregarding program behavior.\nAs such, what can be accomplished is severely limited.\nSome other unsolvable problems include:", {
        "strong": ["not", "all"],
        "literal": ["while", "FALSE", "while"],
        "#text": "This does  mean that a computer program cannot be written\nthat works on special cases, possibly even on most programs that we\nwould be interested in checking.\nFor example, some C compilers will check if the control expression\nfor a  loop is a constant expression that evaluates to\n.\nIf it is, the compiler will issue a warning that the \nloop code will never be executed.\nProgrammers find this special case useful enough to make it worth\nincluding in the compiler.\nHowever, it is not possible to write a computer program that can\ncheck for  input programs whether a specified line of code\nwill be executed when the program is given some specified input."
      }, "Another unsolvable problem is whether a program contains a computer\nvirus.\nThe property \"contains a computer virus\" is a matter of behavior.\nThus, it is not possible to determine positively whether an arbitrary\nprogram contains a computer virus.\nFortunately, there are many good heuristics for determining if a\nprogram is likely to contain a virus, and it is usually possible to\ndetermine if a program contains a particular virus, at least for the\nones that are now known.\nReal virus checkers do a pretty good job,\nbut, it will always be possible for malicious people to invent new\nviruses that no existing virus checker can recognize."],
      "literal_block": [{
        "@xml:space": "preserve",
        "#text": "bool halt(String prog, String input) {\n  if (PROGRAM_HALTS(prog, input))\n    return true;\n  else\n    return false;\n}"
      }, {
        "@xml:space": "preserve",
        "#text": "// Return true if \"prog\" halts when given itself as input\nbool selfhalt(String prog) {\n  if (halt(prog, prog))\n    return true;\n  else\n    return false;\n}\n\n// Return the reverse of what selfhalt returns on \"prog\"\nvoid contrary(String prog) {\n  if (selfhalt(prog))\n    while (true); // Go into an infinite loop\n}"
      }],
      "topic": [{
        "title": "Example",
        "paragraph": ["Consider the following variation on the Halting Problem.\nGiven a computer program, will it halt when its input is the\nempty string?\nThat is, will it halt when it is given no input?\nTo prove that this problem is unsolvable, we will employ a standard\ntechnique for computability proofs:\nUse a computer program to modify another computer program.", {
          "strong": "Proof by contradiction:"
        }, {
          "literal": ["Ehalt", "combine", "combine", "Ehalt", "Ehalt", "Ehalt"],
          "title_reference": ["P", "I", "P", "I", "S", "P", "S", "P'", "P'", "P'", "P", "I"],
          "#text": "Assume that there is a function  that determines\nwhether a given program halts when given no input.\nRecall that our proof for the Halting Problem involved functions\nthat took as parameters a string representing a program and another\nstring representing an input.\nConsider another function  that takes a program\n and an input string  as parameters.\nFunction  modifies  to store \nas a static variable  and further modifies all calls\nto input functions within  to instead get their input from\n.\nCall the resulting program .\nIt should take no stretch of the imagination to believe that any\ndecent compiler could be modified to take computer programs and\ninput strings and produce a new computer program that has been\nmodified in this way.\nNow, take  and feed it to .\nIf  says that  will halt, then we know that\n would halt on input .\nIn other words, we now have a procedure for solving the original\nHalting Problem.\nThe only assumption that we made was the existence of .\nThus, the problem of determining if a program will halt on no input\nmust be unsolvable."
        }]
      }, {
        "title": "Example",
        "paragraph": [{
          "title_reference": ["P", "P"],
          "strong": "any",
          "#text": "For arbitrary program , does there exist  input for\nwhich  halts?"
        }, {
          "strong": "Proof by contradiction:"
        }, {
          "literal": ["Ahalt", "Ahalt", "Ahalt", "Ahalt"],
          "title_reference": ["P", "P", "P", "w", "w", "P", "P", "P'", "P'", "w", "P'", "P", "w", "P'", "P", "w", "P'", "P'", "P", "w"],
          "#text": "This problem is also uncomputable.\nAssume that we had a function  that, when given program\n as input would determine if there is some input for which\n halts.\nWe could modify our compiler (or write a function as part of a\nprogram) to take  and some input string , and\nmodify it so that  is hardcoded inside ,\nwith  reading no input.\nCall this modified program .\nNow,  always behaves the same way regardless of its\ninput, because it ignores all input.\nHowever, because  is now hardwired inside of ,\nthe behavior we get is that of  when given  as\ninput.\nSo,  will halt on any arbitrary input if and only if\n would halt on input .\nWe now feed  to function .\nIf  could determine that  halts on some\ninput, then that is the same as determining that  halts on\ninput .\nBut we know that that is impossible.\nTherefore,  cannot exist."
        }]
      }],
      "bullet_list": {
        "@bullet": "*",
        "list_item": [{
          "paragraph": "Does a program halt on every input?"
        }, {
          "paragraph": "Does a program compute a particular function?"
        }, {
          "paragraph": "Do two programs compute the same function?"
        }, {
          "paragraph": "Does a particular line in a program get executed?"
        }]
      },
      "footnote": {
        "@auto": "1",
        "@ids": "id1",
        "@names": "1",
        "label": "1",
        "paragraph": "There is no requirement for a function to have any discernible\nrelationship between input and output.\nA function is simply a mapping of inputs to outputs, with no\nconstraint on how the mapping is determined."
      }
    }]
  }
}