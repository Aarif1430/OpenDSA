<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="array\ implementation\ for\ complete\ binary\ trees" ids="array-implementation-for-complete-binary-trees" source="&lt;string&gt;" title="Array Implementation for Complete Binary Trees"><title>Array Implementation for Complete Binary Trees</title><subtitle dupnames="array\ implementation\ for\ complete\ binary\ trees" ids="id1">Array Implementation for Complete Binary Trees</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>From the <title_reference>full binary tree theorem &lt;BinaryTreeFullThm&gt;</title_reference>, we know
that a large fraction of the space in a typical binary tree node
implementation is devoted to structural <title_reference>overhead</title_reference>, not to
storing data.
This module presents a simple, compact implementation
for <title_reference>complete binary trees &lt;complete binary tree&gt;</title_reference>.
Recall that complete binary trees have all levels except the bottom
filled out completely, and the bottom level has all of its nodes filled
in from left to right.
Thus, a complete binary tree of <math>n</math> nodes has only one possible
shape.
You might think that a complete binary tree is such an unusual
occurrence that there is no reason to develop a special
implementation for it.
However, the complete binary tree has practical uses, the most
important being the <title_reference>heap &lt;heap&gt; &lt;Heap&gt;</title_reference> data structure.
Heaps are often used to implement
<title_reference>priority queues &lt;priority queue&gt;</title_reference> and for
<title_reference>external sorting algorithms &lt;external sort&gt; &lt;ExternalSort&gt;</title_reference>.</paragraph><paragraph>We begin by assigning numbers to the node positions in the complete
binary tree, level by level, from left to right as shown in
Figure <title_reference>Figure #BinArray</title_reference>.
An array can store the tree's data values efficiently, placing
each data value in the array position corresponding to that node's
position within the tree.
The table lists the array indices for the
children, parent, and siblings of each node in
Figure <title_reference>Figure #BinArray</title_reference>.</paragraph><target refid="binarray"></target><raw format="xml" ids="binarray" names="binarray" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>Here is a table that lists, for each node position, the positions of
the parent, sibling, and children of the node.</paragraph><math_block xml:space="preserve">\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\textrm{Position} &amp; 0  &amp; 1 &amp; 2 &amp; 3 &amp;  4 &amp;  5 &amp; 6 &amp; 7 &amp; 8 &amp;  9 &amp; 10 &amp; 11\\
\hline
\hline
\textrm{Parent} &amp; \,--\, &amp; 0 &amp; 0 &amp; 1 &amp;  1 &amp;  2 &amp;  2 &amp; 3 &amp; 3 &amp; 4 &amp; 4 &amp; 5\\
\hline
\textrm{Left Child} &amp; 1  &amp; 3 &amp; 5 &amp; 7 &amp;  9 &amp; 11 &amp; \,--\, &amp; \,--\, &amp; \,--\, &amp;
\,--\, &amp; \,--\, &amp;  \,--\,\\
\hline
\textrm{Right Child} &amp; 2  &amp; 4 &amp; 6 &amp; 8 &amp; 10 &amp; \,--\, &amp; \,--\, &amp; \,--\, &amp;
\,--\, &amp; \,--\, &amp; \,--\, &amp;  \,--\,\\
\hline
\textrm{Left Sibling} &amp; \,--\, &amp; \,--\, &amp; 1 &amp; \,--\, &amp;  3 &amp; \,--\, &amp; 5 &amp;
\,--\, &amp; 7 &amp; \,--\, &amp;  9 &amp;  \,--\,\\
\hline
\textrm{Right Sibling} &amp; \,--\, &amp; 2 &amp; \,--\, &amp; 4 &amp; \,--\, &amp;  6 &amp; \,--\, &amp; 8 &amp;
\,--\, &amp; 10 &amp; \,--\, &amp; \,--\,\\
\hline
\end{array}</math_block><paragraph>Looking at the table, you should see a pattern
regarding the positions of a node's relatives within the array.
Simple formulas can be derived for calculating the array index
for each relative of a node <math>R</math> from <math>R</math>'s index.
No explicit pointers are necessary to reach a node's left or
right child.
This means there is no overhead to the array implementation if the
array is selected to be of size <math>n</math> for a tree of <math>n</math>
nodes.</paragraph><paragraph>The formulae for calculating the array indices of the various
relatives of a node are as follows.
The total number of nodes in the tree is <math>n</math>.
The index of the node in question is <math>r</math>,
which must fall in the range 0 to <math>n-1</math>.</paragraph><bullet_list bullet="*"><list_item><paragraph>Parent(<math>r</math>) <math>= \lfloor(r - 1)/2\rfloor</math>
if <math>r \neq 0</math>.</paragraph></list_item><list_item><paragraph>Left child(<math>r</math>) <math>= 2r + 1</math> if <math>2r + 1 \leq n</math>.</paragraph></list_item><list_item><paragraph>Right child(<math>r</math>) <math>= 2r + 2</math> if <math>2r + 2 \leq n</math>.</paragraph></list_item><list_item><paragraph>Left sibling(<math>r</math>) <math>= r - 1</math> if <math>r</math> is even.</paragraph></list_item><list_item><paragraph>Right sibling(<math>r</math>) <math>= r + 1</math> if <math>r</math>
is odd and <math>r + 1 \leq n</math>.</paragraph></list_item></bullet_list><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="CompleteFIB"
    long_name="CompleteFIB"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></document>