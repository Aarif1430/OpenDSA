{"document": {"@dupnames": "design\\ patterns", "@ids": "design-patterns", "@source": "<string>", "@title": "Design Patterns", "title": "Design Patterns", "subtitle": {"@dupnames": "design\\ patterns", "@ids": "id1", "#text": "Design Patterns"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "paragraph": [{"title_reference": "design patterns <design pattern>", "#text": "At a higher level of abstraction than ADTs\nare abstractions for describing the design of programs  that is,\nthe interactions of objects and classes.\nExperienced software designers learn and reuse patterns\nfor combining software components.\nThese have come to be referred to as\n."}, "A design pattern embodies and generalizes important design concepts\nfor a recurring problem.\nA primary goal of design patterns is to quickly transfer the knowledge\ngained by expert designers to newer programmers.\nAnother goal is to allow for efficient communication between\nprogrammers.\nIt is much easier to discuss a design issue when you share a\ntechnical vocabulary relevant to the topic.", "Specific design patterns emerge from the realization that a particular\ndesign problem appears repeatedly in many contexts.\nThey are meant to solve real problems.\nDesign patterns describe the structure for a design solution, with the\ndetails filled in for any given problem.\nDesign patterns are a bit like data structures:\nEach one provides costs and benefits, which implies that tradeoffs are\npossible.\nTherefore, a given design pattern might have variations on its\napplication to match the various tradeoffs inherent in a given\nsituation.", "The rest of this module introduces a few simple design patterns that\noccur frequently in a study of data structures and algorithms."], "section": [{"@ids": "flyweight", "@names": "flyweight", "title": "Flyweight", "paragraph": [{"title_reference": "Flyweight", "#text": "The  is meant to solve the following problem:\nYou have an application with many objects.\nSome of these objects are identical in the information that\nthey contain, and the role that they play.\nBut they must be reached from various places, and conceptually they\nreally are distinct objects.\nBecause there is so much duplication of the same information,\nwe would like to take advantage of the opportunity to reduce memory\ncost by sharing that space.\nAn example comes from representing the layout for a document.\nThe letter \"C\" might reasonably be represented by an object that\ndescribes that character's strokes and bounding box.\nHowever, we do not want to create a separate \"C\" object everywhere\nin the document that a \"C\" appears.\nThe solution is to allocate a single copy of the shared representation\nfor \"C\" objects.\nThen, every place in the document that needs a \"C\" in a given font,\nsize, and typeface will reference this single copy.\nThe various instances of references to a specific form of \"C\" are\ncalled flyweights."}, "We could describe the layout of text on a page by using a\ntree structure.\nThe root of the tree represents the entire page.\nThe page has multiple child nodes, one for each column.\nThe column nodes have child nodes for each row.\nAnd the rows have child nodes for each character.\nThese representations for characters are the flyweights.\nThe flyweight includes the reference to the shared shape information,\nand might contain additional information specific to that instance.\nFor example, each instance for \"C\" will contain a reference to the\nshared information about strokes and shapes, and it might also contain\nthe exact location for that instance of the character on the page.", {"title_reference": ["PR quadtree <PR quadtree> <Spatial>", "bintree <bintree> <Spatial>", "leaf nodes <leaf node>"], "#text": "Flyweights are used in the implementation for the\n and the\n\nfor storing collections of point objects.\nIn a PR quadtree, many of the  represent\nempty areas, and the only information that they store is the fact that\nthey are empty.\nThese identical nodes can be implemented using a reference to a single\ninstance of the flyweight to reduce memory costs."}]}, {"@ids": "visitor", "@names": "visitor", "title": "Visitor", "paragraph": [{"title_reference": "tree traversal <traversal> <BinaryTreeTraversal>", "#text": "Given a tree of objects to describe a page layout,\nwe might wish to perform some activity on every node in the tree.\nA \nis the process of visiting every node in the tree in a defined\norder.\nA simple example for our text composition application might be to\ncount the number of nodes in the tree that represents the page.\nAt another time, we might wish to print a listing of all the nodes for\ndebugging purposes."}, {"title_reference": ["visitor", "Graph Traversal <traversal> <GraphTraversal>"], "#text": "We could write a separate traversal function for each such activity\nthat we intend to perform on the tree.\nA better approach would be to write a generic traversal function,\nand pass in the activity to be performed at each node.\nThis organization constitutes the  design pattern.\nThe visitor design pattern can also be used in\n."}]}, {"@ids": "composite", "@names": "composite", "title": "Composite", "paragraph": [{"title_reference": ["procedural", "visitor"], "#text": "There are two fundamental approaches to dealing with the relationship\nbetween a collection of actions and a hierarchy of object types.\nFirst consider the typical  approach.\nSay we have a base class for page layout entities, with a subclass\nhierarchy to define specific subtypes (page, columns, rows, figures,\ncharacters, etc.).\nAnd say there are actions to be performed on a collection of such\nobjects (such as rendering the objects to the screen).\nThe procedural design approach is for each action to be implemented\nas a method that takes as a parameter a pointer to the base class\ntype.\nEach such action method will traverse through the collection of\nobjects, visiting each object in turn.\nEach action method contains something like a switch statement that\ndefines the details of the action for each subclass in the collection\n(e.g., page, column, row, character).\nWe can cut the code down some by using the\n design pattern\nso that we only need to write the traversal once, and then write a\nvisitor subroutine for each action that might be applied to the\ncollection of objects.\nBut each such visitor subroutine must still contain logic for dealing\nwith each of the possible subclasses."}, "In our page composition application, there are only a few activities\nthat we would like to perform on the page representation.\nWe might render the objects in full detail.\nOr we might want a \"rough draft\" rendering that prints only the\nbounding boxes of the objects.\nIf we come up with a new activity to apply to the collection of\nobjects, we do not need to change any of the code that implements the\nexisting activities.\nBut adding new activities won't happen often for this application.\nIn contrast, there could be many object types, and we might frequently\nadd new object types to our implementation.\nUnfortunately, adding a new object type requires that we modify each\nactivity, and the subroutines implementing the activities get rather\nlong switch statements to distinguish the behavior of the many\nsubclasses.", "An alternative design is to have each object subclass in the hierarchy\nembody the action for each of the various activities that might be\nperformed.\nEach subclass will have code to perform each activity\n(such as full rendering or bounding box rendering).\nThen, if we wish to apply the activity to the collection, we simply\ncall the first object in the collection and specify the action\n(as a method call on that object).\nIn the case of our page layout and its hierarchical collection of\nobjects, those objects that contain other objects (such as a row\nobjects that contains letters) will call the appropriate method for\neach child.\nIf we want to add a new activity with this organization, we have to\nchange the code for every subclass.\nBut this is relatively rare for our text compositing application.\nIn contrast, adding a new object into the subclass hierarchy (which\nfor this application is far more likely than adding a new rendering\nfunction) is easy.\nAdding a new subclass does not require changing any of the existing\nsubclasses.\nIt merely requires that we define the behavior of each activity that\ncan be performed on the new subclass.", {"title_reference": ["Composite design pattern", "Expression Tree <Expression Tree> <Composite>"], "#text": "This second design approach of burying the functional activity in the\nsubclasses is called the .\nA detailed example for using the Composite design pattern\ncan be seen in a discussion of the\n."}]}, {"@ids": "strategy", "@names": "strategy", "title": "Strategy", "paragraph": [{"title_reference": ["strategy", "strategy"], "#text": "Our final example of a design pattern lets us encapsulate and make\ninterchangeable a set of alternative actions that\nmight be performed as part of some larger activity.\nAgain continuing our text compositing example, each output device that\nwe wish to render to will require its own function for doing the\nactual rendering.\nThat is, the objects will be broken down into constituent pixels or\nstrokes, but the actual mechanics of rendering a pixel or stroke will\ndepend on the output device.\nWe don't want to build this rendering functionality into the object\nsubclasses.\nInstead, we want to pass to the subroutine performing the rendering\naction a method or class that does the appropriate rendering details\nfor that output device.\nThat is, we wish to hand to the object the appropriate \"\"\nfor accomplishing the details of the rendering task.\nThus, this approach is called the  design pattern."}, "The Strategy design pattern can be used to create generalized sorting\nfunctions.\nThe sorting function can be called with an additional parameter.\nThis parameter is a class\nthat understands how to extract and compare the key values for\nrecords to be sorted.\nIn this way, the sorting function does not need to know any details\nof how its record type is implemented.", "One of the biggest challenges to understanding design patterns is that\nsometimes one is only subtly different from another.\nFor example, you might be confused about the difference between the\ncomposite pattern and the visitor pattern.\nThe distinction is that the composite design pattern is about whether\nto give control of the traversal process to the nodes of the tree or to\nthe tree itself.\nBoth approaches can make use of the visitor design pattern to avoid\nrewriting the traversal function many times, by\nencapsulating the activity performed at each node.", "But isn't the strategy design pattern doing the same thing?\nThe difference between the visitor pattern and the strategy pattern is\nmore subtle.\nHere the difference is primarily one of intent and focus.\nIn both the strategy design pattern and the visitor design pattern, an\nactivity is being passed in as a parameter.\nThe strategy design pattern is focused on encapsulating an activity\nthat is part of a larger process, so that different ways of\nperforming that activity can be substituted.\nThe visitor design pattern is focused on encapsulating an activity that\nwill be performed on all members of a collection so that completely\ndifferent activities can be substituted within a generic method that\naccesses all of the collection members."]}, {"@ids": "summary-questions", "@names": "summary\\ questions", "title": "Summary Questions", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "DesignPatternSumm", "@long_name": "DesignPatternSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}}]}}