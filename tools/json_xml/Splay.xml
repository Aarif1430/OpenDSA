<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="the-splay-tree" names="the\ splay\ tree" source="&lt;string&gt;" title="The Splay Tree"><title>The Splay Tree</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>Like the AVL tree, the splay tree is not actually a distinct data
structure, but rather reimplements the BST insert, delete, and search
methods to improve the performance of a BST.
The goal of these revised methods is to provide guarantees on the time
required by a series of operations, thereby avoiding the worst-case
linear time behavior of standard BST operations.
No single operation in the splay tree is guaranteed to be efficient.
Instead, the splay tree access rules guarantee that a series of
<title_reference>m</title_reference> operations will take <title_reference>O(m log n)</title_reference> time for a tree of
<title_reference>n</title_reference> nodes whenever <title_reference>m geq n</title_reference>.
Thus, a single insert or search operation could take <title_reference>O(n)</title_reference>
time.
However, <title_reference>m</title_reference> such operations are guaranteed to require a total
of <title_reference>O(m log n)</title_reference> time, for an average cost of
<title_reference>O(log n)</title_reference> per access operation.
This is a desirable performance guarantee for any search-tree
structure.</paragraph><paragraph>Unlike the AVL tree, the splay
tree is not guaranteed to be height balanced.
What is guaranteed is that the total cost of the entire series of
accesses will be cheap.
Ultimately, it is the cost of the series of operations that matters,
not whether the tree is balanced.
Maintaining balance is really done only for the sake of reaching this
time efficiency goal.</paragraph><paragraph>The splay tree access functions operate in a manner reminiscent of
the <title_reference>move-to-front</title_reference> rule for
<title_reference>self-organizing lists &lt;self-organizing list&gt; &lt;SelfOrg&gt;</title_reference>,
and of the path compression technique for managing
a series of
<title_reference>Union/Find &lt;Union/Find&gt; &lt;UnionFind&gt;</title_reference> operations.
These access functions tend to make the tree more balanced, but an
individual access will not necessarily result in a more balanced
tree.</paragraph><paragraph>Whenever a node <title_reference>S</title_reference> is accessed (e.g., when <title_reference>S</title_reference> is
inserted, deleted, or is the goal of a search), the splay tree
performs a process called <title_reference>splaying</title_reference>.
Splaying moves <title_reference>S</title_reference> to the root of the BST.
When <title_reference>S</title_reference> is being deleted, splaying
moves the parent of <title_reference>S</title_reference> to the root.
As in the AVL tree, a splay of node <title_reference>S</title_reference>
consists of a series of <title_reference>rotations &lt;rotation&gt;</title_reference>.
A rotation moves <title_reference>S</title_reference> higher in the tree by adjusting its
position with respect to its parent and grandparent.
A side effect of the rotations is a tendency to balance the tree.
There are three types of rotation.</paragraph><paragraph>A <title_reference>single rotation</title_reference> is performed only if <title_reference>S</title_reference>
is a child of the root node.
The single rotation is illustrated by Figure <title_reference>Figure #SingProm</title_reference>.
It basically switches <title_reference>S</title_reference> with its parent in a way that
retains the BST property.
While Figure <title_reference>Figure #SingProm</title_reference> is slightly different from
Figure <title_reference>Figure #AVLsingle</title_reference>, in fact the splay tree single
rotation is identical to the AVL tree single rotation.</paragraph><target refid="singprom"></target><raw format="xml" ids="singprom" names="singprom" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>Unlike the AVL tree, the splay tree requires two types of
double rotation.
Double rotations involve <title_reference>S</title_reference>, its parent (call it <title_reference>P</title_reference>),
and <title_reference>S</title_reference> 's grandparent (call it <title_reference>G</title_reference>).
The effect of a double rotation is to move <title_reference>S</title_reference> up two levels in
the tree.</paragraph><paragraph>The first double rotation is called a <title_reference>zigzag rotation</title_reference>.
It takes place when either of the following two conditions are met:</paragraph><enumerated_list enumtype="arabic" prefix="(" suffix=")"><list_item><paragraph><title_reference>S</title_reference> is the left child of <title_reference>P</title_reference>, and <title_reference>P</title_reference> is the
right child of <title_reference>G</title_reference>.</paragraph></list_item><list_item><paragraph><title_reference>S</title_reference> is the right child of <title_reference>P</title_reference>, and <title_reference>P</title_reference> is the
left child of <title_reference>G</title_reference>.</paragraph></list_item></enumerated_list><paragraph>In other words, a zigzag rotation is used when <title_reference>G</title_reference>,
<title_reference>P</title_reference>, and <title_reference>S</title_reference> form a zigzag.
The zigzag rotation is illustrated by Figure <title_reference>Figure #ZigZag</title_reference>.</paragraph><target refid="zigzag"></target><raw format="xml" ids="zigzag" names="zigzag" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>The other double rotation is known as a <title_reference>zigzig</title_reference> rotation.
A zigzig rotation takes place when either of the following two
conditions are met:</paragraph><enumerated_list enumtype="arabic" prefix="(" suffix=")"><list_item><paragraph><title_reference>S</title_reference> is the left child of <title_reference>P</title_reference>, which is in turn the
left child of <title_reference>G</title_reference>.</paragraph></list_item><list_item><paragraph><title_reference>S</title_reference> is the right child of <title_reference>P</title_reference>, which is in turn the
right child of <title_reference>G</title_reference>.</paragraph></list_item></enumerated_list><paragraph>Thus, a zigzig rotation takes place in those
situations where a zigzag rotation is not appropriate.
The zigzig rotation is illustrated by Figure <title_reference>Figure #ZigZig</title_reference>.
While Figure <title_reference>Figure #ZigZig</title_reference> appears somewhat different from
Figure <title_reference>Figure #AVLdouble</title_reference>, in fact the zigzig rotation is
identical to the AVL tree double rotation.</paragraph><target refid="zigzig"></target><raw format="xml" ids="zigzig" names="zigzig" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>Note that zigzag rotations tend to make the tree more balanced,
because they bring subtrees <title_reference>B</title_reference>  and <title_reference>C</title_reference> up one level
while moving subtree <title_reference>D</title_reference> down one level.
The result is often a reduction of the tree's height by one.
Zigzig promotions and single rotations do not typically reduce the
height of the tree; they merely bring the newly accessed record toward
the root.</paragraph><paragraph>Splaying node <title_reference>S</title_reference> involves a series of double rotations until
<title_reference>S</title_reference> reaches either the root or the child of the root.
Then, if necessary, a single rotation makes <title_reference>S</title_reference> the root.
This process tends to re-balance the tree.
Regardless of balance, splaying will make frequently accessed nodes
stay near the top of the tree, resulting in reduced access cost.
Proof that the splay tree meets the guarantee of
<title_reference>O(m log n)</title_reference> is beyond the scope of our study.</paragraph><topic><title>Example</title><paragraph>Consider a search for value 89 in the splay tree of
Figure <title_reference>Figure #SplayEx</title_reference> (a).
The splay tree's search operation is identical to searching in
a BST.
However, once the value has been found, it is splayed to the root.
Three rotations are required in this example.
The first is a zigzig rotation, whose result is shown in
Figure <title_reference>Figure #SplayEx</title_reference> (b).
The second is a zigzag rotation, whose result is shown in
Figure <title_reference>Figure #SplayEx</title_reference> (c).
The final step is a single rotation resulting in the tree of
Figure <title_reference>Figure #SplayEx</title_reference> (d).
Notice that the splaying process has made the tree shallower.</paragraph></topic><target refid="splayex"></target><raw format="xml" ids="splayex" names="splayex" xml:space="preserve"><odsafig>null</odsafig></raw></document>