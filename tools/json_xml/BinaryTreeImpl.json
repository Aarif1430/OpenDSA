{"document": {"@dupnames": "binary\\ tree\\ node\\ implementations", "@ids": "binary-tree-node-implementations", "@source": "<string>", "@title": "Binary Tree Node Implementations", "title": "Binary Tree Node Implementations", "subtitle": {"@dupnames": "binary\\ tree\\ node\\ implementations", "@ids": "id1", "#text": "Binary Tree Node Implementations"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Binary/BTCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Binary/BTnullpointerCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Binary/expressionTreeCON.css"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@ids": "binlink", "@names": "binlink", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "BTnullpointerCON", "@long_name": "BTnullpointerCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@ids": "diffnodes", "@names": "diffnodes", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "expressionTreeCON", "@long_name": "expressionTreeCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "expressionTraversalCON", "@long_name": "expressionTraversalCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/BTnullpointerCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/expressionTreeCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/expressionTraversalCON.js"}], "paragraph": ["In this module we examine various ways to implement binary tree\nnodes.\nBy definition, all binary tree nodes have two children,\nthough one or both children can be empty.\nBinary tree nodes typically contain a value field,\nwith the type of the field depending on the application.\nThe most common node implementation includes a value field and\npointers to the two children.", {"literal": ["BinNode", "BSTNode", "BSTNode"], "title_reference": ["Binary Search Tree <binary search tree> <BST>", "key-value pair <key-value pair> <Dictionary>"], "#text": "Here is a simple implementation for the\n abstract class, which we will name .\nIts element type is an Object.\nWhen we need to support search structures such as the\n,\nthe node will typically store a\n.\nEvery  object also has two pointers,\none to its left child and another to its right child."}, "Some programmers find it convenient to add a pointer to the\nnode's parent, allowing easy upward movement in the\ntree.\nUsing a parent pointer is somewhat analogous to adding a link to the\nprevious node in a doubly linked list.\nIn practice, the parent pointer is almost always unnecessary\nand adds to the space overhead for the tree implementation.\nIt is not just a problem that parent pointers take space.\nMore importantly, many uses of the parent pointer are driven by\nimproper understanding of recursion and so indicate poor programming.\nIf you are inclined toward using a parent pointer, consider if there\nis a more efficient implementation possible.", {"title_reference": ["leaves <leaf node>", "internal nodes <internal node>", "binary trie", "PR Quadtree", "Huffman coding tree", "expression tree", "Figure #DiffNodes"], "#text": "An important decision in the design of a pointer-based node\nimplementation is whether the same class definition will be used for\n and\n.\nUsing the same class for both will simplify the implementation, but\nmight be an inefficient use of space.\nSome applications require data values only for the leaves.\nOther applications require one type of value for the leaves and\nanother for the internal nodes.\nExamples include the , the ,\nthe , and the \nillustrated by Figure .\nBy definition, only internal nodes have non-empty children.\nIf we use the same node implementation for both internal and leaf\nnodes, then both must store the child pointers.\nBut it seems wasteful to store child pointers in the leaf nodes.\nThus, there are many reasons why it can save space to have separate\nimplementations for internal and leaf nodes."}, {"title_reference": ["Figure #DiffNodes", "Figure #DiffNodes"], "math": "4x(2x + a) - c", "#text": "As an example of a tree that stores different information at the leaf\nand internal nodes, consider the expression tree illustrated by\nFigure .\nThe expression tree represents an algebraic expression\ncomposed of binary operators such as addition, subtraction,\nmultiplication, and division.\nInternal nodes store operators, while the leaves store operands.\nThe tree of Figure  represents the expression\n.\nThe storage requirements for a leaf in an expression tree are quite\ndifferent from those of an internal node.\nInternal nodes store one of a small set of operators,\nso internal nodes could store a small code identifying the\noperator such as a single byte for the operator's character symbol.\nIn contrast, leaves store variable names or numbers,\nwhich is considerably larger in order\nto handle the wider range of possible values.\nAt the same time, leaf nodes need not store child pointers."}, {"title_reference": ["Object-oriented languages <object-oriented programming paradigm>", "class hierarchy", "base class", "subclass"], "literal": ["VarBinNode", "isLeaf", "isLeaf", "isLeaf"], "#text": "allow us to differentiate leaf from\ninternal nodes through the use of a .\nA  provides a general definition for an\nobject,\nand a  modifies a base class to add more detail.\nA base class can be declared for binary tree nodes in general,\nwith subclasses defined for the internal and leaf nodes.\nThe base class in the following code is named\n.\nIt includes a virtual member function named\n, which indicates the node type.\nSubclasses for the internal and leaf node types each implement\n.\nInternal nodes store child pointers of the base class type;\nthey do not distinguish their children's actual subclass.\nWhenever a node is examined, its version of  indicates\nthe node's subclass."}, {"literal": ["VarBinNode", "LeafNode", "IntlNode", "IntlNode", "VarBinNode", "traverse", "traverse", "isLeaf", "rt", "isLeaf", "isLeaf", "traverse"], "#text": "The Expression Tree implementation includes two subclasses derived\nfrom class , named  and\n.\nClass  can access its children through\npointers of type .\nFunction  illustrates the use of these classes.\nWhen  calls method ,\nthe language's runtime environment\ndetermines which subclass this particular instance of \nhappens to be and calls that subclass's version of .\nMethod  then provides the actual node type to its\ncaller.\nThe other member functions for the derived subclasses are accessed by\ntype-casting the base class pointer as appropriate, as shown in\nfunction ."}], "line_block": {"line": null}, "target": [{"@refid": "binlink"}, {"@refid": "diffnodes"}]}}