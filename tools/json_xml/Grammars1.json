{"document": {"@ids": "grammars-part-1", "@names": "grammars\\ -\\ part\\ 1", "@source": "<string>", "@title": "Grammars - Part 1", "title": "Grammars - Part 1", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}, {"@xml:space": "preserve", "#text": "(M 2/1/16)"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/PL/AV/parseTree.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/PL/main.css"}], "section": [{"@ids": "rp-1-part-1", "@names": "rp\\ 1\\ part\\ 1", "title": "RP 1 part 1", "paragraph": ["Topics in this module:", "Grammars provide a formalism for expressing the syntax of programming\nlanguages.  That syntax is consequently used to parse, that is,\ndetermine the correctness, of a \"program\" in the language.  A grammar\nis composed of the following three elements.", {"emphasis": "derives", "#text": "We say that the non-terminal on the left of such a production  the string on the right."}, {"title_reference": "<exp>", "#text": "An example of a context-free grammar should help to clarify this three-part definition.   By convention the non-terminal on the left of the first production is the start symbol, and that is what ultimately must be parsed to have a complete expression in the language.   Hence in the example below,  is the start symbol."}], "block_quote": [{"enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Terminology of grammars"}, {"paragraph": "Derivations and parse trees"}]}}, {"bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "A set of terminals.  These terminals represent the tokens --\ncharacters, or groups of characters that logically belong\ntogether, such as operator symbols, delimiters, keywords, variable\nnames -- that ultimately comprise the program or expression being\nparsed. In the case of algebraic expressions, the terminals would\nbe variables, numeric constants, parentheses, and the various\noperators that are allowed."}, {"paragraph": "A set of non-terminals.  These non-terminals represent the various\ngrammatical constructs within the language we are parsing. In\nparticular, one non-terminal is designated as the start symbol for\nthe grammar."}, {"paragraph": "A set of productions.  The productions are formal rules defining\nthe syntactical composition of the non-terminals from the\nprevious point. The productions take the form:"}]}}], "math_block": {"@xml:space": "preserve", "#text": "\\begin{eqnarray*}\n<nonterminal> &::=& String \\; of \\; terminals \\; and/or \\; nonterminals\\\\\n\\end{eqnarray*}"}, "target": {"@refid": "eg1"}, "section": {"@ids": "example-grammar-1 eg1", "@names": "example\\ grammar\\ 1 eg1", "title": "Example Grammar 1", "math_block": {"@xml:space": "preserve", "#text": "\\begin{eqnarray*}\n<exp> &::=& <trm>\\\\\n&|& <exp> + <trm> \\\\\n&|& <exp> - <trm> \\\\\n&|& <exp> * <trm> \\\\\n&|& <exp> / <trm> \\\\\n<trm> &::=& <pri> \\\\\n&|& ( <exp> ) \\\\\n<pri> &:==& A | B | C | \\ldots | X | Y | Z\n\\end{eqnarray*}"}, "paragraph": [{"title_reference": ["<pri>", "|", "<pri>", "<trm>", "<pri>", "<exp>", "A + B * C"], "emphasis": "parse tree", "#text": "This is essentially a grammar for algebraic expressions with variables\n(that is, the  non-terminal) allowed to be a single upper-case\nletter.  When reading a grammar, the vertical bar  means\n\"or\".  Hence  can be A or B or C ...  The \nnon-terminal must either be a  or a parenthesized\n.  A derivation of the expression \naccording to this grammar proceeds as illustrated in the following\nslide show, with the final result being a .  You should step\nthrough all the slides, making sure that at each step you understand\nthe production that is being applied to \"grow\" the parse tree."}, "Note that, in a complete parse tree, leaf nodes are always terminals,\nand a traversal of the tree that would output these leaf nodes\nwould reproduce the expression being parsed.  This is indicated by the red\nhighlighting in the above slide-show.", {"title_reference": ["epsilon", "epsilon"], "emphasis": "empty production", "#text": "The following set of four review problems for this module should be completed before you go on.   In these review problems, the symbol  is used to represent the .   When  appears on the right of a production, it means that one of the possibilities for the non-terminal on the left side of the production is for it to derive the empty string, that is, the string with no characters.  This is typically used when the syntax for the language being parsed allows the option of the non-terminal not appearing at all.   Often with productions that are recursive, it provides a way for the recursion to bottom out -- similar to the way a recursive termination condition would work in a recursive algorithm."}, "The first problem is about building a parse tree given a grammar and a string."], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "parseTree4", "@long_name": "parseTree4", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP1part1", "@long_name": "RP1part1", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}}, {"@ids": "rp-1-part-2", "@names": "rp\\ 1\\ part\\ 2", "title": "RP 1 part 2", "paragraph": "This problem is about determining whether a given string can be\ngenerated by a given grammar.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP1part2", "@long_name": "RP1part2", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "rp-1-part-3", "@names": "rp\\ 1\\ part\\ 3", "title": "RP 1 part 3", "paragraph": "This problem is about identifying properties of all of the strings in\na language defined by a given grammar.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP1part3", "@long_name": "RP1part3", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "rp-1-part-4", "@names": "rp\\ 1\\ part\\ 4", "title": "RP 1 part 4", "paragraph": "This problem is about precisely characterizing the whole language\ngenerated by a given grammar.", "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP1part4", "@long_name": "RP1part4", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/PL/AV/parseTree4.js"}]}]}}