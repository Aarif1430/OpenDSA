<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="reductions" names="reductions" source="&lt;string&gt;" title="Reductions"><title>Reductions</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/SeniorAlgAnal/ReduceSimpPCON.css</odsalink></raw><section ids="introduction" names="introduction"><title>Introduction</title><paragraph>This module introduces an important concept for
understanding the relationships between problems, called
<title_reference>reduction</title_reference>.
Reduction allows us to solve one problem in terms of another.
Equally importantly, when we wish to understand the difficulty of a
problem, reduction allows us to make relative statements about
upper and lower bounds on the cost of a problem (as opposed to an
algorithm or program).</paragraph><paragraph>Because the concept of a problem is discussed extensively in this
chapter, we want notation to simplify problem descriptions.
Throughout this chapter, a problem will be defined in terms of a
mapping between inputs and outputs, and the name of the problem will
be given in all capital letters.
Thus, a complete definition of the sorting problem could appear as
follows:</paragraph><topic><title>SORTING</title><paragraph><strong>Input:</strong> A sequence of integers
<math>x_0, x_1, x_2, \ldots, x_{n-1}</math>.</paragraph><paragraph><strong>Output:</strong>
A permutation <math>y_0, y_1, y_2, \ldots, y_{n-1}</math> of the
sequence such that <math>y_i \leq y_j</math> whenever <math>i &lt; j</math>.</paragraph></topic></section><section ids="example-the-pairing-problem" names="example:\ the\ pairing\ problem"><title>Example: The Pairing Problem</title><paragraph>When you buy or write a program to solve one problem, such
as sorting, you might be able to use it to help solve a different
problem.
This is known in software engineering as <title_reference>software reuse</title_reference>.
To illustrate this, let us consider another problem.</paragraph><topic><title>PAIRING</title><paragraph><strong>Input:</strong>
Two sequences of integers
<math>X = (x_0, x_1, ..., x_{n-1})</math> and
<math>Y =(y_0, y_1, ..., y_{n-1})</math>.</paragraph><paragraph><strong>Output:</strong>
A pairing of the elements in the two sequences such that
the least value in <math>X</math> is paired with the least value in
<math>Y</math>, the next least value in <math>X</math> is paired with the
next least value in <math>Y</math>, and so on.</paragraph></topic><target refid="pair"></target><raw format="xml" ids="pair" names="pair" xml:space="preserve"><odsafig>null</odsafig></raw><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="pairToSortReduction"
    long_name="pairToSortReduction"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>Figure <title_reference>Figure #Pair</title_reference> illustrates PAIRING.
One way to solve PAIRING is to use an existing sorting
program to sort each of the two sequences, and then pair off
items based on their position in sorted order.
Technically we say that in this solution, <strong>PAIRING</strong> is
<title_reference>reduced &lt;reduction&gt;</title_reference> to SORTING, because <strong>SORTING</strong> is used to
solve PAIRING.</paragraph><paragraph>Notice that reduction is a three-step process.
The first step is to convert an instance of
<strong>PAIRING</strong> into two instances of <strong>SORTING</strong>.
The conversion step in this example is not very interesting; it simply
takes each sequence and assigns it to an array to be passed to
<strong>SORTING</strong>.
The second step is to sort the two arrays (i.e., apply <strong>SORTING</strong> to
each array).
The third step is to convert the output of <strong>SORTING</strong> to the output
for <strong>PAIRING</strong>.
This is done by pairing the first elements in the sorted arrays, the
second elements, and so on.</paragraph><paragraph>A reduction of <strong>PAIRING</strong> to <strong>SORTING</strong> helps to establish an upper
bound on the cost of <strong>PAIRING</strong>.
In terms of asymptotic notation, assuming that we can find one method
to convert the inputs to <strong>PAIRING</strong> into inputs to <strong>SORTING</strong>
"fast enough", and a second method to convert the result of
<strong>SORTING</strong> back to the correct result for <strong>PAIRING</strong> "fast enough",
then the asymptotic cost of PAIRING cannot be more than the cost of
<strong>SORTING</strong>.
In this case, there is little work to be done to convert from
<strong>PAIRING</strong> to <strong>SORTING</strong>, or to convert the answer from <strong>SORTING</strong>
back to the answer for <strong>PAIRING</strong>, so the dominant cost of this
solution is performing the sort operation.
Thus, an upper bound for <strong>PAIRING</strong> is in <math>O(n \log n)</math>.</paragraph><paragraph>It is important to note that the pairing problem does <strong>not</strong>
require that elements of the two sequences be sorted.
This is merely one possible way to solve the problem.
<strong>PAIRING</strong> only requires that the elements of the sequences be paired
correctly.
Perhaps there is another way to do it?
Certainly if we use sorting to solve <strong>PAIRING</strong>,
the algorithms will require <math>\Omega(n \log n)</math> time.
But, another approach might conceivably be faster.</paragraph></section><section ids="reduction-and-finding-a-lower-bound" names="reduction\ and\ finding\ a\ lower\ bound"><title>Reduction and Finding a Lower Bound</title><paragraph>There is another use of reductions aside from applying an old
algorithm to solve a new problem (and thereby establishing an upper
bound for the new problem).
That is to prove a lower bound on the cost of a new problem by showing
that it could be used as a solution for an old problem with a known
lower bound.</paragraph><paragraph>Assume we can go the other way and convert <strong>SORTING</strong> to <strong>PAIRING</strong>
"fast enough".
What does this say about the minimum cost of <strong>PAIRING</strong>?
We know that the
<title_reference>lower bound &lt;sorting lower bound&gt; &lt;SortingLowerBound&gt;</title_reference>
for <strong>SORTING</strong> in the worst and average cases is
in <math>\Omega(n \log n)</math>.
In other words, the best possible algorithm for sorting requires at
least <math>n \log n</math> time.</paragraph><paragraph>Assume that PAIRING could be done in <math>O(n)</math> time.
Then, one way to create a sorting algorithm would be to convert
<strong>SORTING</strong> into <strong>PAIRING</strong>, run the algorithm for <strong>PAIRING</strong>,
and finally convert the answer back to the answer for <strong>SORTING</strong>.
Provided that we can convert SORTING to/from PAIRING "fast enough",
this process would yield an <math>O(n)</math> algorithm for sorting!
Because this contradicts what we know about the lower bound for
<strong>SORTING</strong>, and the only flaw in the reasoning is the initial
assumption that <strong>PAIRING</strong> can be done in <math>O(n)</math> time, we can
conclude that there is no <math>O(n)</math> time algorithm for
<strong>PAIRING</strong>.
This reduction process tells us that <strong>PAIRING</strong> must be at least as
expensive as <strong>SORTING</strong> and so must itself have a lower bound in
<math>\Omega(n \log n)</math>.</paragraph><paragraph>To complete this proof regarding the lower bound for <strong>PAIRING</strong>, we
need now to find a way to reduce <strong>SORTING</strong> to <strong>PAIRING</strong>.
This is easily done.
Take an instance of SORTING (i.e., an array <math>A</math> of <math>n</math>
elements).
A second array <math>B</math> is generated that simply stores <math>i</math> in
position <math>i</math> for <math>0 \leq i &lt; n</math>.
Pass the two arrays to <strong>PAIRING</strong>.
Take the resulting set of pairs, and use the value from the <math>B</math>
half of the pair to tell which position in the sorted array the
<math>A</math> half should take; that is, we can now reorder the records in
the <math>A</math> array using the corresponding value in the <math>B</math>
array as the sort key and running a simple
<math>\Theta(n)</math>
<title_reference>Binsort &lt;Binsort&gt; &lt;BinSort&gt;</title_reference>.
The conversion of <strong>SORTING</strong> to <strong>PAIRING</strong> can be done in
<math>O(n)</math> time, and likewise the conversion of the output of
<strong>PAIRING</strong> can be converted to the correct output for <strong>SORTING</strong> in
<math>O(n)</math> time.
Thus, the cost of this "sorting algorithm" is dominated by the cost
for <strong>PAIRING</strong>.</paragraph></section><section ids="the-reduction-template" names="the\ reduction\ template"><title>The Reduction Template</title><paragraph>Consider any two problems for which a suitable reduction from one to
the other can be found.
The first problem takes an arbitrary instance of its input, which
we will call <strong>I</strong>, and transforms <strong>I</strong> to a solution, which
we will call <strong>SLN</strong>.
The second problem takes an arbitrary instance of its input, which
we will call <strong>I'</strong>, and transforms <strong>I'</strong> to a solution,
which we will call <strong>SLN'</strong>.
We can define reduction more formally as a three-step process:</paragraph><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Transform an arbitrary instance of the first problem to an
instance of the second problem.
In other words, there must be a transformation from any instance
<strong>I</strong> of the first problem to an instance <strong>I'</strong> of the
second problem.</paragraph></list_item><list_item><paragraph>Apply an algorithm for the second problem to the instance
<strong>I'</strong>, yielding a solution <strong>SLN'</strong>.</paragraph></list_item><list_item><paragraph>Transform <strong>SLN'</strong> to the solution of <strong>I</strong>, known as <strong>SLN</strong>.
Note that <strong>SLN</strong> must in fact be the correct solution for <strong>I</strong>
for the reduction to be acceptable.</paragraph></list_item></enumerated_list><target refid="blackbox"></target><raw format="xml" ids="blackbox" names="blackbox" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>Figure <title_reference>Figure #BlackBox</title_reference> shows a graphical representation of the
general reduction process, showing the role of the two problems, and
the two transformations.
Next is a slideshow that shows the steps for
the reduction of <strong>SORTING</strong> to <strong>PAIRING</strong>.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="sortToPairReduction"
    long_name="sortToPairReduction"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>It is important to note that the reduction process does not give us
an algorithm for solving either problem by itself.
It merely gives us a method for solving the first problem given that
we already have a solution to the second.
More importantly for the topics to be discussed in the remainder of
this chapter, reduction gives us a way to understand the bounds of
one problem in terms of another.
Specifically, given efficient transformations,
the upper bound of the first problem is at most the upper bound of
the second.
Conversely, the lower bound of the second problem is at least the
lower bound of the first.</paragraph></section><section ids="two-multiplication-examples" names="two\ multiplication\ examples"><title>Two Multiplication Examples</title><paragraph>As a second example of reduction, consider the simple problem of
multiplying two <math>n</math>-digit numbers.
The standard long-hand method for multiplication is to multiply the
last digit of the first number by the second number
(taking <math>\Theta(n)</math> time), multiply the second digit of the
first number by the second number (again taking <math>\Theta(n)</math>
time), and so on for each of the <math>n</math> digits of the first
number.
Finally, the intermediate results are added together.
Note that adding two numbers of length <math>M</math> and <math>N</math> can
easily be done in <math>\Theta(M + N)</math> time.
Because each digit of the first number is multiplied against each
digit of the second, this algorithm requires <math>\Theta(n^2)</math>
time.
Asymptotically faster (but more complicated) algorithms are known, but
none is so fast as to be in <math>O(n)</math>.</paragraph><paragraph>Next we ask the question:
Is squaring an <math>n</math>-digit number as difficult as multiplying two
<math>n</math>-digit numbers?
We might hope that something about this special case will allow for a
faster algorithm than is required by the more general multiplication
problem.
However, a simple reduction proof serves to show that squaring is
"as hard" as multiplying.</paragraph><paragraph>The key to the reduction is the following formula:</paragraph><math_block xml:space="preserve">X \times Y = \frac{(X + Y)^2 - (X - Y)^2}{4}.</math_block><paragraph>The significance of this formula is that it allows us to
convert an arbitrary instance of multiplication to a series of
operations involving three addition/subtractions (each of which can be
done in linear time), two squarings, and a division by 4.
This is because</paragraph><math_block xml:space="preserve">(X + Y)^2 - (X - Y)^2 = X^2 + 2XY + Y^2 - (X^2 - 2XY + Y^2) = 4XY</math_block><paragraph>Note that the division by 4 can be done in linear time (simply convert
to binary, shift right by two digits, and convert back).
This reduction shows that if a linear time algorithm for squaring can
be found, it can be used to construct a linear time algorithm for
multiplication.</paragraph><paragraph>Our next example of reduction concerns the multiplication of two
<math>n \times n</math> matrices.
For this problem, we will assume that the values stored in the
matrices are simple integers and that multiplying two simple integers
takes constant time (because multiplication of two <literal>int</literal>
variables takes a fixed number of machine instructions).
The standard algorithm for multiplying two matrices is to multiply
each element of the first matrix's first row by the corresponding
element of the second matrix's first column, then adding the numbers.
This takes <math>\Theta(n)</math> time.
Each of the <math>n^2</math> elements of the solution are computed in
similar fashion, requiring a total of <math>\Theta(n^3)</math> time.
Faster algorithms are known
(see <title_reference>Strassen's algorithm &lt;Strassen's algorithm&gt; &lt;Strassen&gt;</title_reference>),
but none are so fast as to be in <math>O(n^2)</math>.</paragraph><paragraph>Now, consider the case of multiplying two
<title_reference>symmetric matrices &lt;symmetric matrix&gt;</title_reference>.
A symmetric matrix is one in which entry <math>ij</math> is equal to entry
<math>ji</math>; that is, the upper-right triangle of the matrix is a
mirror image of the lower-left triangle.
Is there something about this restricted case that allows us to
multiply two symmetric matrices faster than in the general case?
The answer is no, as can be seen by the following reduction.
Assume that we have been given two <math>n \times n</math> matrices
<math>A</math> and <math>B</math>.
We can construct a <math>2n \times 2n</math> symmetric matrix from an
arbitrary matrix <math>A</math> as follows:</paragraph><math_block xml:space="preserve">\left[
\begin{array}{cc}
0 &amp;A\\
A^{\rm T}&amp; 0
\end{array}
\right].</math_block><paragraph>Here 0 stands for an <math>n \times n</math> matrix composed of zero
values, <math>A</math> is the original matrix, and <math>A^{\rm T}</math> stands
for the transpose of matrix <math>A</math>. <footnote_reference auto="1" ids="id1" refid="id2">1</footnote_reference></paragraph><paragraph>Note that the resulting matrix is now symmetric.
We can convert matrix <math>B</math> to a symmetric matrix in a similar
manner.
If symmetric matrices could be multiplied "quickly" (in particular,
if they could be multiplied together in <math>\Theta(n^2)</math> time),
then we could find the result of multiplying two arbitrary
<math>n \times n</math> matrices in <math>\Theta(n^2)</math> time by taking
advantage of the following observation:</paragraph><math_block xml:space="preserve">\left[
\begin{array}{cc}
0&amp;A\\
A^{\rm T}&amp;0
\end{array}
\right]
\left[
\begin{array}{cc}
0&amp;B^{\rm T}\\
B&amp;0
\end{array}
\right] =
\left[
\begin{array}{cc}
AB&amp;0\\
0&amp;A^{\rm T}B^{\rm T}
\end{array}
\right].</math_block><paragraph>In the above formula, <math>AB</math> is the result of multiplying
matrices <math>A</math> and <math>B</math> together.</paragraph><paragraph>The following slideshow illustrates this reduction process.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="matrixMulReduction"
    long_name="matrixMulReduction"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><footnote auto="1" backrefs="id1" ids="id2" names="1"><label>1</label><paragraph>The transpose operation
takes position <math>ij</math> of the original matrix and places it
in position <math>ji</math> of the transpose matrix.
This can easily be done in <math>n^2</math> time for an
<math>n \times n</math> matrix.</paragraph></footnote></section><section ids="bounds-theorems" names="bounds\ theorems"><title>Bounds Theorems</title><paragraph>We will use the following notation:
<math>\leq_{O(g(n))}</math> means that a reduction can be done
with transformations that cost <math>O(g(n))</math>.</paragraph><paragraph><strong>Lower Bound Theorem}</strong>: If <math>P_1 \leq_{O(g(n))} P_2</math>,
then there is a lower bound of <math>\Omega(h(n))</math> on the time
complexity of <math>P_1</math>, and <math>g(n) = o(h(n))</math>,
then there is a lower bound of <math>\Omega(h(n))</math> on
<math>P_2</math>.
(Notice little-oh, not big-Oh.)</paragraph><paragraph>Example:
SORTING <math>\leq_{O(n)}</math> PAIRING, because
<math>g(n) = n</math>, <math>h(n) = n \log n</math>, and
<math>g(n) = o(h(n))</math>.
The Lower Bound Theorem gives us an <math>\Omega(n \log n)</math>
lower bound on PAIRING.</paragraph><paragraph>This also goes the other way.</paragraph><paragraph><strong>Upper Bound Theorem</strong>: If <math>P_2</math> has time complexity
<math>O(h(n))</math> and <math>P_1 \leq_{O(g(n))} P_2</math>, then
<math>P_1</math> has time complexity <math>O(g(n) + h(n))</math>.</paragraph><paragraph>So, given good transformations, both problems take at least
<math>\Omega(P_1)</math> and at most <math>O(P_2)</math>.</paragraph></section><section ids="the-cost-of-making-a-simple-polygon" names="the\ cost\ of\ making\ a\ simple\ polygon"><title>The Cost of Making a Simple Polygon</title><paragraph>SIMPLE POLYGON: Given a set of <math>n</math> points in the plane,
find a simple polygon with those points as vertices.
(Here, "simple" means that no lines cross.)
We will show that SORTING <math>\leq_{O(n)}</math> SIMPLE POLYGON.</paragraph><paragraph>We start with an instance of SORTING: <math>\{x_1, x_2, \cdots, x_n\}</math>.
In linear time, find <math>M = \max|x_i|</math>.
Let <math>C</math> be a circle centered at the origin, of radius <math>M</math>.</paragraph><paragraph>We will generate an instance of SIMPLE POLYGON by replacing each value
in the array to be sorted with a corresponding point defined as</paragraph><math_block xml:space="preserve">\{(x_1, \sqrt{M^2 - x_i^2}), \cdots, (x_n, \sqrt{M^2 - x_n^2})\}.</math_block><raw format="xml" xml:space="preserve"><inlineav
    type="dgm"
    exer_name="ReduceSimpPCON"
    long_name="ReduceSimpPCON"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>It is an important fact that all of these points fall on <math>C</math>.
Furthermore, when we find a simple polygon, the points all fall along
the circle in sort order.
This is because
the only simple polygon having all of its points on <math>C</math> as
vertices is the convex one.
Therefore, by the Lower Bound Theorem, SIMPLE POLYGON is in
<math>\Omega(n \log n)</math>.</paragraph><raw format="xml" xml:space="preserve"><odsascript>AV/SeniorAlgAnal/ReduceSimpPCON.js</odsascript></raw></section></document>