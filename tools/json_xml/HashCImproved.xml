<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="improved-collision-resolution" names="improved\ collision\ resolution" source="&lt;string&gt;" title="Improved Collision Resolution"><title>Improved Collision Resolution</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Hashing/collisionCON.css</odsalink></raw><section ids="linear-probing-by-steps" names="linear\ probing\ by\ steps"><title>Linear Probing by Steps</title><paragraph>How can we avoid primary clustering?
One possible improvement might be to use linear probing,
but to skip slots by some constant <math>c</math> other than 1.
This would make the probe function
<math>\textbf{p}(K, i) = ci</math>,
and so the <math>i</math> th slot in the probe sequence will be
<math>(\textbf{h}(K) + ic) \mod M</math>.
In this way, records with adjacent home positions will not follow the
same probe sequence.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="collisionCON1"
    long_name="collisionCON1"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>One quality of a good probe sequence is that it will cycle through
all slots in the hash table before returning to the home position.
Clearly linear probing (which "skips" slots by one each time) does this.
Unfortunately, not all values for <math>c</math> will make this happen.
For example, if <math>c = 2</math> and the table contains an even number of
slots, then any key whose home position is in an even slot will have
a probe sequence that cycles through only the even slots.
Likewise, the probe sequence for a key whose home position is in an
odd slot will cycle through the odd slots.
Thus, this combination of table size and linear probing constant
effectively divides the records into two sets stored in two
disjoint sections of the hash table.
So long as both sections of the table contain the same number of records,
this is not really important.
However, just from chance it is likely that one section will become
fuller than the other, leading to more collisions and poorer
performance for those records.
The other section would have fewer records, and thus better
performance.
But the overall system performance will be degraded,
as the additional cost to the side that is more full outweighs the
improved performance of the less-full side.</paragraph><paragraph>Constant <math>c</math> must be relatively prime to <math>M</math> to generate a
linear probing sequence that visits all slots in the table
(that is, <math>c</math> and <math>M</math> must share no factors).
For a hash table of size <math>M = 10</math>, if <math>c</math>
is any one of 1, 3, 7, or 9,
then the probe sequence will visit all slots for any key.
When <math>M = 11</math>, any value for <math>c</math> between 1 and 10 generates a
probe sequence that visits all slots for every key.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="collisionCON2"
    long_name="collisionCON2"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Now you can practice linear probing by different step sizes.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="HashLinearStepPPRO"
    long_name="HashLinearStepPPRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="pseudo-random-probing" names="pseudo-random\ probing"><title>Pseudo-Random Probing</title><paragraph>Consider the situation where <math>c = 2</math> and we wish to insert a record
with key <math>k_1</math> such that
<math>\textbf{h}(k_1) = 3</math>.
The probe sequence for  <math>k_1</math> is 3, 5, 7, 9, and so on.
If another key <math>k_2</math> has home position at slot 5,
then its probe sequence will be 5, 7, 9, and so on.
The probe sequences of <math>k_1</math> and <math>k_2</math>
are linked together in a manner that contributes to clustering.
In other words, linear probing with a value of <math>c &gt; 1</math> does not
solve the problem of primary clustering.
We would like to find a probe function that does not link
keys together in this way.
We would prefer that the probe sequence for <math>k_1</math>
after the first step on the sequence should not be identical to the
probe sequence of <math>k_2</math>.
Instead, their probe sequences should diverge.</paragraph><paragraph>The ideal probe function would select the next position on the probe
sequence at random from among the unvisited slots; that is, the probe
sequence should be a random permutation of the hash table positions.
Unfortunately, we cannot actually select the next position in the
probe sequence at random, because we would not be able to duplicate
this same probe sequence when searching for the key.
However, we can do something similar called
<title_reference>pseudo-random probing</title_reference>.
In pseudo-random probing, the <math>i</math> th slot in the probe sequence is
<math>(\textbf{h}(K) + r_i) \mod M</math>
where <math>r_i</math> is the <math>i</math> th value in a random permutation
of the numbers from 1 to <math>M-1</math>.
All inserts and searches must use the same sequence of random numbers.
The probe function would be
<math>\textbf{p}(K, i) = \textbf{Permutation}[i]</math>
where <strong>Permutation</strong> is an array of length <math>M</math> that stores a value of
0 in position <strong>Permutation[0]</strong>, and stores a
random permutation of the values from 1 to <math>M - 1</math> in slots 1 to
<math>M - 1</math>.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="collisionCON3"
    long_name="collisionCON3"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Here is a practice exercise for pseudo-random probing.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="HashPseudoRandomPPRO"
    long_name="HashPseudoRandomPPRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><paragraph>Pseudo-random probing exhibits another desirable feature in a hash
function.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="collisionCON4"
    long_name="collisionCON4"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw></section><section ids="quadratic-probing" names="quadratic\ probing"><title>Quadratic Probing</title><paragraph>Another probe function that eliminates
primary clustering is called
<title_reference>quadratic probing</title_reference>.
Here the probe function is some quadratic function
<math>\textbf{p}(K, i) = c_1 i^2 + c_{2}i + c_3</math>
for some choice of constants <math>c_1</math>, <math>c_2</math>,
and  <math>c_3</math>.</paragraph><paragraph>The simplest variation is <math>\textbf{p}(K, i) = i^2</math>
(i.e., <math>c_1 = 1</math>, <math>c_2 = 0</math>, and
<math>c_3 = 0</math>).
Then the <math>i</math> th value in the probe sequence would be
<math>(\textbf{h}(K) + i^2) \mod M</math>.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="collisionCON5"
    long_name="collisionCON5"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Now you can practice quadratic probing.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="HashQuadraticPPRO"
    long_name="HashQuadraticPPRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><paragraph>There is one problem with quadratic probing: Its probe sequence
typically will not visit all slots in the hash table.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="collisionCON6"
    long_name="collisionCON6"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>For many hash table sizes, this probe function will cycle through a
relatively small number of slots.
If all slots on that cycle happen to be full, this means that the
record cannot be inserted at all!
A more realistic example is a table with 105 slots.
The probe sequence starting from any given slot will only visit 23
other slots in the table.
If all 24 of these slots should happen to be full, even if other slots
in the table are empty, then the record cannot be inserted because the
probe sequence will continually hit only those same 24 slots.</paragraph><paragraph>Fortunately, it is possible to get good results from quadratic probing
at low cost.
The right combination of probe function and table size will visit many
slots in the table.
In particular, if the hash table size is a prime number and the probe
function is <math>\textbf{p}(K, i) = i^2</math>,
then at least half the slots in the table will be visited.
Thus, if the table is less than half full, we can be certain that a
free slot will be found.
Alternatively, if the hash table size is a power of two and the probe
function is <math>\textbf{p}(K, i) = (i^2 + i)/2</math>,
then every slot in the table will be visited by the probe function.</paragraph></section><section ids="double-hashing" names="double\ hashing"><title>Double Hashing</title><paragraph>Both pseudo-random probing and quadratic probing eliminate
primary clustering, which is the name given to the the situation when
keys share substantial segments of a probe sequence.
If two keys hash to the same home position, however, then they will always
follow the same probe sequence for every collision resolution method that
we have seen so far.
The probe sequences generated by pseudo-random and
quadratic probing (for example) are entirely a function of the home
position, not the original key value.
This is because function <strong>p</strong> ignores its input parameter
<math>K</math> for these collision resolution methods.
If the hash function generates a cluster at a particular home
position, then the cluster remains under pseudo-random and quadratic
probing.
This problem is called <title_reference>secondary clustering</title_reference>.</paragraph><paragraph>To avoid secondary clustering, we need to have the probe sequence make
use of the original key value in its decision-making process.
A simple technique for doing this is to return to
linear probing by a constant step size
for the probe function, but to
have that constant be determined by a second hash function,
<math>\textbf{h}_2</math>.
Thus, the probe sequence would be of the form
<math>\textbf{p}(K, i) = i * \textbf{h}_2(K)</math>.
This method is called <title_reference>double hashing</title_reference>.</paragraph><paragraph>There are important restrictions on <math>h_2</math>.
Most importantly, the value returned by <math>h_2</math> must never be zero
(or <math>M</math>) because that will immediately lead to an infinite loop
as the probe sequence makes no progress.
However, a good implementation of double hashing should also ensure
that all of the probe sequence constants are relatively
prime to the table size <math>M</math>.
For example, if the hash table size were 100 and the step size for
linear probing (as generated by function <math>h_2</math>) were 50, then
there would be only one slot on the probe sequence.
If instead the hash table size is 101 (a prime number), than any step
size less than 101 will visit every slot in the table.</paragraph><paragraph>This can be achieved easily.
One way is to select <math>M</math> to be a prime number, and have
<math>\textbf{h}_2</math> return a value in the range
<math>1 &lt;= \textbf{h}_2(k) &lt;= M - 1</math>.
We can do this by using this secondary hash function:
<math>\textbf{h}_2(k) = 1 + (k \mod (M-1))</math>.
An alternative is to set <math>M = 2^m</math>
for some value <math>m</math> and have
<math>\textbf{h}_2</math> return an odd value
between 1 and <math>2^m</math>.
We can get that result with this secondary hash function:
<math>\textbf{h}_2(k) = (((k/M) \mod (M/2)) * 2) + 1</math>. <footnote_reference auto="1" ids="id1" refid="id2">1</footnote_reference></paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="collisionCON7"
    long_name="collisionCON7"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><line_block><line></line></line_block><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="collisionCON8"
    long_name="collisionCON8"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Now you can try it.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="HashDoublePPRO"
    long_name="HashDoublePPRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><footnote auto="1" backrefs="id1" ids="id2" names="1"><label>1</label><paragraph>The secondary hash function
<math>\textbf{h}_2(k) = (((k/M) \mod (M/2)) * 2) + 1</math> might
seem rather mysterious, so let's break this down.
This is being used in the context of two facts: (1) We want the
function to return an odd value that is less than <math>M</math> the
hash table size, and (2) we are using a hash table of size
<math>M = 2^m</math>, which means that taking the mod of size
<math>M</math> is using the bottom <math>m</math> bits of the key value.
OK, since <math>\textbf{h}_2</math> is multiplying something by 2 and
adding 1, we guarentee that it is an odd number.
Now, <math>((X \mod (M/2)) * 2) + 1</math> must be in the range 1
and <math>M-1</math> (if you need to, play around with this on paper
to convince yourself that this is true).
This is exactly what we want.
The last piece of the puzzle is the first part <math>k/M</math>.
That is not strictly necessary.
But remember that since the table size is <math>M = 2^m</math>, this
is the same as shifting the key value right by <math>m</math> bits.
In other words, we are not using the bottom <math>m</math> bits to
decide on the second hash function value, which is especially a
good thing if we used the bottom <math>m</math> bits to decide on
the first hash function value!
In other words, we really do not want the value of the step
sized used by the linear probing to be fixed to the slot in the
hash table that we chose.
So we are using the next <math>m</math> bits of the key value
instead.
Note that this would only be a good idea if we have keys in a
large enough key range, that is, we want plenty of use of those
second <math>m</math> bits in the key range.
This will be true if the max key value uses at least <math>2m</math>
bits, meaning that the max key value should be at least the
square of the hash table size.
This is not a problem for typical hashing applications.</paragraph></footnote><raw format="xml" xml:space="preserve"><odsascript>AV/Hashing/collisionCON1.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Hashing/collisionCON2.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Hashing/collisionCON3.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Hashing/collisionCON4.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Hashing/collisionCON5.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Hashing/collisionCON6.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Hashing/collisionCON7.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Hashing/collisionCON8.js</odsascript></raw></section></document>