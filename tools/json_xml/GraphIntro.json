{"document": {"@ids": "graphs-chapter-introduction", "@names": "graphs\\ chapter\\ introduction", "@source": "<string>", "@title": "Graphs Chapter Introduction", "title": "Graphs Chapter Introduction", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Graph/GraphDefCON.css"}], "section": [{"@ids": "graph-terminology", "@names": "graph\\ terminology", "title": "Graph Terminology", "paragraph": ["Graphs provide the ultimate in data structure flexibility.\nA graph consists of a set of nodes, and a set of edges where an\nedge connects two nodes.\nTrees and lists can be viewed as special cases of graphs.", "Graphs are used to model both real-world systems and abstract\nproblems, and are the data structure of choice in many\napplications.\nHere is a small sampling of the types of problems that graphs are\nroutinely used for.", "The rest of this module covers some basic graph terminology.\nThe following modules will describe fundamental representations for\ngraphs, provide a reference implementation, and cover\ncore graph algorithms including traversal, topological sort, shortest\npaths algorithms, and algorithms to find the minimal-cost spanning tree.\nBesides being useful and interesting in their own right, these\nalgorithms illustrate the use of many other data structures presented\nthroughout the course.", {"title_reference": ["graph", "mathbf{G} = (mathbf{V}, mathbf{E})", "vertices <vertex>", "mathbf{V}", "edges <edge>", "mathbf{E}", "mathbf{E}", "mathbf{V}", "|mathbf{V}|", "|mathbf{E}|", "|mathbf{E}|", "|mathbf{V}|^2 - |mathbf{V}|"], "#text": "A   consists\nof a set of   and a set of\n ,\nsuch that each edge in  is a connection between a\npair of vertices in .\nThe number of vertices is written , and the number\nof edges is written .\n can range from zero to a maximum of\n."}, {"title_reference": ["undirected graph", "directed graph", "digraph", "labeled graph", "weight", "weighted graph"], "#text": "A graph whose edges are not directed is called an\n, as shown in part (a) of the following figure.\nA graph with edges directed from one vertex to another\n(as in (b)) is called a  or .\nA graph with labels associated with its vertices\n(as in (c)) is called a .\nAssociated with each edge may be a cost or .\nA graph whose edges have weights\n(as in (c)) is said to be a ."}, {"title_reference": ["a", "b", "(a, b)", "incident", "a", "b", "adjacent", "a", "b", "a", "b", "b", "a", "degree", "e"], "#text": "An edge connecting Vertices  and  is written\n.\nSuch an edge is said to be  with Vertices \nand .\nThe two vertices are said to be .\nIf the edge is directed from  to ,\nthen we say that  is adjacent to ,\nand  is adjacent from .\nThe  of a vertex is the number of edges it is incident\nwith.\nFor example, Vertex  below has a degree of three."}, {"title_reference": ["out degree", "in degree"], "#text": "In a directed graph, the  for a vertex is the number\nof neighbors adjacent from it (or the number of edges going out from\nit), while the  is the number of neighbors adjacent\nto it (or the number of edges coming in to it).\nIn (c) above, the in degree of Vertex 1 is two,\nand its out degree is one."}, {"title_reference": ["v_1, v_2, ..., v_n", "path", "n-1", "v_i", "v_{i+1}", "1 leq i < n", "simple path", "length", "cycle", "v_1", "simple cycle"], "#text": "A sequence of vertices \nforms a  of length  if there exist edges from\n to  for .\nA path is a  if all vertices on the path are\ndistinct.\nThe  of a path is the number of edges it contains.\nA  is a path of length three or more that connects\nsome vertex  to itself.\nA cycle is a  if the path is simple, except for\nthe first and last vertices being the same."}, {"title_reference": ["connected graph", "connected components <connected component>"], "#text": "An undirected graph is a  if there is at least\none path from any vertex to any other.\nThe maximally connected subgraphs of an undirected graph are called\n.\nFor example, this figure shows an undirected graph\nwith three connected components."}, {"title_reference": ["sparse graph", "dense graph", "complete graph", "subgraph", "mathbf{S}", "mathbf{G}", "mathbf{V}_s", "mathbf{G}", "mathbf{E}_s", "mathbf{G}", "e  in mathbf{E}_s", "e", "mathbf{V}_s", "V", "clique"], "#text": "A graph with relatively few edges is called a ,\nwhile a graph with many edges is called a .\nA graph containing all possible edges is said to be a\n.\nA   is formed from graph\n by selecting a subset  of\n's vertices and a subset\n of  's edges such that for every\nedge ,\nboth vertices of  are in .\nAny subgraph of  where all vertices in the graph connect to\nall other vertices in the subgraph is called a ."}, {"title_reference": ["acyclic graph", "directed acyclic graph", "DAG"], "#text": "A graph without cycles is called an .\nThus, a directed graph without cycles is called a\n or ."}, {"title_reference": ["free tree", "|mathbf{V}| - 1"], "#text": "A  is a connected, undirected graph with no simple\ncycles.\nAn equivalent definition is that\na free tree is connected and has  edges."}], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Modeling connectivity in computer and communications networks."}, {"paragraph": "Representing an abstract map as a set of locations with distances\nbetween locations. This can used to compute shortest routes between\nlocations such as in a GPS routefinder."}, {"paragraph": "Modeling flow capacities in transportation networks to find which\nlinks create the bottlenecks."}, {"paragraph": "Finding a path from a starting condition to a goal condition.\nThis is a common way to model problems in artificial intelligence\napplications and computerized game players."}, {"paragraph": "Modeling computer algorithms, to show transitions from one program\nstate to another."}, {"paragraph": "Finding an acceptable order for finishing subtasks in a complex\nactivity, such as constructing large buildings."}, {"paragraph": "Modeling relationships such as family trees, business or military\norganizations, and scientific taxonomies."}]}, "footnote": {"@auto": "1", "@ids": "id1", "@names": "1", "label": "1", "paragraph": "Some graph applications require that a given pair of vertices\ncan have multiple or parallel edges connecting them, or that a\nvertex can have an edge to itself.\nHowever, the applications discussed here do not require\neither of these special cases.\nTo simplify our graph API, we will assume that there are no\ndupicate edges, and no edges that connect a node to itself."}, "target": [{"@refid": "graphterms"}, {"@refid": "concom"}], "raw": [{"@format": "xml", "@ids": "graphterms", "@names": "graphterms", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "GdirundirCON", "@long_name": "GdirundirCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "GneighborCON", "@long_name": "GneighborCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "GpathDefCON", "@long_name": "GpathDefCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@ids": "concom", "@names": "concom", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "GconcomCON", "@long_name": "GconcomCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "GsparseDefCON", "@long_name": "GsparseDefCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}]}, {"@ids": "graph-representations", "@names": "graph\\ representations", "title": "Graph Representations", "paragraph": [{"title_reference": ["adjacency matrix", "|mathbf{V}| times |mathbf{V}|", "v_0", "v_{|mathbf{V}|-1}", "i", "v_i", "j", "i", "v_i", "v_j", "Theta(|mathbf{V}|^2)"], "#text": "There are two commonly used methods for representing graphs.\nThe  for a graph is a\n array.\nWe typically label the vertices from  through\n.\nRow  of the adjacency matrix contains entries for\nVertex .\nColumn  in row  is marked if there is an edge\nfrom  to  and is not marked otherwise.\nThe space requirements for the adjacency matrix are\n."}, {"title_reference": ["adjacency list", "|mathbf{V}|", "i", "v_i", "v_i"], "#text": "The second common representation for graphs is the\n.\nThe adjacency list is an array of linked lists.\nThe array is  items long, with position \nstoring a pointer to the linked list of edges for Vertex .\nThis linked list represents the edges by the vertices that are\nadjacent to Vertex ."}, "Here is an example of the two representations on a directed graph.\nThe entry for Vertex 0 stores 1 and 4 because there are two edges\nin the graph leaving Vertex 0, with one going to Vertex 1 and one\ngoing to Vertex 4.\nThe list for Vertex 2 stores an entry for Vertex 4 because there is\nan edge from Vertex 2 to Vertex 4, but no entry for Vertex 3\nbecause this edge comes into Vertex 2 rather than going out.", {"title_reference": ["u", "v", "u", "v", "v", "u"], "#text": "Both the adjacency matrix and the adjacency list can be used to store\ndirected or undirected graphs.\nEach edge of an undirected graph connecting Vertices \nand  is represented by two directed edges: one from\n to  and one from  to .\nHere is an example of the two representations on an undirected graph.\nWe see that there are twice as many edge entries in both the adjacency\nmatrix and the adjacency list.\nFor example, for the undirected graph, the list for Vertex 2 stores an\nentry for both Vertex 3 and Vertex 4."}, {"title_reference": "Theta(|mathbf{V}| + |mathbf{E}|)", "#text": "The storage requirements for the adjacency list depend on both the\nnumber of edges and the number of vertices in the graph.\nThere must be an array entry for each vertex (even if the vertex is\nnot adjacent to any other vertex and thus has no elements on its\nlinked list), and each edge must appear on one of the lists.\nThus, the cost is ."}, {"title_reference": ["Figure #GraphTerms", "Figure #Directed", "Figure #Undirected"], "#text": "Sometimes we want to store weights or distances with each each edge,\nsuch as in Figure  (c).\nThis is easy with the adjacency matrix, where we will just store\nvalues for the weights in the matrix.\nIn Figures  and  we\nstore a value of \"1\" at each position just to show that the edge\nexists.\nThat could have been done using a single bit, but since bit\nmanipulation is typically complicated in most programming languages,\nan implementation might store a byte or an integer at each matrix\nposition.\nFor a weighted graph, we would need to store at each position in the\nmatrix enough space to represent the weight, which might typically be\nan integer."}, "The adjacency list needs to explicitly store a weight with each edge.\nIn the adjacency list shown below, each linked list node is shown\nstoring two values.\nThe first is the index for the neighbor at the end of the associated\nedge.\nThe second is the value for the weight.\nAs with the adjacency matrix, this value requires space to represent,\ntypically an integer.", "Which graph representation is more space efficient depends on the\nnumber of edges in the graph.\nThe adjacency list stores information only for those edges that\nactually appear in the graph, while the adjacency matrix requires\nspace for each potential edge, whether it exists or not.\nHowever, the adjacency matrix requires no overhead for pointers,\nwhich can be a substantial cost, especially if the only information\nstored for an edge is one bit to indicate its existence.\nAs the graph becomes denser, the adjacency matrix becomes\nrelatively more space efficient.\nSparse graphs are likely to have their adjacency list representation\nbe more space efficient.", {"title_reference": ["|mathbf{V}|", "Theta(|mathbf{V}^2|)", "Theta(|mathbf{V}| + |mathbf{E}|)"], "#text": "The adjacency matrix often requires a higher asymptotic cost for an\nalgorithm than would result if the adjacency list were used.\nThe reason is that it is common for a graph algorithm\nto visit each neighbor of each vertex.\nUsing the adjacency list, only the actual edges connecting a vertex to\nits neighbors are examined.\nHowever, the adjacency matrix must look at each of its\n\npotential edges, yielding a total cost of\n\ntime when the algorithm might otherwise require only\n time.\nThis is a considerable disadvantage when the graph is sparse,\nbut not when the graph is closer to full."}], "target": [{"@refid": "directed"}, {"@refid": "undirected"}], "raw": [{"@format": "xml", "@ids": "directed", "@names": "directed", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "GdirRepCON", "@long_name": "GdirRepCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@ids": "undirected", "@names": "undirected", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "GundirRepCON", "@long_name": "GundirRepCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "GweightedCON", "@long_name": "GweightedCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "GspaceCalcSumm", "@long_name": "GspaceCalcSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}], "topic": {"title": "Example", "paragraph": {"title_reference": ["2 |mathbf{V}^2| = 50", "4 |mathbf{V}| + 6 |mathbf{E}| = 56", "4 |mathbf{V}| + 6 |mathbf{E}| = 92"], "#text": "Assume that a vertex index requires two bytes, a pointer requires\nfour bytes, and an edge weight requires two bytes.\nThen the adjacency matrix for the directed graph above\nrequires  bytes while the adjacency list\nrequires  bytes.\nFor the undirected version of the graph above, the adjacency\nmatrix requires the same space as before, while the adjacency list\nrequires  bytes\n(because there are now 12 edges represented instead of 6)."}}}, {"@ids": "graph-terminology-questions", "@names": "graph\\ terminology\\ questions", "title": "Graph Terminology Questions", "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "GraphIntroSumm", "@long_name": "GraphIntroSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Graph/GdirundirCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Graph/GneighborCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Graph/GpathDefCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Graph/GconcomCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Graph/GsparseDefCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Graph/GdirRepCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Graph/GundirRepCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Graph/GweightedCON.js"}]}]}}