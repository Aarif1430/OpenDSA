{"document": {"@dupnames": "abstract\\ data\\ types", "@ids": "abstract-data-types", "@source": "<string>", "@title": "Abstract Data Types", "title": "Abstract Data Types", "subtitle": {"@dupnames": "abstract\\ data\\ types", "@ids": "id1", "#text": "Abstract Data Types"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Design/ADTCON.css"}, {"@format": "xml", "@ids": "datatype", "@names": "datatype", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "ADTCON", "@long_name": "ADTCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "IntroADTSumm", "@long_name": "IntroADTSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Design/ADTCON.js"}], "paragraph": [{"title_reference": ["data item", "data structure"], "#text": "This module presents terminology and definitions related to techniques\nfor managing the tremendous complexity of computer programs.\nIt also presents working definitions for the fundamental but somewhat\nslippery terms \"\" and \"\".\nWe begin with the basic elements on which data structures are built."}, {"title_reference": ["type", "simple type", "aggregate type", "composite type", "data item", "member"], "literal": ["true", "false"], "#text": "A  is a collection of values.\nFor example, the Boolean type consists of the values  and\n.\nThe integers also form a type.\nAn integer is a \nbecause its values contain no subparts.\nA bank account record will typically contain several pieces of\ninformation such as name, address, account number, and account\nbalance.\nSuch a record is an example of an  or\n.\nA  is a piece of information\nor a record whose value is drawn from a type.\nA data item is said to be a  of a type."}, {"title_reference": "data type", "#text": "A  is a type together with a collection of operations\nto manipulate the type.\nFor example, an integer variable is a member of the integer data\ntype.\nAddition is an example of an operation on the integer data type."}, {"title_reference": "graph data structure <graph> <GraphImpl>", "#text": "A distinction should be made between the\nlogical concept of a data type and its physical implementation in a\ncomputer program.\nFor example, there are two traditional implementations\nfor the list data type:\nthe linked list and the array-based list.\nThe list data type can therefore be implemented using a linked list or\nan array.\nBut we don't need to know how the list is implemented when we wish to\nuse a list to help in a more complex design.\nFor example, a list might be used to help implement a\n."}, {"title_reference": ["sparse matrix <sparse matrix> <SparseMatrix>", "hash table <hash table> <HashIntro>"], "#text": "As another example, the term \"array\" could refer either\nto a data type or an implementation.\n\"Array\" is commonly used in computer programming to mean a\ncontiguous block of memory locations,\nwhere each memory location stores one fixed-length data item.\nBy this meaning, an array is a physical data structure.\nHowever, array can also mean a logical data type composed of a\n(typically homogeneous) collection of data items, with each data item\nidentified by an index number.\nIt is possible to implement arrays in many different ways besides as a\nblock of contiguous memory locations.\nThe \nrefers to a large, two-dimensional array\nthat stores only a relatively few non-zero values.\nThis is often implemented with a linked structure, or possibly using a\n.\nBut it could be implemented with an interface that uses traditional\nrow and column indices, thus appearing to the user in the same way\nthat it would if it had been implemented as a block of contiguous\nmemory locations."}, {"title_reference": ["abstract data type", "encapsulation"], "emphasis": "how", "#text": "An  (ADT) is the specification of a data type\nwithin some language, independent of an implementation.\nThe interface for the ADT is defined in terms of a type and a set of\noperations on that type.\nThe behavior of each operation is determined by its inputs and outputs.\nAn ADT does not specify  the data type is implemented.\nThese implementation details are hidden from the user of the ADT and\nprotected from outside access, a concept referred to as\n."}, {"title_reference": ["data structure", "class", "member function", "method", "data members <data member>", "object"], "#text": "A  is the implementation for an ADT.\nIn an object-oriented language,\nan ADT and its implementation together make up a .\nEach operation associated with the ADT is implemented by a\n or .\nThe variables that define the space required by a data item are\nreferred to as .\nAn  is an instance of a class, that is, something that\nis created and takes up storage during the execution of a\ncomputer program."}, {"title_reference": ["data structure", "file structure"], "#text": "The term  often refers to data\nstored in a computer's main memory.\nThe related term  \noften refers to the organization of data on peripheral storage, such\nas a disk drive or CD."}, "One application that makes use of some ADT might use particular\nmember functions of that ADT more than a second application, or the\ntwo applications might have different time requirements for the\nvarious operations.\nThese differences in the requirements of applications are the reason\nwhy a given ADT might be supported by more than one implementation.", "The concept of an ADT can help us to focus on key issues even in\nnon-computing applications.", {"title_reference": "metaphor", "#text": "The concept of an ADT is one instance of an\nimportant principle that must be understood by any successful\ncomputer scientist: managing complexity through\nabstraction.\nA central theme of computer science is complexity and\ntechniques for handling it.\nHumans deal with complexity by assigning a label to an assembly of\nobjects or concepts and then manipulating the label in place of the\nassembly.\nCognitive psychologists call such a label a\n.\nA particular label might be related to other pieces of information or\nother labels.\nThis collection can in turn be given a label,\nforming a hierarchy of concepts and labels.\nThis hierarchy of labels allows us to focus on\nimportant issues while ignoring unnecessary details."}, "Consider how you might go about the process of designing a complex\ncomputer program that implements and manipulates an ADT.\nThe ADT is implemented in one part\nof the program by a particular data structure.\nWhile designing those parts of the program that use the ADT,\nyou can think in terms of operations on the data type without\nconcern for the data structure's implementation.\nWithout this ability to simplify your thinking about a complex\nprogram, you would have no hope of understanding or implementing it.", {"title_reference": ["logical form", "physical form"], "emphasis": "concrete implementation", "#text": "Data types have both a  and a .\nThe definition of the data type in terms of an ADT is its logical\nform.\nThe implementation of the data type as a data structure\nis its physical form.\nSometimes you might see the term ,\nbut the word concrete is redundant.\nThe figure below illustrates this relationship between logical\nand physical forms for data types.\nWhen you implement an ADT, you are dealing with the physical form of\nthe associated data type.\nWhen you use an ADT elsewhere in your program, you are concerned with\nthe associated data type's logical form.\nSome sections of this book focus on physical\nimplementations for a given data structure.\nOther sections use the logical ADT for the data structure in the\ncontext of a higher-level task."}, "The ADT defines the logical form of the data type.\nThe data structure implements the physical form of the data type.\nUsers of an ADT are typically programmers working in the same language\nas the implementer of the ADT.\nTypically, these programmers want to use the ADT as a component\nin another application.\nThe interface to an ADT is also commonly referred to as the\nApplication Programmer Interface, or API, for the ADT.\nThe interface becomes a form of communication between the two programmers."], "topic": [{"title": "Example", "paragraph": {"literal": ["int", "int", "int", "int", "int"], "#text": "The mathematical concept of an integer, along with operations\nthat manipulate integers, form a data type.\nThe  variable type is a physical representation of\nthe abstract integer.\nThe  variable type, along with the operations that act on an\n variable, form an ADT.\nUnfortunately, the  implementation is not\ncompletely true to the abstract integer, as there are limitations on\nthe range of values an  variable can store.\nIf these limitations prove unacceptable, then some other\nrepresentation for the ADT \"integer\" must be devised, and a new\nimplementation must be used for the associated operations."}}, {"title": "Example", "paragraph": ["An ADT for a list of integers might specify the following operations:", "From this description, the input and output of each operation should\nbe clear, but the implementation for lists has not been\nspecified."], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Insert a new integer at a particular position in the list."}, {"paragraph": {"literal": "True", "#text": "Return  if the list is empty."}}, {"paragraph": "Reinitialize the list."}, {"paragraph": "Return the number of integers currently in the list."}, {"paragraph": "Delete the integer at a particular position in the list."}]}}, {"title": "Example", "paragraph": {"title_reference": ["hashing <hashing> <HashIntro>", "B-tree <B-tree> <BTree>"], "#text": "Two popular implementations for large disk-based\ndatabase applications are \nand the .\nBoth support efficient insertion and deletion of records, and both\nsupport exact-match queries.\nHowever, hashing is more efficient than the B-tree for\nexact-match queries.\nOn the other hand, the B-tree can perform range queries\nefficiently, while hashing is hopelessly inefficient for\nrange queries.\nThus, if the database application limits searches to exact-match\nqueries, hashing is preferred.\nOn the other hand, if the application requires support for range\nqueries, the B-tree is preferred.\nDespite these performance issues, both implementations solve\nversions of the same problem: updating and searching a large\ncollection of records."}}, {"title": "Example", "paragraph": "When operating a car, the primary activities are steering,\naccelerating, and braking.\nOn nearly all passenger cars, you steer by turning the steering\nwheel, accelerate by pushing the gas pedal, and brake by pushing\nthe brake pedal.\nThis design for cars can be viewed as an ADT with operations\n\"steer\", \"accelerate\", and \"brake\".\nTwo cars might implement these operations in radically different\nways, say with different types of engine, or front- versus\nrear-wheel drive.\nYet, most drivers can operate many different cars because the ADT\npresents a uniform method of operation that does not require the\ndriver to understand the specifics of any particular engine or\ndrive design.\nThese differences are deliberately hidden."}, {"title": "Example", "paragraph": "We apply the label \"hard drive\" to a collection of\nhardware that manipulates data on a particular type of\nstorage device, and we apply the label \"CPU\" to the hardware that\ncontrols execution of computer instructions.\nThese and other labels are gathered together under the label\n\"computer\".\nBecause even the smallest home computers today have millions of\ncomponents, some form of abstraction is necessary to comprehend how\na computer operates."}, {"title": "Example", "paragraph": {"title_reference": ["buffer pool <buffer pool> <BuffPool>", "memory manager <memory manager> <MemmanIntro>", "index structures <indexing> <IndexIntro>", "search keys <search key>"], "#text": "Consider the design for a relatively simple database system stored\non disk.\nTypically, records on disk in such a program are accessed through a\n rather than directly.\nVariable length records might use a\n to find an\nappropriate location within the disk file to place the record.\nMultiple \nwill typically be used to support access to a collection of records\nusing multiple .\nThus, we have a chain of classes, each with its own responsibilities\nand access privileges.\nA database query from a user is implemented by searching an index\nstructure.\nThis index requests access to the record by means of a request to\nthe buffer pool.\nIf a record is being inserted or deleted, such a request goes\nthrough the memory manager, which in turn interacts with the buffer\npool to gain access to the disk file.\nA program such as this is far too complex for nearly any human\nprogrammer to keep all of the details in his or her head at once.\nThe only way to design and implement such a program is through\nproper use of abstraction and metaphors.\nIn object-oriented programming,\nsuch abstraction is handled using classes."}}, {"title": "Example", "paragraph": {"title_reference": "list", "#text": "A particular programming environment might provide a library that\nincludes a  class.\nThe logical form of the list is defined by the public\nfunctions, their inputs, and their outputs that define the class.\nThis might be all that you know about the list class implementation,\nand this should be all you need to know.\nWithin the class, a variety of physical implementations for lists\nis possible."}}], "target": {"@refid": "datatype"}}}