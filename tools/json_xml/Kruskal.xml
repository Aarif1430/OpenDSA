<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="kruskal's\ algorithm" ids="kruskal-s-algorithm" source="&lt;string&gt;" title="Kruskal's Algorithm"><title>Kruskal's Algorithm</title><subtitle dupnames="kruskal's\ algorithm" ids="id1">Kruskal's Algorithm</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>Our next MCST algorithm is commonly referred to as
<title_reference>Kruskal's algorithm</title_reference>.
Kruskal's algorithm is also a simple, greedy algorithm.
First partition the set of vertices into <title_reference>|mathbf{V}|</title_reference>
<title_reference>disjoint sets &lt;UNION/FIND&gt; &lt;UnionFind&gt;</title_reference>,
each consisting of one vertex.
Then process the edges in order of weight.
An edge is added to the MCST, and two disjoint sets combined,
if the edge connects two vertices in different disjoint sets.
This process is repeated until only one disjoint set remains.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="KruskalUFAV"
    long_name="KruskalUFAV"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>The edges can be processed in order of weight by using a
min-heap.
This is generally faster than sorting the edges first, because in
practice we need only visit a small fraction of the edges before
completing the MCST.
This is an example of finding only a
<title_reference>few smallest elements &lt;HeapSort&gt;</title_reference> in a list.</paragraph><paragraph>The only tricky part to this algorithm is determining if two vertices
belong to the same equivalence class.
Fortunately, the ideal algorithm is available for the purpose ---
the <title_reference>UNION/FIND &lt;UNION/FIND&gt; &lt;UnionFind&gt;</title_reference>.
Here is an implementation for Kruskal's algorithm.
Class <literal>KruskalElem</literal> is used to store the edges on the min-heap.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>Kruskal's algorithm is dominated by the time required to
process the edges.
The <literal>differ</literal> and <literal>UNION</literal> functions are nearly
constant in time if path compression and weighted union is used.
Thus, the total cost of the algorithm is
<title_reference>Theta(|mathbf{E}| log |mathbf{E}|)</title_reference> in the worst case,
when nearly all edges must be processed before all the edges of the
spanning tree are found and the algorithm can stop.
More often the edges of the spanning tree are the shorter ones,and
only about <title_reference>|mathbf{V}|</title_reference> edges must be processed.
If so, the cost is often close to
<title_reference>Theta(|mathbf{V}| log |mathbf{E}|)</title_reference> in the average case.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="pe"
    exer_name="KruskalPE"
    long_name="KruskalPE"
    points="1.0"
    required="True"
    threshold="0.9">
</avembed>
</raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Development/MCSTCON.js</odsascript></raw></document>