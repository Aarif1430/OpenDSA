<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="grammars-part-1" names="grammars\ -\ part\ 1" source="&lt;string&gt;" title="Grammars - Part 1"><title>Grammars - Part 1</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-13 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/PL/AV/parseTree.css</odsalink></raw><raw format="xml" xml:space="preserve"><odsalink>AV/PL/main.css</odsalink></raw><comment xml:space="preserve">(M 2/1/16)</comment><section ids="rp-1-part-1" names="rp\ 1\ part\ 1"><title>RP 1 part 1</title><paragraph>Topics in this module:</paragraph><block_quote><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>Terminology of grammars</paragraph></list_item><list_item><paragraph>Derivations and parse trees</paragraph></list_item></enumerated_list></block_quote><paragraph>Grammars provide a formalism for expressing the syntax of programming
languages.  That syntax is consequently used to parse, that is,
determine the correctness, of a "program" in the language.  A grammar
is composed of the following three elements.</paragraph><block_quote><bullet_list bullet="*"><list_item><paragraph>A set of terminals.  These terminals represent the tokens --
characters, or groups of characters that logically belong
together, such as operator symbols, delimiters, keywords, variable
names -- that ultimately comprise the program or expression being
parsed. In the case of algebraic expressions, the terminals would
be variables, numeric constants, parentheses, and the various
operators that are allowed.</paragraph></list_item><list_item><paragraph>A set of non-terminals.  These non-terminals represent the various
grammatical constructs within the language we are parsing. In
particular, one non-terminal is designated as the start symbol for
the grammar.</paragraph></list_item><list_item><paragraph>A set of productions.  The productions are formal rules defining
the syntactical composition of the non-terminals from the
previous point. The productions take the form:</paragraph></list_item></bullet_list></block_quote><math_block xml:space="preserve">\begin{eqnarray*}
&lt;nonterminal&gt; &amp;::=&amp; String \; of \; terminals \; and/or \; nonterminals\\
\end{eqnarray*}</math_block><paragraph>We say that the non-terminal on the left of such a production <emphasis>derives</emphasis> the string on the right.</paragraph><paragraph>An example of a context-free grammar should help to clarify this three-part definition.   By convention the non-terminal on the left of the first production is the start symbol, and that is what ultimately must be parsed to have a complete expression in the language.   Hence in the example below, <math>&lt;exp&gt;</math> is the start symbol.</paragraph><target refid="eg1"></target><section ids="example-grammar-1 eg1" names="example\ grammar\ 1 eg1"><title>Example Grammar 1</title><math_block xml:space="preserve">\begin{eqnarray*}
&lt;exp&gt; &amp;::=&amp; &lt;trm&gt;\\
&amp;|&amp; &lt;exp&gt; + &lt;trm&gt; \\
&amp;|&amp; &lt;exp&gt; - &lt;trm&gt; \\
&amp;|&amp; &lt;exp&gt; * &lt;trm&gt; \\
&amp;|&amp; &lt;exp&gt; / &lt;trm&gt; \\
&lt;trm&gt; &amp;::=&amp; &lt;pri&gt; \\
&amp;|&amp; ( &lt;exp&gt; ) \\
&lt;pri&gt; &amp;:==&amp; A | B | C | \ldots | X | Y | Z
\end{eqnarray*}</math_block><paragraph>This is essentially a grammar for algebraic expressions with variables
(that is, the <math>&lt;pri&gt;</math> non-terminal) allowed to be a single upper-case
letter.  When reading a grammar, the vertical bar <math>|</math> means
"or".  Hence <math>&lt;pri&gt;</math> can be A or B or C ...  The <math>&lt;trm&gt;</math>
non-terminal must either be a <math>&lt;pri&gt;</math> or a parenthesized
<math>&lt;exp&gt;</math>.  A derivation of the expression <math>A + B * C</math>
according to this grammar proceeds as illustrated in the following
slide show, with the final result being a <emphasis>parse tree</emphasis>.  You should step
through all the slides, making sure that at each step you understand
the production that is being applied to "grow" the parse tree.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="parseTree4"
    long_name="parseTree4"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Note that, in a complete parse tree, leaf nodes are always terminals,
and a traversal of the tree that would output these leaf nodes
would reproduce the expression being parsed.  This is indicated by the red
highlighting in the above slide-show.</paragraph><paragraph>The following set of four review problems for this module should be completed before you go on.   In these review problems, the symbol <math>\epsilon</math> is used to represent the <emphasis>empty production</emphasis>.   When <math>\epsilon</math> appears on the right of a production, it means that one of the possibilities for the non-terminal on the left side of the production is for it to derive the empty string, that is, the string with no characters.  This is typically used when the syntax for the language being parsed allows the option of the non-terminal not appearing at all.   Often with productions that are recursive, it provides a way for the recursion to bottom out -- similar to the way a recursive termination condition would work in a recursive algorithm.</paragraph><paragraph>The first problem is about building a parse tree given a grammar and a string.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP1part1"
    long_name="RP1part1"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section></section><section ids="rp-1-part-2" names="rp\ 1\ part\ 2"><title>RP 1 part 2</title><paragraph>This problem is about determining whether a given string can be
generated by a given grammar.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP1part2"
    long_name="RP1part2"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="rp-1-part-3" names="rp\ 1\ part\ 3"><title>RP 1 part 3</title><paragraph>This problem is about identifying properties of all of the strings in
a language defined by a given grammar.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP1part3"
    long_name="RP1part3"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="rp-1-part-4" names="rp\ 1\ part\ 4"><title>RP 1 part 4</title><paragraph>This problem is about precisely characterizing the whole language
generated by a given grammar.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP1part4"
    long_name="RP1part4"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/PL/AV/parseTree4.js</odsascript></raw></section></document>