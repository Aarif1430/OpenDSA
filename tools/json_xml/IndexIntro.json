{"document": {"@ids": "indexing-chapter-introduction", "@names": "indexing\\ chapter\\ introduction", "@source": "<string>", "@title": "Indexing Chapter Introduction", "title": "Indexing Chapter Introduction", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "paragraph": [{"math": "K", "#text": "Many large-scale computing applications are centered around data sets\nthat are too large to fit into main memory.\nThe classic example is a large database of records with multiple\nsearch keys, requiring the ability to insert, delete, and search for\nrecords.\nHashing provides outstanding performance for such\nsituations, but only in the limited case in which all searches are of\nthe form \"find the record with key value \".\nMany applications require more general search capabilities.\nOne example is a range query\nsearch for all records whose key lies within some range.\nOther queries might involve visiting all records in order of their key\nvalue, or finding the record with the greatest key value.\nHash tables are not organized to support any of these queries\nefficiently."}, "This chapter introduces file structures used to organize a large\ncollection of records stored on disk.\nSuch file structures support efficient insertion,\ndeletion, and search operations, for exact-match queries, range\nqueries, and largest/smallest key value searches.", {"title_reference": "entry-sequenced file", "#text": "Before discussing such file structures, we must become familiar\nwith some basic file-processing terminology.\nAn \nstores records in the order that they were added to the file.\nEntry-sequenced files are the disk-based equivalent to an unsorted\nlist and so do not support efficient search.\nThe natural solution is to sort the records by order of the search key.\nHowever, a typical database, such as a collection of employee or\ncustomer records maintained by a business, might contain multiple\nsearch keys.\nTo answer a question about a particular customer might require a\nsearch on the name of the customer.\nBusinesses often wish to sort and output the records by\nzip code order for a bulk mailing.\nGovernment paperwork might require the ability to search by\nSocial Security number.\nThus, there might not be a single \"correct\" order in which to store\nthe records."}, {"title_reference": ["Indexing", "external sort <external sort> <ExternalSort>", "index file"], "#text": "is the process of associating a key with the location\nof a corresponding data record.\nAn  typically uses\nthe concept of a key sort, in which an  is created whose\nrecords consist of key/pointer pairs.\nHere, each key is associated with a pointer to a complete record in\nthe main database file.\nThe index file could be sorted or organized using a tree structure,\nthereby imposing a logical order on the records without\nphysically rearranging them.\nOne database might have several associated index files,\neach supporting efficient access through a different key field."}, {"title_reference": "primary key", "#text": "Each record of a database normally has a unique identifier,\ncalled the .\nFor example, the primary key for a set of personnel records might be\nthe Social Security number or ID number for the individual.\nUnfortunately, the ID number is generally an inconvenient value on\nwhich to perform a search because the searcher is unlikely to know it.\nInstead, the searcher might know the desired employee's name.\nAlternatively, the searcher might be interested in finding all\nemployees whose salary is in a certain range.\nIf these are typical search requests to the database, then the name\nand salary fields deserve separate indices.\nHowever, key values in the name and salary indices are not likely to\nbe unique."}, {"title_reference": ["secondary key", "secondary key index", "secondary index", "primary key index", "primary index"], "#text": "A key field such as salary, where a particular key value might be\nduplicated in multiple records, is called a\n.\nMost searches are performed using a secondary key.\nThe  (or more simply, )\nwill associate a secondary key value with the primary key of each\nrecord having that secondary key value.\nAt this point, the full database might be searched directly for the\nrecord with that primary key, or there might be a \n(or )\nthat relates each primary key value with a pointer to the\nactual record on disk.\nIn the latter case, only the primary index provides the\nlocation of the actual record on disk, while the secondary indices\nrefer to the primary index."}, {"title_reference": "Hashing", "#text": "Indexing is an important technique for organizing large databases,\nand many indexing methods have been developed.\nDirect access through hashing is discussed in\nChapter .\nA simple list sorted by key\nvalue can also serve as an index to the record file.\nIndexing disk files by sorted lists are discussed in the following\nsection.\nUnfortunately, a sorted list does not perform well for insert\nand delete operations."}, {"title_reference": ["ISAM <ISAM> <ISAM>", "TreeIndexing <TreeIndexing> <TreeIndexing>", "2-3 tree <2-3 tree> <TwoThreeTree>", "B-tree <B-tree> <BTree>"], "#text": "A third approach to indexing is the tree index.\nTrees are typically used to organize large databases that must support\nrecord insertion, deletion, and\nkey range searches.\n was a\na tentative step toward solving the problem of storing a large\ndatabase that must support insertion and deletion of records.\nIts shortcomings help to illustrate the value of tree indexing\ntechniques.\nModule \nintroduces the basic issues related to tree indexing.\nModule  introduces the 2-3\ntree, a balanced tree structure that is a simple form of the\n.\nB-trees are the most widely used indexing method for large disk-based\ndatabases, and for implementing file systems."}]}}