{"document": {"@dupnames": "shortest-paths\\ problems", "@ids": "shortest-paths-problems", "@source": "<string>", "@title": "Shortest-Paths Problems", "title": "Shortest-Paths Problems", "subtitle": {"@dupnames": "shortest-paths\\ problems", "@ids": "id1", "#text": "Shortest-Paths Problems"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@ids": "distexamp", "@names": "distexamp", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "dijkstraCON", "@long_name": "dijkstraCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}], "paragraph": [{"title_reference": ["weights <weight>", "costs <cost>", "distances <distance>"], "#text": "On a road map, a road connecting two towns is typically\nlabeled with its distance.\nWe can model a road network as a directed graph whose edges are\nlabeled with real numbers.\nThese numbers represent the distance (or other cost metric, such as\ntravel time) between two vertices.\nThese labels may be called ,\n, or ,\ndepending on the application.\nGiven such a graph, a typical problem is to find the total\nlength of the shortest path between two specified vertices.\nThis is not a trivial problem, because the shortest path may not be\nalong the edge (if any) connecting two vertices, but rather may be\nalong a path involving one or more intermediate vertices."}, {"title_reference": ["Figure #DistExamp", "A", "B", "D", "A", "D", "A", "C", "B", "D", "A", "D", "A", "D", "mathbf{d}(A, D) = 10", "A", "D", "Figure #DistExamp", "E", "B", "mathbf{d}(E, B) = infty", "mathbf{w}(A, D) = 20", "(A, D)", "A", "D", "E", "B", "mathbf{w}(E, B) = infty", "mathbf{w}(D, A) = infty", "Figure #DistExamp"], "#text": "For example, in Figure ,\nthe cost of the path from  to  to  is 15.\nThe cost of the edge directly from  to  is 20.\nThe cost of the path from  to  to  to\n is 10.\nThus, the shortest path from  to  is 10\n(rather than along the edge connecting  to ).\nWe use the notation  to indicate that the\nshortest distance from  to  is 10.\nIn Figure , there is no path from  to\n, so we set .\nWe define  to be the weight of edge\n, that is, the weight of the direct connection\nfrom  to .\nBecause there is no edge from  to ,\n.\nNote that  because the graph of\nFigure  is directed.\nWe assume that all weights are positive."}], "target": {"@refid": "distexamp"}, "section": {"@ids": "single-source-shortest-paths", "@names": "single-source\\ shortest\\ paths", "title": "Single-Source Shortest Paths", "paragraph": [{"title_reference": ["single-source shortest paths problem", "S", "mathbf{G}", "S", "mathbf{G}", "S", "T", "S", "T", "S"], "#text": "We will now present an algorithm to solve the\n.\nGiven Vertex  in Graph ,\nfind a shortest path from  to every other vertex in\n.\nWe might want only the shortest path between two vertices,\n and .\nHowever in the worst case, finding the shortest path from\n to  requires us to find the shortest paths from\n to every other vertex as well.\nSo there is no better algorithm (in the worst case) for\nfinding the shortest path to a single vertex than to find shortest\npaths to all vertices.\nThe algorithm described here will only compute the distance to every\nsuch vertex, rather than recording the actual path.\nRecording the path requires only simple modifications to the algorithm."}, "Computer networks provide an application for the single-source\nshortest-paths problem.\nThe goal is to find the cheapest way for one computer to broadcast\na message to all other computers on the network.\nThe network can be modeled by a graph with edge weights indicating\ntime or\ncost to send a message to a neighboring computer.", "For unweighted graphs (or whenever all edges have the same cost), the\nsingle-source shortest paths can be found using a simple breadth-first\nsearch.\nWhen weights are added, BFS will not give the correct answer.", {"title_reference": ["v_0", "v_{n-1}", "S = v_0", "v_1", "v_0", "v_1", "v_2", "v_0", "v_2", "v_0", "v_1", "v_2", "v_i", "v_0", "v_{i-1}", "v_i", "v_j", "j > i", "S", "S", "i-1", "S", "mathbf{S}", "i", "X"], "#text": "One approach to solving this problem when the edges have\ndiffering weights might be to process the\nvertices in a fixed order.\nLabel the vertices  to , with\n.\nWhen processing Vertex , we take the edge connecting\n and .\nWhen processing , we consider the shortest distance from\n to  and compare that to the shortest\ndistance from  to  to .\nWhen processing Vertex , we consider the shortest\npath for Vertices  through  that have\nalready been processed.\nUnfortunately, the true shortest path to  might go\nthrough Vertex  for .\nSuch a path will not be considered by this algorithm.\nHowever, the problem would not occur if we process the vertices in\norder of distance from .\nAssume that we have processed in order of distance from  to\nthe first  vertices that are closest to ;\ncall this set of vertices .\nWe are now about to process the  th closest vertex; call\nit ."}, {"title_reference": ["S", "X", "S"], "#text": "A shortest path from  to  must have its next-to-last\nvertex in .\nThus,"}, {"title_reference": ["S", "X", "S", "U", "U", "X", "U", "mathbf{S}"], "#text": "In other words, the shortest path from  to  is the\nminimum over all paths that go from  to , then have an\nedge from  to , where  is some vertex\nin ."}, {"title_reference": ["mathbf{D}(X)", "X", "mathbf{V}", "mathbf{D}", "S", "v", "mathbf{D}(X)", "X", "V"], "literal": ["INFINITE", "D"], "#text": "This solution is usually referred to as Dijkstra's algorithm.\nIt works by maintaining a distance estimate\n for all vertices  in .\nThe elements of  are initialized to the value\n.\nVertices are processed in order of distance from .\nWhenever a vertex  is processed,  is\nupdated for every neighbor  of .\nHere is an implementation for Dijkstra's\nalgorithm.\nAt the end, array  will contain the shortest distance values."}, {"literal": "for", "title_reference": "|mathbf{V}|", "#text": "There are two reasonable solutions to the key issue of finding the\nunvisited vertex with minimum distance value during each pass through\nthe main  loop.\nThe first method is simply to scan through the list of\n vertices searching for the minimum value, as\nfollows:"}, {"title_reference": ["|mathbf{V}|", "Theta(|mathbf{V}|^2 + |mathbf{E}|) =\nTheta(|mathbf{V}|^2)", "|mathbf{E}|", "O(|mathbf{V}|^2)"], "literal": "D", "#text": "Because this scan is done  times,\nand because each edge requires a constant-time update to ,\nthe total cost for this approach\nis ,\nbecause  is in ."}, {"title_reference": ["Theta(log |mathbf{V}|)", "mathbf{D}(X)", "X", "priority queue <priority queue> <Heaps>", "Theta(|mathbf{V}|)", "Theta(|mathbf{E}|)", "Theta((|mathbf{V}| + |mathbf{E}|) log |mathbf{E}|)"], "literal": ["VISITED", "KVPair"], "#text": "An alternative approach is to store unprocessed vertices in a\nmin-heap ordered by their distance from the processed vertices.\nThe next-closest vertex can be found in the heap in\n time.\nEvery time we modify ,\nwe could reorder  in\nthe heap by deleting and reinserting it.\nThis is an example of a \nwith priority update.\nTo implement true priority updating, we would need to store with each\nvertex its position within the heap so that we can remove its old\ndistances whenever it is updated by processing new edges.\nA simpler approach is to add the new (always smaller) distance value\nfor a given vertex as a new record in the heap.\nThe smallest value for a given vertex currently in the heap will be\nfound first, and greater distance values found later will be ignored\nbecause the vertex will already be marked as .\nThe only disadvantage to repeatedly inserting distance values in this\nway is that it will raise the number of elements in the heap from\n to \nin the worst case.\nBut in practice this only adds a slight increase to the depth of the\nheap.\nThe time complexity is\n,\nbecause for each edge that we process we must reorder the heap.\nWe use the  class to store key-value pairs in the heap, with\nthe edge weight as the key and the target vertex as the value.\nhere is the implementation for Dijkstra's algorithm using a heap."}, {"literal": "MinVertex", "title_reference": ["|mathbf{E}|", "|mathbf{V}|^2", "Theta((|mathbf{V}| + |mathbf{E}|) log |mathbf{E}|)", "Theta(|mathbf{V}|^2 log |mathbf{E}|) = Theta(|V|^2 log |V|)"], "#text": "Using  to scan the vertex list for the minimum value\nis more efficient when the graph is dense, that is, when\n approaches .\nUsing a heap is more efficient when the graph is sparse\nbecause its cost is\n.\nHowever, when the graph is dense, this cost can become as great as\n."}, "Now you can practice using Dijkstra's algorithm."], "raw": [{"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "DijkstraAV", "@long_name": "DijkstraAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "DijkstraPE", "@long_name": "DijkstraPE", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Graph/dijkstraCON.js"}], "math_block": {"@xml:space": "preserve", "#text": "\\mathbf{d}(S, X) =\n\\min_{U \\in \\mathbf{S}}(\\mathbf{d}(S, U) + \\mathbf{w}(U, X))."}}}}