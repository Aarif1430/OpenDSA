{"document": {"@ids": "binary-search-trees", "@names": "binary\\ search\\ trees", "@source": "<string>", "@title": "Binary Search Trees", "title": "Binary Search Trees", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Binary/BSTCON.css"}], "section": [{"@ids": "binary-search-tree-definition", "@names": "binary\\ search\\ tree\\ definition", "title": "Binary Search Tree Definition", "paragraph": [{"title_reference": ["binary search tree", "BST", "binary tree", "binary search tree property", "nodes <node>", "key", "Figure #BSTShape", "inorder traversal <inorder traversal> <BinaryTreeTraversal>"], "math": ["K", "K", "K", "K"], "#text": "A  ()\nis a  that conforms to the\nfollowing condition, known\nas the .\nAll  stored in the left subtree of a node whose\n value is  have key values\nless than or equal to .\nAll nodes stored in the right subtree of a node whose key value\nis  have key values greater than .\nFigure  shows two BSTs for a collection of\nvalues.\nOne consequence of the binary search tree property is that if the BST\nnodes are printed using an\n,\nthen the resulting enumeration will be in\nsorted order from lowest to highest."}, {"title_reference": ["keys <key>", "comparing records <comparable> <Comparison>", "key-value pairs <key-value pair>", "comparator function <comparator>"], "literal": ["Comparator", "Comparable"], "#text": "Here is a class declaration for the BST.\nRecall that there are various ways to deal with\n and\n\nThree typical approaches are ,\na special comparison method such as using the  class,\nand passing in a .\nOur BST implementation will require that records implement the\n interface."}], "target": {"@refid": "bstshape"}, "raw": [{"@format": "xml", "@ids": "bstshape", "@names": "bstshape", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}], "section": {"@ids": "bst-search", "@names": "bst\\ search", "title": "BST Search", "paragraph": {"literal": ["find", "findhelp", "find", "findhelp"], "#text": "The first operation that we will look at in detail will find the\nrecord that matches a given key.\nNotice that in the BST class, public member function\n calls private member function .\nMethod  takes the search key as an explicit parameter\nand its BST as an implicit parameter, and returns the record that\nmatches the key.\nHowever, the find operation is most easily implemented as a\nrecursive function whose parameters are the root of a\nsubtree and the search key.\nMember  has the desired form for this recursive\nsubroutine and is implemented as follows."}, "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "BSTsearchCON", "@long_name": "BSTsearchCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "BSTsearchPRO", "@long_name": "BSTsearchPRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}]}}, {"@ids": "bst-insert", "@names": "bst\\ insert", "title": "BST Insert", "paragraph": ["Now we look at how to insert a new node into the BST.", {"literal": "inserthelp", "#text": "Note that, except for the last node in the path, \nwill not actually change the child pointer for any of the nodes that\nare visited.\nIn that sense, many of the assignments seem redundant.\nHowever, the cost of these additional assignments is worth paying to\nkeep the insertion process simple.\nThe alternative is to check if a given assignment is necessary, which\nis probably more expensive than the assignment!"}, "We have to decide what to do when the node that we want to\ninsert has a key value equal to the key of some node already in\nthe tree.\nIf during insert we find a node that duplicates the key value to be\ninserted, then we have two options.\nIf the application does not allow nodes with equal keys, then this\ninsertion should be treated as an error (or ignored).\nIf duplicate keys are allowed, our convention will be to insert the\nduplicate in the left subtree.", {"title_reference": "Figure #BSTShape", "math": ["n", "n"], "#text": "The shape of a BST depends on the order in which elements are inserted.\nA new element is added to the BST as a new leaf node,\npotentially increasing the depth of the tree.\nFigure  illustrates two BSTs for a collection\nof values.\nIt is possible for the BST containing  nodes to be a chain of\nnodes with height .\nThis would happen if, for example, all elements were inserted in\nsorted order.\nIn general, it is preferable for a BST to be as shallow as\npossible.\nThis keeps the average cost of a BST operation low."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "BSTinsertCON", "@long_name": "BSTinsertCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "BSTinsertPRO", "@long_name": "BSTinsertPRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}]}, {"@ids": "bst-remove", "@names": "bst\\ remove", "title": "BST Remove", "paragraph": ["Removing a node from a BST is a bit trickier than inserting a node,\nbut it is not complicated if all of the possible cases are considered\nindividually.\nBefore tackling the general node removal process, we will first see\nhow to remove from a given subtree the node with the largest key\nvalue.\nThis routine will be used later by the general node removal function.", {"literal": ["deletemax", "inserthelp", "deletemax"], "#text": "The return value of the  method is the subtree of\nthe current node with the maximum-valued node in the subtree removed.\nSimilar to the  method, each node on the path back to\nthe root has its right child pointer reassigned to the subtree\nresulting from its call to the  method."}, {"literal": "getmax", "#text": "A useful companion method is  which returns a\npointer to the node containing the maximum value in the subtree."}, {"literal": ["removehelp", "deletemax"], "math": ["R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R"], "#text": "Now we are ready for the  method.\nRemoving a node with given key value  from the BST\nrequires that we first find  and then remove it from the\ntree.\nSo, the first part of the remove operation is a search to find\n.\nOnce  is found, there are several possibilities.\nIf  has no children, then 's parent has its\npointer set to NULL.\nIf  has one child, then 's parent has\nits pointer set to 's child (similar to ).\nThe problem comes if  has two children.\nOne simple approach, though expensive, is to set 's parent to\npoint to one of 's subtrees, and then reinsert the remaining\nsubtree's nodes one at a time.\nA better alternative is to find a value in one of the\nsubtrees that can replace the value in ."}, "Thus, the question becomes:\nWhich value can substitute for the one being removed?\nIt cannot be any arbitrary value, because we must preserve the BST\nproperty without making major changes to the structure of the tree.\nWhich value is most like the one being removed?\nThe answer is the least key value greater than the one\nbeing removed, or else the greatest key value less than (or equal to)\nthe one being removed.\nIf either of these values replace the one being removed,\nthen the BST property is maintained.", {"emphasis": "left", "footnote_reference": {"@auto": "1", "@ids": "id1", "@refid": "id2", "#text": "1"}, "math": ["L", "L", "L", "L"], "#text": "When duplicate node values do not appear in the tree, it makes no\ndifference whether the replacement is the greatest value from the\nleft subtree or the least value from the right subtree.\nIf duplicates are stored in the left subtree, then we must select\nthe replacement from the  subtree. \nTo see why, call the least value in the right subtree .\nIf multiple nodes in the right subtree have value ,\nselecting  as the replacement value for the root of the\nsubtree will result in a tree with equal values to the right of the\nnode now containing .\nSelecting the greatest value from the left subtree does not\nhave a similar problem, because it does not violate the Binary Search\nTree Property if equal values appear in the left subtree."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "BSTdeletemaxCON", "@long_name": "BSTdeletemaxCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "BSTremoveCON", "@long_name": "BSTremoveCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "BSTremovePRO", "@long_name": "BSTremovePRO", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}], "footnote": {"@auto": "1", "@backrefs": "id1", "@ids": "id2", "@names": "1", "label": "1", "paragraph": "Alternatively, if we prefer to store duplicate values in the\nright subtree, then we must replace a deleted node with the\nleast value from its right subtree."}}, {"@ids": "bst-analysis", "@names": "bst\\ analysis", "title": "BST Analysis", "paragraph": [{"literal": ["findhelp", "inserthelp", "removehelp"], "title_reference": "balanced <balanced tree>", "math": ["n", "\\log n", "n", "n", "\\Theta(\\log n)", "\\Theta(n)", "n", "\\Theta(\\log n)", "\\Theta(n \\log n)", "n", "\\sum_{i=1}^{n} i = \\Theta(n^2)"], "#text": "The cost for  and  is the depth of\nthe node found or inserted.\nThe cost for  is the depth of the node being\nremoved, or in the case when this node has two children,\nthe depth of the node with smallest value in its right subtree.\nThus, in the worst case, the cost for any one of these operations is\nthe depth of the deepest node in the tree.\nThis is why it is desirable to keep BSTs\n, that is, with least possible\nheight.\nIf a binary tree is balanced, then the height for a tree of \nnodes is approximately .\nHowever, if the tree is completely unbalanced, for example in the\nshape of a linked list, then the height for a tree with \nnodes can be as great as .\nThus, a balanced BST will in the average case have operations costing\n, while a badly unbalanced BST can have\noperations in the worst case costing .\nConsider the situation where we construct a BST of  nodes\nby inserting records one at a time.\nIf we are fortunate to have them arrive in an order that results in a\nbalanced tree (a \"random\" order is likely to be good\nenough for this purpose), then each insertion will cost on average\n, for a total cost of\n.\nHowever, if the records are inserted in order of increasing value,\nthen the resulting tree will be a chain of height .\nThe cost of insertion in this case will be\n."}, {"math": "\\Theta(n)", "#text": "Traversing a BST costs  regardless of the shape of\nthe tree.\nEach node is visited exactly once, and each child pointer\nis followed exactly once."}, {"literal": "printhelp", "#text": "Below is an example traversal, named .\nIt performs an inorder traversal on the BST to print the node values\nin ascending order."}, {"title_reference": ["AVL tree <AVL tree> <AVL>", "splay tree <splay tree> <Splay>", "2-3 Tree <2-3 tree> <TwoThreeTree>"], "#text": "While the BST is simple to implement and efficient when the tree is\nbalanced, the possibility of its being unbalanced is a serious\nliability.\nThere are techniques for organizing a BST to guarantee good performance.\nTwo examples are the\n and the\n.\nThere also exist other types of search trees that are guaranteed to\nremain balanced, such as the ."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "BSTSumm", "@long_name": "BSTSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/BSTsearchCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/BSTinsertCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/BSTdeletemaxCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/BSTremoveCON.js"}]}]}}