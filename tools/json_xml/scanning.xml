<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="reading-input-from-files-or-otherwise" names="reading\ input\ (from\ files\ or\ otherwise)" source="&lt;string&gt;" title="Reading Input (from Files or Otherwise)"><title>Reading Input (from Files or Otherwise)</title><subtitle ids="the-scanner-class" names="the\ scanner\ class">The Scanner Class</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>Java has an excellent class for reading in text. The
Scanner class is extremely useful to quickly parse through a String.
See the <raw format="html" xml:space="preserve">&lt;a href="http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html" target = "_blank"&gt;Scanner class API&lt;/a&gt;</raw>.
So how do we properly read in a file?
There are a number of ways.
This page shows a simple demonstration of how to use the Scanner class to read
in a command file from an old CS3114 project.
In this project we are given 4 commands that our program must handle:
debug, search, add, and delete.
Take a look at the <raw format="html" xml:space="preserve">&lt;a href="http://courses.cs.vt.edu/~cs3114/Fall13/watcherP4.txt" target = "_blank"&gt;input file&lt;/a&gt;</raw>.</paragraph><substitution_definition names="external_link1"><raw format="html" xml:space="preserve">&lt;a href="http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html" target = "_blank"&gt;Scanner class API&lt;/a&gt;</raw></substitution_definition><substitution_definition names="external_link2"><raw format="html" xml:space="preserve">&lt;a href="http://courses.cs.vt.edu/~cs3114/Fall13/watcherP4.txt" target = "_blank"&gt;input file&lt;/a&gt;</raw></substitution_definition><enumerated_list enumtype="arabic" prefix="" suffix="."><list_item><paragraph>debug - prints information about the tree in the program</paragraph></list_item><list_item><paragraph>search - searches a region based off coordinates given</paragraph></list_item><list_item><paragraph>add - adds a node at the coordinates given</paragraph></list_item><list_item><paragraph>delete - deletes a node at the specific point</paragraph></list_item></enumerated_list><paragraph>*Every command except debug takes additional parameters*</paragraph><paragraph>Consider the following code snippet.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>This code will parse through a command file, read in each command and each of
their parameters (if the command has one). It is important to note, however,
that this code is not necessarily safe. It assumes that the command file
given is properly formatted, and as such if a user decides to give the program
a malformed file the program will behave in a possibly unknown way.</paragraph><paragraph>Depending on the structure of your file you may not wish to simply do the token
method. Another approach would be to read in an entire line and then work from
there.
Consider <raw format="html" xml:space="preserve">&lt;a href="http://courses.cs.vt.edu/~cs3114/Fall14/P1sampleInput.txt" target = "_blank"&gt;this input file&lt;/a&gt;</raw>.
We now have 3 commands that we must support.</paragraph><substitution_definition names="external_link3"><raw format="html" xml:space="preserve">&lt;a href="http://courses.cs.vt.edu/~cs3114/Fall14/P1sampleInput.txt" target = "_blank"&gt;this input file&lt;/a&gt;</raw></substitution_definition><paragraph>1. insert {artist-name}&lt;SEP&gt;{song-name} - inserts a song using the information
provided in the fields</paragraph><enumerated_list enumtype="arabic" prefix="" start="2" suffix="."><list_item><paragraph>remove {artist|song} {name} - removes a song given a song name or artist name</paragraph></list_item></enumerated_list><paragraph>3. print {artist|song|blocks} - depending on the parameter value, you will print
out either a complete listing of the artists contained in the database, or the
songs, or else the free block list for the memory manager</paragraph><paragraph>So this time we have less commands to support, but more options for each command
, no worries! We simply need to change our code just a little bit. We see this
time that the insert command has no spacing between artist/song tokens. Rather it
uses the seperator &lt;SEP&gt;.</paragraph><raw format="xml" xml:space="preserve"><codeinclude>null</codeinclude></raw><paragraph>Seperating artists and song name on the same line can prove to be rather difficult
due to the fact that either name might include a space or other
traditional deliminator.
By seperating these fields using &lt;SEP&gt;, we drastically
reduce the possibilty of a valid name containing the delimeter.</paragraph></document>