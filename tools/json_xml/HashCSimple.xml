<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="collision\ resolution" ids="collision-resolution" source="&lt;string&gt;" title="Collision Resolution"><title>Collision Resolution</title><subtitle dupnames="collision\ resolution" ids="id1">Collision Resolution</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><index>null</index></raw><raw format="xml" xml:space="preserve"><odsalink>AV/Hashing/linProbeCON.css</odsalink></raw><paragraph>We now turn to the most commonly used form of hashing:
<title_reference>closed hashing &lt;closed hash system&gt;</title_reference> with no bucketing, and a
<title_reference>collision resolution policy</title_reference> that can potentially use any slot
in the hash table.</paragraph><paragraph>During insertion, the goal of <title_reference>collision resolution</title_reference> is to find
a free slot in the hash table when the home position for the record is
already occupied.
We can view any collision resolution method as generating a sequence
of hash table slots that can potentially hold the record.
The first slot in the sequence will be the home position for the key.
If the home position is occupied, then the collision resolution policy
goes to the next slot in the sequence.
If this is occupied as well, then another slot must be found, and
so on.
This sequence of slots is known as the
<title_reference>probe sequence</title_reference>, and it is generated by some
<title_reference>probe function</title_reference> that we will call <strong>p</strong>.
Insertion works as follows:</paragraph><literal_block xml:space="preserve">// Insert e into hash table HT
void hashInsert(const Key&amp; k, const Elem&amp; e) {
  int home;                     // Home position for e
  int pos = home = h(k);        // Init probe sequence
  for (int i=1; EMPTYKEY != (HT[pos]).key(); i++) {
    pos = (home + p(k, i)) % M; // probe
    if (k == HT[pos].key()) {
      println("Duplicates not allowed");
      return;
    }
  }
  HT[pos] = e;
}</literal_block><paragraph>Method <literal>hashInsert</literal> first checks to see if the home slot for the
key is empty.
If the home slot is occupied, then we use the probe function
<math>\textbf{p}(k, i)</math> to locate a free slot in the table.
Function <strong>p</strong> has two parameters, the key <math>k</math> and a
count <math>i</math> of where in the probe sequence we wish to be.
That is, to get the first position in the probe sequence after the
home slot for key <math>K</math>, we call <math>\textbf{p}(K, 1)</math>.
For the next slot in the probe sequence, call <math>\textbf{p}(K, 2)</math>.
Note that the probe function returns an offset from the original home
position, rather than a slot in the hash table.
Thus, the <literal>for</literal> loop in <literal>hashInsert</literal> is computing positions
in the table at each iteration by adding the value returned from the
probe function to the home position.
The <math>i</math> th call to <strong>p</strong> returns the <math>i</math> th offset to be used.</paragraph><paragraph>Searching in a hash table follows the same probe sequence that was
followed when inserting records.
In this way, a record not in its home position can be recovered.
An implementation for the search procedure is as
follows.:</paragraph><literal_block xml:space="preserve">// Search for the record with Key K
bool hashSearch(const Key&amp; K, Elem&amp; e) const {
  int home;              // Home position for K
  int pos = home = h(K); // Initial position is the home slot
  for (int i = 1;
       (K != (HT[pos]).key()) &amp;&amp; (EMPTYKEY != (HT[pos]).key());
       i++)
    pos = (home + p(K, i)) % M; // Next on probe sequence
  if (K == (HT[pos]).key()) {   // Found it
    e = HT[pos];
    return true;
  }
  else return false;            // K not in hash table
}</literal_block><paragraph>Both the insert and the search routines assume that at least
one slot on the probe sequence of every key will be empty.
Otherwise they will continue in an infinite loop on unsuccessful
searches.
Thus, the hash system should keep a count of the number of records stored,
and refuse to insert into a table that has only one free slot.</paragraph><paragraph>The simplest approach to collsion resolution is simply to move down
the table from the home slot until a free slot is found.
This is known as <title_reference>linear probing</title_reference>.
The probe function for simple linear probing is
<math>\textbf{p}(K, i) = i</math>.
That is, the <math>i</math> th offset on the probe sequence is just
<math>i</math>,
meaning that the <math>i</math> th step is simply to move down  <math>i</math>
slots in the table.
Once the bottom of the table is reached, the probe sequence
wraps around to the beginning of the table (since the last step is to
mod the result to the table size).
Linear probing has the virtue that all slots in the table will be
candidates for inserting a new record before the probe sequence
returns to the home position.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="linProbeCON1"
    long_name="linProbeCON1"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Can you see any reason why this might not be the best approach
to collision resolution?</paragraph><section ids="the-problem-with-linear-probing" names="the\ problem\ with\ linear\ probing"><title>The Problem with Linear Probing</title><paragraph>While linear probing is probably
the first idea that comes to mind when considering collision
resolution policies, it is not the only one possible.
Probe function <strong>p</strong> allows us many options for how to do collision
resolution.
In fact, linear probing is one of the worst collision resolution
methods.
The main problem is illustrated by the next slideshow.</paragraph><raw format="xml" xml:space="preserve"><inlineav
    type="ss"
    exer_name="linProbeCON2"
    long_name="linProbeCON2"
    points="0"
    required="True"
    threshold="1.0">
</inlineav>
</raw><paragraph>Again, the ideal behavior for a collision resolution mechanism is that
each empty slot in the table will have equal probability of
receiving the next record inserted (assuming that every slot in the
table has equal probability of being hashed to initially).
This tendency of linear probing to cluster items together is known as
<title_reference>primary clustering</title_reference>.
Small clusters tend to merge into big clusters, making the problem
worse.
The objection to primary clustering is that it leads to
long probe sequences.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="HashLinearPPRO"
    long_name="HashLinearPPRO"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><raw format="xml" xml:space="preserve"><odsascript>AV/Hashing/linProbeCON1.js</odsascript></raw><raw format="xml" xml:space="preserve"><odsascript>AV/Hashing/linProbeCON2.js</odsascript></raw></section></document>