{"document": {"@ids": "syntax-of-the-lambda-calculus", "@names": "syntax\\ of\\ the\\ lambda\\ calculus", "@source": "<string>", "@title": "Syntax of the Lambda Calculus", "title": "Syntax of the Lambda Calculus", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/PL/AV/parseTree.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/PL/main.css"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}], "section": [{"@ids": "lambda-calculus", "@names": "lambda\\ calculus", "title": "Lambda Calculus", "paragraph": [{"title_reference": ["lambda calculus", "lambda"], "math": ["\\lambda", "\\lambda"], "#text": "The  (also written as -calculus,\nwhere  is the name of the Greek letter )\nwas created by Alonzo Church in the early 1930s to study which\nfunctions are computable. In addition to being a concise yet powerful\nmodel in computability theory, the lambda calculus is also the\nsimplest functional programming language. So much so that the lambda\ncalculus looks like a toy language, even though it is (provably!) as\npowerful as any of the programming languages being used today, such as\nJavaScript, Java, C++, etc."}, {"@ids": "bnf-grammar-for-lc", "@names": "bnf-grammar-for-lc", "title_reference": "lambda expressions", "math": "\\lambda exp", "#text": "Programs in the lambda calculus are called \n(abbreviated ), of which there are only three\nkinds. In fact, here is a complete BNF grammar for the lambda\ncalculus:"}, "This BNF grammar tells us that expressions in the lambda calculus come\nin one of three flavors:", "The grammar above is quite concise, since it contains only two\nnon-terminals. Yet it generates an infinite set of expressions that\nrepresent all computable functions! Recall that the expressive power\nof BNF grammars comes from recursion, which is present in both the\nsecond and third productions in the grammar  above.", "The following slideshow demonstrates how to use the grammar above\nto build the parse tree for a given lambda expression.", {"strong": "Questions to ponder"}, {"math": "<var>", "#text": "Q1. Why does the non-terminal  not appear on the\nleft-hand size of any productions in the grammar above? Is the grammar\nincomplete?"}, "Q2. How many terminals does this grammar contain?", "Q3. Is this grammar ambiguous, since the third production is doubly recursive?"], "raw": [{"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "parseTree", "@long_name": "parseTree", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}], "target": {"@refid": "bnf-grammar-for-lc"}, "math_block": {"@xml:space": "preserve", "#text": "\\begin{eqnarray*}\n<\\lambda exp> &::=& <var>\\\\\n                     &|& \\lambda <\\mathrm{var}>\\ .\\ <\\lambda exp>\\\\\n                     &|& (\\ <\\lambda exp>\\ <\\lambda exp>\\ )\\\\\n\\end{eqnarray*}"}, "block_quote": {"enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"title_reference": "variable", "math": ["x, y, a_1", "p_2"], "#text": "A  (the first production above): typically, we\nwill use a single letter, with an optional integer subscript, to\ndenote a variable. So, , and  are\nexamples of variables."}}, {"paragraph": {"title_reference": ["function abstraction", "lambda abstraction"], "math": ["\\lambda", "< var >", "<\\lambda exp >", "\\lambda x.y", "x", "y", "<var>", "\\lambda"], "emphasis": "not", "#text": "A  (the second production above):\nthis type of  expressions, also called a\n, corresponds to a function\ndefinition, which contains two components: the formal parameter\nof the function (there must be exactly one parameter, namely the\n non-terminal in the second production above) and\nthe body of the function (namely the \nnon-terminal in the same production). So, for example,\n is the function whose formal parameter is\n and whose body is . Note that the non-terminal\n after the  terminal is  the\nname of the function. In fact, all functions in the lambda calculus\nare anonymous."}}, {"paragraph": [{"title_reference": "application", "math": ["\\lambda", "(f\\ x)", "f", "x"], "#text": "An  (the third production above): this type of\n expressions corresponds to a function call (or\napplication, or invocation), which contains two components: the\nfunction being called, followed by the argument that is passed\ninto the function. So, for example,  is the\napplication of the variable  (which must stand for a\nfunction, since functions are the only values in the lambda\ncalculus) to the argument , which must also stand for a\nfunction."}, {"math": "f(x)", "#text": "Note that in the lambda calculus, the parentheses\nsurround both the function and its argument, while in many modern\nprogramming languages (and in mathematical notation), the\nfunction would come first and be followed by the formal parameter\nin parentheses, like this: . In the lambda calculus,\nthe parentheses are not optional around function\ncalls. Furthermore, the grammar above makes it clear that they\ncannot be used anywhere else."}], "raw": {"@format": "xml", "@xml:space": "preserve", "index": "null"}}]}}}, {"@ids": "rp-14-part-1", "@names": "rp\\ 14\\ part\\ 1", "title": "RP 14 part 1", "paragraph": "Test your mastery of the syntax of the lambda calculus with this\nexercise.  To get credit for this randomized exercise, you must solve\nit correctly three times in a row.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP14part1", "@long_name": "RP14part1", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "rp-14-part-2", "@names": "rp\\ 14\\ part\\ 2", "title": "RP 14 part 2", "paragraph": "Once you can consistently solve the previous problem, try this more\nintense exercise, in which you have to analyze four expressions each\ntime.  To get credit for this randomized exercise, you must solve it\ncorrectly three times in a row.", "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP14part2", "@long_name": "RP14part2", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/PL/AV/parseTree.js"}]}]}}