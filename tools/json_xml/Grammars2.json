{"document": {"@ids": "grammars-part-2", "@names": "grammars\\ -\\ part\\ 2", "@source": "<string>", "@title": "Grammars - Part 2", "title": "Grammars - Part 2", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-13 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}, {"@xml:space": "preserve", "#text": "(W 2/3/16)"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/PL/AV/parseTree.css"}], "section": [{"@ids": "rp-2-part-1", "@names": "rp\\ 2\\ part\\ 1", "title": "RP 2 part 1", "block_quote": {"paragraph": {"emphasis": ["ambiguous grammars", "Grammars - Part 1"], "title_reference": ["eg1", "<exp>, <trm>, <pri>"], "#text": "The main topic of this module is .  In  of , we developed a grammar for algebraic expressions that involved three non-terminals .   Could we develop a simpler grammar for the same language that only required two non-terminals?   Here is a candidate for doing that with only two non-terminals."}}, "section": {"@ids": "example-grammar-2", "@names": "example\\ grammar\\ 2", "title": "Example Grammar 2", "math_block": {"@xml:space": "preserve", "#text": "\\begin{eqnarray*}\n<exp> &::=& <exp>\\\\\n&|& <exp> + <exp> \\\\\n&|& <exp> - <exp> \\\\\n&|& <exp> * <exp> \\\\\n&|& <exp> / <exp> \\\\\n<exp> &::=& <pri> \\\\\n&|& ( <exp> ) \\\\\n<pri> &:==& A | B | C | \\ldots | X | Y | Z\n\\end{eqnarray*}"}, "paragraph": [{"title_reference": ["A+B*C", "+"], "#text": "Let's try to parse the expression  using this grammar.\nThe grammar offers us a lot of options for how to start the parse.  We\ncould choose to first use the production with the  operator,\nas is done in the following slide-show."}, {"title_reference": "*", "#text": "Or we could also start with the production having the  operator, in which case the parse proceeds as shown in the following slide-show."}, {"emphasis": "ambiguous grammar", "#text": "Note that both of the slide-shows above produce valid parse trees for this grammar.   The problem, however, is that the two parse trees are different.   In the first of the two parse trees, B would multiply C, which would correspond to usual operator precedence.   However, in the parse tree produced by the second slide-show, B would be added to A, a result that is contrary to usual operator precedence.   A grammar such as this, which allows two different parse trees for the same expression, is called an .   Ambiguous grammars should always be avoided.   Although they allow you to determine the syntactic correctness of an expression, the variety of parse trees they allow confounds our ability to use the parse trees for any type of reliable semantic action."}, "The review problem set for this module contains four review problems, the first three of which refer to the same grammar.  The first problem is about determining how many parse trees a given string has in a given grammar."], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "parseTree5a", "@long_name": "parseTree5a", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "parseTree5b", "@long_name": "parseTree5b", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP2part1", "@long_name": "RP2part1", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}}, {"@ids": "rp-2-part-2", "@names": "rp\\ 2\\ part\\ 2", "title": "RP 2 part 2", "paragraph": "This problem is again about determining how many parse trees a given string\nhas in a given grammar.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP2part2", "@long_name": "RP2part2", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "rp-2-part-3", "@names": "rp\\ 2\\ part\\ 3", "title": "RP 2 part 3", "paragraph": "This problem is once more about determining how many parse trees a\ngiven string has in a given grammar.", "raw": {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP2part3", "@long_name": "RP2part3", "@points": "1.0", "@required": "True", "@threshold": "5"}}}, {"@ids": "rp-2-part-4", "@names": "rp\\ 2\\ part\\ 4", "title": "RP 2 part 4", "paragraph": "This problem will help you discover ambiguities in grammars as well as\nconvince yourself that a grammar is not ambiguous.", "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "RP2part4", "@long_name": "RP2part4", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/PL/AV/parseTree5a.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/PL/AV/parseTree5b.js"}]}]}}