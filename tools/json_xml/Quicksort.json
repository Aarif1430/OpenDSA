{"document": {"@ids": "quicksort", "@names": "quicksort", "@source": "<string>", "@title": "Quicksort", "title": "Quicksort", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Sorting/quicksortCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Development/QuickSortPartitionAnalysisCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Development/QuickSortWorstCaseCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Development/QuickSortBestCaseCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Development/QuickSortAverageCaseCON.css"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}], "section": [{"@ids": "introduction", "@names": "introduction", "title": "Introduction", "paragraph": ["While Mergesort uses the most obvious form of divide and conquer\n(split the list in half then sort the halves), this is not the only way\nthat we can break down the sorting problem.\nWe saw that doing the merge step for Mergesort when using an array\nimplementation is not so easy.\nSo perhaps a different divide and conquer strategy might turn out to\nbe more efficient?", {"title_reference": "Quicksort", "literal": "qsort", "#text": "is aptly named because, when properly\nimplemented, it is the fastest known general-purpose in-memory sorting\nalgorithm in the average case.\nIt does not require the extra array needed by Mergesort, so it is\nspace efficient as well.\nQuicksort is widely used, and is typically the algorithm implemented\nin a library sort routine such as the UNIX \nfunction.\nInterestingly, Quicksort is hampered by exceedingly poor worst-case\nperformance, thus making it inappropriate for certain applications."}, "Before we get to Quicksort, consider for a moment the practicality\nof using a Binary Search Tree for sorting.\nYou could insert all of the values to be sorted into the BST\none by one, then traverse the completed tree using an inorder traversal.\nThe output would form a sorted list.\nThis approach has a number of drawbacks, including the extra space\nrequired by BST pointers and the amount of time required to insert\nnodes into the tree.\nHowever, this method introduces some interesting ideas.\nFirst, the root of the BST (i.e., the first node inserted) splits the\nlist into two sublists:\nThe left subtree contains those values in the\nlist less than the root value while the right subtree contains those\nvalues in the list greater than or equal to the root value.\nThus, the BST implicitly implements a \"divide and conquer\" approach\nto sorting the left and right subtrees.\nQuicksort implements this same concept in a much more efficient way.", {"title_reference": ["pivot", "k", "k", "k", "n-k", "partition", "k", "k", "n-k-1"], "#text": "Quicksort first selects a value called the .\n(This is conceptually like the root node's value in the BST.)\nAssume that the input array contains  records with key values\nless than the pivot.\nThe records are then rearranged in such a way that the \nvalues less than the pivot are placed in the first, or leftmost,\n positions in the array, and the values greater than or equal\nto the pivot are placed in the last, or rightmost, \npositions.\nThis is called a  of the array.\nThe values placed in a given partition need not (and typically will\nnot) be sorted with respect to each other.\nAll that is required is that all values end up in the correct\npartition.\nThe pivot value itself is placed in position .\nQuicksort then proceeds to sort the resulting subarrays now on either\nside of the pivot, one of size  and the other of size\n.\nHow are these values sorted?\nBecause Quicksort is such a good algorithm, using Quicksort on\nthe subarrays would be appropriate."}, "Unlike some of the sorts that we have seen earlier in this chapter,\nQuicksort might not seem very \"natural\" in that it is not an\napproach that a person is likely to use to sort real objects.\nBut it should not be too surprising that a really efficient sort for\nhuge numbers of abstract objects on a computer would be rather\ndifferent from our experiences with sorting a relatively few physical\nobjects.", {"literal": ["i", "j", "quicksort", "quicksort(array, 0, n-1)"], "#text": "Here is an implementation for Quicksort.\nParameters  and  define the left and right\nindices, respectively, for the subarray being sorted.\nThe initial call to  would be\n."}, {"literal": ["partition", "k", "j", "partition", "j", "k", "qsort"], "title_reference": "n-1", "#text": "Function  will move records to the\nappropriate partition and then return , the first\nposition in the right partition.\nNote that the pivot value is initially placed at the end of the array\n(position ).\nThus,  must not affect the value of array position .\nAfter partitioning, the pivot value is placed in position ,\nwhich is its correct position in the final, sorted array.\nBy doing so, we guarantee that at least one value (the pivot) will not\nbe processed in the recursive calls to .\nEven if a bad pivot is selected, yielding a completely empty\npartition to one side of the pivot, the larger partition will contain\nat most  records."}, {"literal": "findpivot", "#text": "Selecting a pivot can be done in many ways.\nThe simplest is to use the first key.\nHowever, if the input is sorted or reverse sorted, this will produce a\npoor partitioning with all values to one side of the pivot.\nIt is better to pick a value at random, thereby reducing the chance of\na bad input order affecting the sort.\nUnfortunately, using a random number generator is relatively\nexpensive, and we can do nearly as well by selecting the middle\nposition in the array.\nHere is a simple  function."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "QuicksortPivotPRO", "@long_name": "QuicksortPivotPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}]}, {"@ids": "partition", "@names": "partition", "title": "Partition", "paragraph": [{"literal": ["partition", "partition"], "#text": "We now turn to function .\nIf we knew in advance how many keys are less than the pivot,\n could simply copy records with key values less\nthan the pivot to the low end of the array, and records with larger\nkeys to the high end.\nBecause we do not know in advance how many keys are less than\nthe pivot,\nwe use a clever algorithm that moves indices inwards from the\nends of the subarray, swapping values as necessary until the two\nindices meet.\nHere is an implementation for the partition step."}, {"literal": ["right >= left", "while", "right", "partition", "left", "qsort"], "#text": "Note the check that  in the second inner\n loop.\nThis ensures that  does not run off the low end of the\npartition in the case where the pivot is the least value in that\npartition.\nFunction  returns the first index of the right\npartition (the place where  ends at) so that the subarray\nbound for the recursive calls to  can be determined."}, "And here is a visualization illustrating the running time analysis of the partition function"], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "quicksortCON", "@long_name": "quicksortCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "QuicksortPartitPRO", "@long_name": "QuicksortPartitPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "QuickSortPartitionAnalysisCON", "@long_name": "QuickSortPartitionAnalysisCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}]}, {"@ids": "putting-it-together", "@names": "putting\\ it\\ together", "title": "Putting It Together", "paragraph": ["Here is a visualization for the entire Quicksort algorithm.\nThis visualization shows you how the logical decomposition caused by\nthe partitioning process works.\nIn the visualization, the separate sub-partitions are separated out to\nmatch the recursion tree.\nIn reality, there is only a single array involved (as you will see in\nthe proficiency exercise that follows the visualization).", "Here is a complete proficiency exercise to see how well you understand\nQuicksort."], "raw": [{"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ss", "@exer_name": "quicksortAV", "@long_name": "quicksortAV", "@points": "0.0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "pe", "@exer_name": "quicksortPRO", "@long_name": "quicksortPRO", "@points": "1.0", "@required": "True", "@threshold": "0.9"}}]}, {"@ids": "quicksort-analysis", "@names": "quicksort\\ analysis", "title": "Quicksort Analysis", "paragraph": ["This visualization explains the worst-case running time of Quick Sort", "This is terrible, no better than Bubble Sort.\nWhen will this worst case occur?\nOnly when each pivot yields a bad partitioning of the array.\nIf the pivot values are selected at random, then this is extremely\nunlikely to happen.\nWhen selecting the middle position of the current subarray, it is\nstill unlikely to happen.\nIt does not take many good partitionings for Quicksort to\nwork fairly well.", "This visualization explains the best-case running time of Quick Sort", {"title_reference": ["n-1", "n-2"], "#text": "Quicksort's average-case behavior falls somewhere\nbetween the extremes of worst and best case.\nAverage-case analysis considers the cost for all possible arrangements\nof input, summing the costs and dividing by the number of cases.\nWe make one reasonable simplifying assumption:\nAt each partition step, the pivot is\nequally likely to end in any position in the (sorted) array.\nIn other words, the pivot is equally likely to break an array into\npartitions of sizes 0 and , or 1 and , and so\non."}, "Given this assumption, the average-case cost is computed from the\nfollowing equation:", "This visualization will help you to understand how this recurrence\nrelation was formed.", {"title_reference": ["n", "n", "n!", "n!", "O(n^2)", "(n!)(O(n log n))", "O(n^2)", "O(n^2)", "O(n^2)", "n"], "#text": "This is an unusual situation that the average case cost and the worst\ncase cost have asymptotically different growth rates.\nConsider what \"average case\" actually means.\nWe compute an average cost for inputs of size  by summing up\nfor every possible input of size  the product of the running\ntime cost of that input times the probability that that input will\noccur.\nTo simplify things, we assumed that every permutation is equally\nlikely to occur.\nThus, finding the average means summing up the cost for every\npermutation and dividing by the number of permuations\n(which is ).\nWe know that some of these  inputs cost .\nBut the sum of all the permutation costs has to be\n.\nGiven the extremely high cost of the worst inputs, there must be\nvery few of them.\nIn fact, there cannot be a constant fraction of the inputs with cost\n.\nIf even, say, 1% of the inputs have cost , this would\nlead to an average cost of .\nThus, as  grows, the fraction of inputs with high cost must\nbe going toward a limit of zero.\nWe can conclude that Quicksort will run fast if\nwe can avoid those very few bad input permutations.\nThis is why picking a good pivot is so important."}, {"literal": ["findpivot", "findpivot"], "#text": "The running time for Quicksort can be improved (by a constant factor),\nand much study has gone into optimizing this algorithm.\nSince Quicksort's worst case behavior arises when the pivot does a\npoor job of splitting the array into equal size subarrays,\nimproving  seems like a good place to start.\nIf we are willing to do more work searching for a better pivot, the\neffects of a bad pivot can be decreased or even eliminated.\nHopefully this will save more time than was added by the additional\nwork needed to find the pivot.\nOne widely-used choice is to use the \"median of three\" algorithm,\nwhich uses as a pivot the middle of three randomly selected values.\nUsing a random number generator to choose the positions is relatively\nexpensive, so a common compromise is to look at the first, middle, and\nlast positions of the current subarray.\nHowever, our simple  function that takes the\nmiddle value as its pivot has the virtue of making it highly unlikely\nto get a bad input by chance, and it is quite cheap to implement.\nThis is in sharp contrast to selecting the first or last record as\nthe pivot, which would yield bad performance for many permutations\nthat are nearly sorted or nearly reverse sorted."}, {"title_reference": "n", "#text": "A significant improvement can be gained by recognizing that\nQuicksort is relatively slow when  is small.\nThis might not seem to be relevant if most of the time we sort\nlarge arrays, nor should it matter how long Quicksort takes in the\nrare instance when a small array is sorted because it will be fast\nanyway.\nBut you should notice that Quicksort itself sorts many, many small\narrays!\nThis happens as a natural by-product of the divide and conquer\napproach."}, "A simple improvement might then be to replace Quicksort with a faster\nsort for small numbers, say Insertion Sort or Selection Sort.\nHowever, there is an even better---and still simpler---optimization.\nWhen Quicksort partitions are below a certain size, do nothing!\nThe values within that partition will be out of order.\nHowever, we do know that all values in the array to the left of the\npartition are smaller than all values in the partition.\nAll values in the array to the right of the partition are greater than\nall values in the partition.\nThus, even if Quicksort only gets the values to\n\"nearly\" the right locations, the array will be close to sorted.\nThis is an ideal situation in which to take advantage of the best-case\nperformance of Insertion Sort.\nThe final step is a single call to Insertion Sort to process the\nentire array, putting the records into final sorted order.\nEmpirical testing shows that the subarrays should be left unordered\nwhenever they get down to nine or fewer records.", {"literal": ["findpivot", "partition"], "#text": "The last speedup to be considered reduces the cost of making\nrecursive calls.\nQuicksort is inherently recursive, because each Quicksort operation\nmust sort two sublists.\nThus, there is no simple way to turn Quicksort into an iterative\nalgorithm.\nHowever, Quicksort can be implemented using a stack\nto imitate recursion, as the amount of information that must\nbe stored is small.\nWe need not store copies of a subarray, only the subarray bounds.\nFurthermore, the stack depth can be kept small if care is taken on\nthe order in which Quicksort's recursive calls are executed.\nWe can also place the code for  and\n inline to eliminate the remaining function\ncalls.\nNote however that by not processing sublists of size nine or\nless as suggested above, about three quarters of the function calls\nwill already have been eliminated.\nThus, eliminating the remaining function calls will yield only a\nmodest speedup."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "QuickSortWorstCaseCON", "@long_name": "QuickSortWorstCaseCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "QuickSortBestCaseCON", "@long_name": "QuickSortBestCaseCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "QuickSortAverageCaseCON", "@long_name": "QuickSortAverageCaseCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "todo": "null"}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "QuicksortSumm", "@long_name": "QuicksortSumm", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/quicksortCODE.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Sorting/quicksortCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/QuickSortPartitionAnalysisCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/QuickSortWorstCaseCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/QuickSortBestCaseCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Development/QuickSortAverageCaseCON.js"}], "math_block": {"@xml:space": "preserve", "#text": "{\\bf T}(n) = cn + \\frac{1}{n}\\sum_{k=0}^{n-1}[{\\bf T}(k) +\n{\\bf T}(n - 1 - k)],\n\\quad {\\bf T}(0) = {\\bf T}(1) = c."}}]}}