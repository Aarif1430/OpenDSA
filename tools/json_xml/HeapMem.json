{"document": {"@dupnames": "heap\\ memory", "@ids": "heap-memory", "@source": "<string>", "@title": "Heap Memory", "title": "Heap Memory", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "section": [{"@dupnames": "heap\\ memory", "@ids": "id1", "title": "Heap Memory", "paragraph": ["\"Heap\" memory, also known as \"dynamic\" memory, is an alternative to\nlocal stack memory.\nLocal memory (Section 2) is quite automatic  it is allocated\nautomatically on function call and it is deallocated automatically\nwhen a function exits.\nHeap memory is different in every way.\nThe programmer explicitly requests the allocation of a memory\n\"block\" of a particular size, and the block continues to be allocated\nuntil the programmer explicitly requests that it be deallocated.\nNothing happens automatically.\nSo the programmer has much greater control of memory, but with greater\nresponsibility since the memory must now be actively managed.\nThe advantages of heap memory are:", "The disadvantages of heap memory are:", "Nonetheless, there are many problems that can only be solved with heap\nmemory, so that's that way it has to be.\nIn languages with garbage collectors such as Perl, LISP, or Java,\nthe above disadvantages are mostly eliminated.\nThe garbage collector takes over most of the responsibility for heap\nmanagement at the cost of a little extra time taken at run-time."], "bullet_list": [{"@bullet": "*", "list_item": [{"paragraph": {"strong": "Lifetime", "#text": ". Because the programmer now controls exactly when memory\nis allocated and deallocated, it is possible to build a data\nstructure in memory, and return that data structure to the\ncaller. This was never possible with local memory which was\nautomatically deallocated when the function exited."}}, {"paragraph": {"strong": "Size", "#text": ". The size of allocated memory can be controlled with more\ndetail. For example, a string buffer can be allocated at run-time\nwhich is exactly the right size to hold a particular string. With\nlocal memory, the code is more likely to declare a buffer size 1000\nand hope for the best. (See the StringCopy() example below.)"}}]}, {"@bullet": "*", "list_item": [{"paragraph": {"strong": "More Work", "#text": ". Heap allocation needs to arranged explicitly in the\ncode which is just more work."}}, {"paragraph": {"strong": "More Bugs", "emphasis": "wrong", "#text": ". Because it's now done explicitly in the code,\nrealistically on occasion the allocation will be done incorrectly\nleading to memory bugs. Local memory is constrained, but at least\nit's never ."}}]}]}, {"@ids": "what-does-the-heap-look-like", "@names": "what\\ does\\ the\\ heap\\ look\\ like?", "title": "What Does The Heap Look Like?", "paragraph": "Before seeing the exact details, let's look at a rough example of\nallocation and deallocation in the heap.", "section": [{"@ids": "allocation", "@names": "allocation", "title": "Allocation", "paragraph": [{"title_reference": "allocation", "#text": "The heap is a large area of memory available for use by the program.\nThe program can request areas, or \"blocks\", of memory for its use\nwithin the heap.\nIn order to allocate a block of some size, the program makes an explicit request by calling the heap  function.\nThe allocation function reserves a block of memory of the requested size in the heap and returns a pointer to it. Suppose a program makes three allocation requests to allocate memory to hold three separate GIF images in the heap each of which takes 1024 bytes of memory. After the three allocation requests, memory might look like."}, "Each allocation request reserves a contiguous area of the requested size in the heap and\nreturns a pointer to that new block to the program. Since each block is always referred to\nby a pointer, the block always plays the role of a \"pointee\" (Section 1) and the program\nalways manipulates its heap blocks through pointers. The heap block pointers are\nsometimes known as \"base address\" pointers since by convention they point to the base\n(lowest address byte) of the block.\nIn this example, the three blocks have been allocated contiguously starting at the bottom\nof the heap, and each block is 1024 bytes in size as requested. In reality, the heap\nmanager can allocate the blocks wherever it wants in the heap so long as the blocks do\nnot overlap and they are at least the requested size. At any particular moment, some areas\nin the heap have been allocated to the program, and so are \"in use\". Other areas have yet\nto be committed and so are \"free\" and are available to satisfy allocation requests. The\nheap manager has its own, private data structures to record what areas of the heap are\ncommitted to what purpose at any moment  The heap manager satisfies each allocation\nrequest from the pool of free memory and updates its private data structures to record\nwhich areas of the heap are in use."], "raw": {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}}, {"@ids": "deallocation", "@names": "deallocation", "title": "Deallocation", "paragraph": ["When the program is finished using a block of memory, it makes an explicit\ndeallocation request to indicate to the heap manager that the program is now finished with that block.\nThe heap manager updates its private data structures to show that the area of memory\noccupied by the block is free again and so may be re-used to satisfy future allocation\nrequests. Here's what the heap would look like if the program deallocates the second of\nthe three blocks.", "After the deallocation, the pointer continues to point to the now deallocated block. The\nprogram must not access the deallocated pointee. This is why the pointer is drawn in gray\nthe pointer is there, but it must not be used. Sometimes the code will set the pointer to\nNULL immediately after the deallocation to make explicit the fact that it is no longer\nvalid."], "raw": {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}}]}, {"@ids": "programming-the-heap", "@names": "programming\\ the\\ heap", "title": "Programming The Heap", "paragraph": "Programming the heap looks pretty much the same in most languages. The basic features\nare:", "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": "The heap is an area of memory available to allocate areas (\"blocks\")\nof memory for the program."}, {"paragraph": {"literal": ["malloc()", "free()", "realloc()"], "#text": "There is some \"heap manager\" library code which manages the heap for\nthe program. The programmer makes requests to the heap manager,\nwhich in turn manages the internals of the heap. In C, the heap is\nmanaged by the ANSI library functions , , and\n."}}, {"paragraph": "The heap manager uses its own private data structures to keep track\nof which blocks in the heap are \"free\" (available for use) and which\nblocks are currently in use by the program and how large those\nblocks are. Initially, all of the heap is free."}, {"paragraph": "The heap may be of a fixed size (the usual conceptualization), or it\nmay appear to be of a fixed but extremely large size backed by\nvirtual memory. In either case, it is possible for the heap to get\n\"full\" if all of its memory has been allocated and so it cannot\nsatisfy an allocation request. The allocation function will\ncommunicate this run-time condition in some way to the program\nusually by returning a NULL pointer or raising a language specific\nrun-time exception."}, {"paragraph": "The allocation function requests a block in the heap of a particular\nsize. The heap manager selects an area of memory to use to satisfy\nthe request, marks that area as \"in use\" in its private data\nstructures, and returns a pointer to the heap block. The caller is\nnow free to use that memory by dereferencing the pointer. The block\nis guaranteed to be reserved for the sole use of the caller\nthe heap will not hand out that same area of memory to some other\ncaller. The block does not move around inside the heap  its\nlocation and size are fixed once it is allocated. Generally, when a\nblock is allocated, its contents are random. The new owner is\nresponsible for setting the memory to something\nmeaningful. Sometimes there is variation on the memory allocation\nfunction which sets the block to all zeros (calloc() in C)."}, {"paragraph": "The deallocation function is the opposite of the allocation\nfunction. The program makes a single deallocation call to return a\nblock of memory to the heap free area for later re-use. Each block\nshould only be deallocated once. The deallocation function takes as\nits argument a pointer to a heap block previously furnished by the\nallocation function. The pointer must be exactly the same pointer\nreturned earlier by the allocation function, not just any pointer\ninto the block. After the deallocation, the program must treat the\npointer as bad and not access the deallocated pointee."}]}}, {"@ids": "c-specifics", "@names": "c\\ specifics", "title": "C Specifics", "paragraph": {"literal": ["malloc()", "free()", "<stdlib.h>", "malloc()", "free()"], "#text": "In the C language, the library functions which make heap requests are\n (\"memory allocate\") and .\nThe prototypes for these functions are in the header file .\nAlthough the syntax varies between languages, the roles of\n and  are nearly identical in all languages."}, "block_quote": {"paragraph": [{"literal": ["void* malloc(unsigned long size);", "malloc()", "malloc()", "sizeof()", "sizeof(int)", "sizeof(struct fraction)", "struct fraction"], "#text": "The  function takes an unsigned integer which is the\nrequested size of the block measured in bytes.\n returns a pointer to a new heap block if the\nallocation is successful, and NULL if the request cannot be\nsatisfied because the heap is full.\nThe C operator  is a convenient way to compute the size\nin bytes of a type   for an  int pointee,\n for a  pointee."}, {"literal": ["void free(void* heapBlockPointer);", "free()", "free()", "malloc()", "free()", "free()", "free()", "malloc()", "free()"], "#text": "The  function takes a pointer t a heap block and returns\nit to the free pool for later reuse. The pointer passed to\n must be exactly the pointer returned earlier by\n, not just a pointer to somewhere in the block.\nCalling  with the wrong sort of pointer is famous for the\nparticularly ugly sort of crashing which it causes. The call to\n does not need to give the size of the heap block\nthe heap manager will have noted the size in its private data\nstructures. The call to  just needs to identify which\nblock to deallocate by its pointer. If a program correctly\ndeallocates all of the memory it allocates, then every call to\n will later be matched by exactly one call to\n As a practical matter however, it is not always\nnecessary for a program to deallocate every block it allocates  see\n\"Memory Leaks\" below."}]}}, {"@ids": "simple-heap-example", "@names": "simple\\ heap\\ example", "title": "Simple Heap Example", "paragraph": {"literal": "int", "#text": "Here is a simple example which allocates an\n block in the heap, stores the number 42 in the block, and then deallocates it.\nThis is the simplest possible example of heap block allocation, use, and deallocation.\nThe example shows the state of memory at three different times during the execution of the above code. The stack and heap are shown\nseparately in the drawing  a drawing for code which uses stack and heap memory needs\nto distinguish between the two areas to be accurate since the rules which govern the two\nareas are so different. In this case, the lifetime of the local variable intPtr is totally\nseparate from the lifetime of the heap block, and the drawing needs to reflect that\ndifference."}, "literal_block": [{"@xml:space": "preserve", "#text": "void Heap1() {\n  int* intPtr;\n  // Allocates local pointer local variable (but not its pointee)\n  // T1"}, {"@xml:space": "preserve", "#text": "// Allocates heap block and stores its pointer in local variable.\n// Dereferences the pointer to set the pointee to 42.\nintPtr = malloc(sizeof(int));\n*intPtr = 42;\n// T2"}, {"@xml:space": "preserve", "#text": "// Deallocates heap block making the pointer bad.\n// The programmer must remember not to use the pointer\n// after the pointee has been deallocated (this is\n// why the pointer is shown in gray).\nfree(intPtr);\n// T3"}], "raw": [{"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsafig": "null"}]}, {"@ids": "simple-heap-observations", "@names": "simple\\ heap\\ observations", "title": "Simple Heap Observations", "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": {"literal": ["intPtr", "intPtr"], "#text": "After the allocation call allocates the block in the heap. The\nprogram stores the pointer to the block in the local variable\n. The block is the \"pointee\" and  is its pointer\nas shown at T2. In this state, the pointer may be dereferenced\nsafely to manipulate the pointee. The pointer/pointee rules from\nSection 1 still apply, the only difference is how the pointee is\ninitially allocated."}}, {"paragraph": {"literal": ["malloc()", "intPtr", "intPtr"], "#text": "At T1 before the call to ,  is uninitialized\ndoes not have a pointee  at this point  \"bad\" in the\nsame sense as discussed in Section 1. As before, dereferencing such\nan uninitialized pointer is a common, but catastrophic\nerror. Sometimes this error will crash immediately (lucky). Other\ntimes it will just slightly corrupt a random data structure\n(unlucky)."}}, {"paragraph": {"literal": "free()", "#text": "The call to  deallocates the pointee as shown at\nT3. Dereferencing the pointer after the pointee has been deallocated\nis an error. Unfortunately, this error will almost never be flagged\nas an immediate run-time error. 99% of the time the dereference will\nproduce reasonable results 1% of the time the dereference will\nproduce slightly wrong results. Ironically, such a rarely appearing\nbug is the most difficult type to track down."}}, {"paragraph": "When the function exits, its local variable intPtr will be\nautomatically deallocated following the usual rules for local\nvariables (Section 2). So this function has tidy memory behavior\nall of the memory it allocates while running (its local\nvariable, its one heap block) is deallocated by the time it exits."}]}}, {"@ids": "heap-array", "@names": "heap\\ array", "title": "Heap Array", "paragraph": {"literal": ["sizeof()", "struct fraction"], "#text": "In the C language, it's convenient to allocate an array in the heap,\nsince C can treat any pointer as an array.\nThe size of the array memory block is the size of each element (as\ncomputed by the  operator) multiplied by the number of\nelements (See CS Education Library/101 The C Language, for a complete\ndiscussion of C, and arrays and pointers in particular).\nSo the following code heap allocates an array of 100\n's in the heap, sets them all to 22/7, and\ndeallocates the heap array."}, "literal_block": {"@xml:space": "preserve", "#text": "void HeapArray() {\n  struct fraction* fracts;\n  int i;\n  // allocate the array\n  fracts = malloc(sizeof(struct fraction) * 100);\n  // use it like an array -- in this case set them all to 22/7\n  for (i=0; i<99; i++) {\n    fracts[i].numerator = 22;\n    fracts[i].denominator = 7;\n  }\n  // Deallocate the whole array\n  free(fracts);\n}"}}, {"@ids": "heap-string-example", "@names": "heap\\ string\\ example", "title": "Heap String Example", "paragraph": {"literal": "StringCopy()", "#text": "Here is a more useful heap array example. The  function takes a C string,\nmakes a copy of that string in the heap, and returns a pointer to the new string. The caller\ntakes over ownership of the new string and is responsible for freeing it."}, "literal_block": {"@xml:space": "preserve", "#text": "/*\n Given a C string, return a heap allocated copy of the string.\n Allocate a block in the heap of the appropriate size,\n copies the string into the block, and returns a pointer to the block.\n The caller takes over ownership of the block and is responsible\n for freeing it.\n*/\nchar* StringCopy(const char* string) {\n  char* newString;\n  int len;\n  len = strlen(string) + 1;   // +1 to account for the '\\0'\n  newString = malloc(sizeof(char)*len);         // elem-size * number-of-elements\n  assert(newString != NULL);    // simplistic error check (a good habit)\n  strcpy(newString, string);    // copy the passed in string to the block\n\n  return(newString);    // return a ptr to the block\n}"}, "section": {"@ids": "heap-string-observations", "@names": "heap\\ string\\ observations", "title": "Heap String Observations", "paragraph": {"literal": "StringCopy()", "#text": "takes advantage of both of the key features of heap memory:"}, "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": {"strong": "Size", "literal": ["StringCopy()", "malloc()", "sizeof(char)", "char", "element-size *\nnumber-of-elements"], "#text": ".  specifies, at run-time, the exact size of\nthe block needed to store the string in its call to\n. Local memory cannot do that since its size is\nspecified at compile-time. The call to  is not\nreally necessary, since the size of    is 1 by\ndefinition. In any case, the example demonstrates the correct\nformula for the size of an array block which is  ."}}, {"paragraph": {"strong": "Lifetime", "literal": "StringCopy()", "#text": ".   allocates the block, but then passes\nownership of it to the caller. There is no call to free(), so the\nblock continues to exist even after the function exits. Local memory\ncannot do that. The caller will need to take care of the\ndeallocation when it is finished with the string."}}]}}}, {"@ids": "memory-leaks", "@names": "memory\\ leaks", "title": "Memory Leaks", "paragraph": {"title_reference": "memory leak", "#text": "What happens if some memory is heap allocated, but never deallocated?\nA program which forgets to deallocate a block is said to have a\n which may or may not be a serious problem.\nThe result will be that the heap gradually fill up as there\ncontinue to be allocation requests, but no deallocation requests to\nreturn blocks for re-use.\nFor a program which runs, computes something, and exits immediately, memory leaks\nare not usually a concern. Such a \"one shot\" program could omit all of its deallocation\nrequests and still mostly work. Memory leaks are more of a problem for a program which\nruns for an indeterminate amount of time. In that case, the memory leaks can gradually\nfill the heap until allocation requests cannot be satisfied, and the program stops working\nor crashes. Many commercial programs have memory leaks, so that when run for long\nenough, or with large data-sets, they fill their heaps and crash. Often the error detection\nand avoidance code for the heap-full error condition is not well tested, precisely because\nthe case is rarely encountered with short runs of the program  that's why filling the\nheap often results in a real crash instead of a polite error message. Most compilers have a\n\"heap debugging\" utility which adds debugging code to a program to track every\nallocation and deallocation. When an allocation has no matching deallocation, that's a\nleak, and the heap debugger can help you find them."}}, {"@ids": "ownership", "@names": "ownership", "title": "Ownership", "paragraph": {"literal": ["StringCopy()", "StringCopy()", "StringCopy()", "StringCopy()", "StringCopy()"], "#text": "allocates the heap block, but it does not deallocate it. This is so the caller\ncan use the new string. However, this introduces the problem that somebody does need to\nremember to deallocate the block, and it is not going to be . That is why the\ncomment for  mentions specifically that the caller is taking on\nownership  of the block. Every block of memory has exactly one \"owner\" who takes responsibility for\ndeallocating it. Other entities can have pointers, but they are just sharing. There's only\none owner, and the comment for  makes it clear that ownership is being\npassed from  to the caller. Good documentation always remembers to\ndiscuss the ownership rules which a function expects to apply to its parameters or return\nvalue. Or put the other way, a frequent error in documentation is that it forgets to\nmention, one way or the other, what the ownership rules are for a parameter or return\nvalue. That's one way that memory errors and leaks are created."}, "section": {"@ids": "ownership-models", "@names": "ownership\\ models", "title": "Ownership Models", "paragraph": "The two common patterns for ownership are:", "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": {"strong": "Caller ownership", "#text": ".  The caller owns its own memory. It may pass a\npointer to the callee for sharing purposes, but the caller retains\nownership. The callee can access things while it runs, and\nallocate and deallocate its own memory, but it should not disrupt\nthe caller's memory."}}, {"paragraph": {"strong": "Callee allocated and returned", "literal": "StringCopy()", "#text": ". The callee allocates some memory\nand returns it to the caller. This happens because the result of the\ncallee computation needs new memory to be stored or\nrepresented. The new  memory is passed to the caller so they can see\nthe result, and the caller    must take over ownership of the\nmemory. This is the pattern demonstrated in ."}}]}}}, {"@ids": "heap-memory-summary", "@names": "heap\\ memory\\ summary", "title": "Heap Memory Summary", "paragraph": "Heap memory provides greater control for the programmer  the\nblocks of memory can be requested in any size, and they remain\nallocated until they are deallocated explicitly.\nHeap memory can be passed back to the caller since it is not deallocated on exit, and it\ncan be used to build linked structures such as linked lists and binary trees. The\ndisadvantage of heap memory is that  the program must make explicit allocation and\ndeallocate calls to manage the heap memory. The heap memory does not operate\nautomatically and conveniently the way local memory does."}]}}