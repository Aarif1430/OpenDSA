<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document dupnames="kd\ trees" ids="kd-trees" source="&lt;string&gt;" title="KD Trees"><title>KD Trees</title><subtitle dupnames="kd\ trees" ids="id1">KD Trees</subtitle><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><paragraph>The <title_reference>kd tree</title_reference> is a modification to the <title_reference>BST</title_reference> that allows
for efficient processing of
<title_reference>multi-dimensional search keys &lt;multi-dimensional search key&gt;</title_reference>.
The kd tree differs from the BST in that each level of the kd tree
makes branching decisions based on a particular search key associated
with that level, called the <title_reference>discriminator</title_reference>.
In principle, the kd tree could be used to unify key searching across
any arbitrary set of keys such as name and zipcode.
But in practice, it is nearly always used to support search on
multi-dimensional coordinates, such as locations in 2D or 3D space.
We define the discriminator at level <title_reference>i</title_reference> to be
<title_reference>i</title_reference> mod <title_reference>k</title_reference> for <title_reference>k</title_reference> dimensions.
For example, assume that we store data organized by
<title_reference>xy</title_reference>-coordinates.
In this case, <title_reference>k</title_reference> is 2 (there are two coordinates),
with the <title_reference>x</title_reference>-coordinate field arbitrarily designated key 0,
and the <title_reference>y</title_reference>-coordinate field designated key 1.
At each level, the discriminator alternates between <title_reference>x</title_reference> and
<title_reference>y</title_reference>.
Thus, a node <title_reference>N</title_reference> at level 0 (the root) would have in its left
subtree only nodes whose <title_reference>x</title_reference> values are less than
<title_reference>N_x</title_reference> (because <title_reference>x</title_reference> is search key 0, and
<title_reference>0 mod 2 = 0</title_reference>).
The right subtree would contain nodes whose <title_reference>x</title_reference> values are
greater than <title_reference>N_x</title_reference>.
A node <title_reference>M</title_reference> at level 1 would have in its left subtree only
nodes whose <title_reference>y</title_reference> values are less than <title_reference>M_y</title_reference>.
There is no restriction on the relative values of <title_reference>M_x</title_reference> and the
<title_reference>x</title_reference> values of <title_reference>M</title_reference> 's descendants, because branching
decisions made at <title_reference>M</title_reference> are based solely on the <title_reference>y</title_reference>
coordinate.
Figure <title_reference>Figure #kdExamp</title_reference> shows an example of how a collection
of two-dimensional points would be stored in a kd tree.</paragraph><target refid="kdexamp"></target><raw format="xml" ids="kdexamp" names="kdexamp" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>In Figure <title_reference>Figure #kdExamp</title_reference>, the region containing the points
is (arbitrarily) restricted to a <title_reference>128 times 128</title_reference> square, and
each internal node splits the search space.
Each split is shown by a line, vertical for nodes with
<title_reference>x</title_reference> discriminators and horizontal for nodes with <title_reference>y</title_reference>
discriminators.
The root node splits the space into two parts;
its children further subdivide the space into smaller parts.
The children's split lines do not cross the root's split line.
Thus, each node in the kd tree helps to decompose the space into
rectangles that show the extent of where nodes can fall in the
various subtrees.</paragraph><paragraph>Searching a kd tree for the record with a specified xy-coordinate
is like searching a BST, except that each level of the
kd tree is associated with a particular discriminator.</paragraph><topic><title>Example</title><paragraph>Consider searching the kd tree for a
record located at <title_reference>P = (69, 50)</title_reference>.
First compare <title_reference>P</title_reference> with the point stored at
the root (record <title_reference>A</title_reference> in Figure <title_reference>Figure #kdExamp</title_reference>).
If <title_reference>P</title_reference> matches the location of A`,
then the search is successful.
In this example the positions do not match
(<title_reference>A</title_reference> 's location (40, 45) is not the same as (69, 50)),
so the search must continue.
The <title_reference>x</title_reference> value of <title_reference>A</title_reference> is compared with that of
<title_reference>P</title_reference> to determine in which direction to branch.
Because <title_reference>A_x</title_reference>'s value of 40 is less than
<title_reference>P</title_reference>'s <title_reference>x</title_reference> value of 69, we branch to the right subtree
(all cities with <title_reference>x</title_reference> value greater than or equal to 40 are in
the right subtree).
<title_reference>A_y</title_reference> does not affect the decision on which way to
branch at this level.
At the second level, <title_reference>P</title_reference> does not match record <title_reference>C</title_reference>'s
position, so another branch must be taken.
However, at this level we branch based on the relative <title_reference>y</title_reference>
values of point <title_reference>P</title_reference> and record <title_reference>C</title_reference>
(because <title_reference>1 mod 2 = 1</title_reference>, which corresponds to the
<title_reference>y</title_reference>-coordinate).
Because <title_reference>C_y</title_reference>'s value of 10 is less than <title_reference>P_y</title_reference>'s value
of 50, we branch to the right.
At this point, <title_reference>P</title_reference> is compared against the position
of <title_reference>D</title_reference>.
A match is made and the search is successful.</paragraph><paragraph>If the search process reaches a <literal>NULL</literal> pointer, then
that point is not contained in the tree.
Here is a kd tree search implementation,
equivalent to the <literal>findhelp</literal> function of the BST class.
<literal>KD</literal> class private member <literal>D</literal> stores the key's dimension.</paragraph></topic><literal_block xml:space="preserve">private E findhelp(KDNode&lt;E&gt; rt, int[] key, int level) {
  if (rt == null) return null;
  E it = rt.element();
  int[] itkey = rt.key();
  if ((itkey[0] == key[0]) &amp;&amp; (itkey[1] == key[1]))
    return rt.element();
  if (itkey[level] &gt; key[level])
    return findhelp(rt.left(), key, (level+1)%D);
  else
    return findhelp(rt.right(), key, (level+1)%D);
}</literal_block><paragraph>Inserting a new node into the kd tree is similar to
BST insertion.
The kd tree search procedure is followed until a <literal>NULL</literal> pointer is
found, indicating the proper place to insert the new node.</paragraph><topic><title>Example</title><paragraph>Inserting a record at location (10, 50) in the
kd tree of Figure <title_reference>Figure #kdExamp</title_reference> first requires a search
to the node containing record <title_reference>B</title_reference>.
At this point, the new record is inserted into <title_reference>B</title_reference>'s left
subtree.</paragraph></topic><paragraph>Deleting a node from a kd tree is similar to deleting from a BST,
but slightly harder.
As with deleting from a BST, the first step is to find the node
(call it <title_reference>N</title_reference>) to be deleted.
It is then necessary to find a descendant of <title_reference>N</title_reference> which can be
used to replace <title_reference>N</title_reference> in the tree.
If <title_reference>N</title_reference> has no children, then <title_reference>N</title_reference> is replaced with a
<literal>NULL</literal> pointer.
Note that if <title_reference>N</title_reference> has one child that in turn has children, we
cannot simply assign <title_reference>N</title_reference>'s parent to point to <title_reference>N</title_reference>'s
child as would be done in the BST.
To do so would change the level of all nodes in the subtree, and thus
the discriminator used for a search would also change.
The result is that the subtree would no longer be a kd tree because a
node's children might now violate the BST property for that
discriminator.</paragraph><paragraph>Similar to BST deletion, the record stored in <title_reference>N</title_reference> should
be replaced either by the record in <title_reference>N</title_reference>'s right subtree with
the least value of &lt;var&gt;N&lt;/var&gt;'s discriminator, or by the record in
<title_reference>N</title_reference>'s left subtree with the greatest value for this
discriminator.
Assume that <title_reference>N</title_reference> was at an odd level and therefore <title_reference>y</title_reference> is
the discriminator.
<title_reference>N</title_reference> could then be replaced by the record in its right subtree
with the least <title_reference>y</title_reference> value (call it <title_reference>Y_{min}</title_reference>).
The problem is that &lt;var&gt;Y&lt;/var&gt;&lt;sub&gt;min&lt;/sub&gt; is not necessarily the
leftmost node, as it would be in the BST.
A modified search procedure to find the least <title_reference>y</title_reference> value in the
left subtree must be used to find it instead.
The implementation for <literal>findmin</literal> is shown next.
A recursive call to the delete routine will then remove
:math`Y_{min}` from the tree.
Finally, <title_reference>Y_{min}</title_reference>'s record is substituted for the
record in node <title_reference>N</title_reference>.</paragraph><literal_block xml:space="preserve">private KDNode&lt;E&gt;
findmin(KDNode&lt;E&gt; rt, int descrim, int level) {
  KDNode&lt;E&gt; temp1, temp2;
  int[] key1 = null;
  int[] key2 = null;
  if (rt == null) return null;
  temp1 = findmin(rt.left(), descrim, (level+1)%D);
  if (temp1 != null) key1 = temp1.key();
  if (descrim != level) {
    temp2 = findmin(rt.right(), descrim, (level+1)%D);
    if (temp2 != null) key2 = temp2.key();
    if ((temp1 == null) || ((temp2 != null) &amp;&amp;
                   (key1[descrim] &gt; key2[descrim])))
    temp1 = temp2;
    key1 = key2;
  } // Now, temp1 has the smaller value
  int[] rtkey = rt.key();
  if ((temp1 == null) || (key1[descrim] &gt; rtkey[descrim]))
    return rt;
  else
    return temp1;
}</literal_block><paragraph>In <literal>findmin</literal>, on levels using the minimum value's discriminator,
branching is to the left.
On other levels, both children's subtrees must be visited.
Helper function <literal>min</literal> takes two nodes and a discriminator as
input, and returns the node with the smaller value in that
discriminator.</paragraph><paragraph>Note that we can replace the node to be deleted with the least-valued
node from the right subtree only if the right subtree exists.
If it does not, then a suitable replacement must be found in the left
subtree.
Unfortunately, it is not satisfactory to replace <title_reference>N</title_reference>'s record
with the record having the greatest value for the discriminator in the
left subtree, because this new value might be duplicated.
If so, then we would have equal values for the discriminator in
<title_reference>N</title_reference>'s left subtree, which violates the ordering rules for the
kd tree.
Fortunately, there is a simple solution to the problem.
We first move the left subtree of node <title_reference>N</title_reference> to become the
right subtree (i.e., we simply swap the values of <title_reference>N</title_reference>'s left
and right child pointers).
At this point, we proceed with the normal deletion process, replacing
the record of &lt;var&gt;N&lt;/var&gt; to be deleted with the record containing
the <strong>least</strong> value of the discriminator from what is now
<title_reference>N</title_reference>'s right subtree.</paragraph><paragraph>Assume that we want to print out a list of all records that are within
a certain distance <title_reference>d</title_reference> of a given point <title_reference>P</title_reference>.
We will use Euclidean distance, that is, point <title_reference>P</title_reference> is defined
to be within distance <title_reference>d</title_reference> of point <title_reference>N</title_reference>
if <title_reference>sqrt{(P_x - N_x)^2 + (P_y - N_y)^2} leq d.</title_reference></paragraph><paragraph>If the search process reaches a node whose key value for the
discriminator is more than <title_reference>d</title_reference> above the corresponding value in
the search key, then it is not possible that any record in the right
subtree can be within distance <title_reference>d</title_reference> of the search key because all
key values in that dimension are always too great.
Similarly, if the current node's key value in the discriminator
is <title_reference>d</title_reference> less than that for the search key value, then no record in
the left subtree can be within the radius.
In~such cases, the subtree in question need not be searched,
potentially saving much time.
In the average case, the number of nodes that must be visited during a
range query is linear on the number of data records that fall within
the query circle.</paragraph><topic><title>Example</title><paragraph>We will now find all cities in the kd tree of
Figure <title_reference>Figure #kdSearch</title_reference> within 25 units of the point
(25, 65).
The search begins with the root node, which contains record
<title_reference>A</title_reference>.
Because (40, 45) is exactly 25 units from the search point, it will
be reported.
The search procedure then determines which branches of the tree to
take.
The search circle extends to both the left and the right of
<title_reference>A</title_reference>'s (vertical) dividing line, so both branches of the tree
must be searched.
The left subtree is processed first.
Here, record <title_reference>B</title_reference> is checked and found to fall within the
search circle.
Because the node storing <title_reference>B</title_reference> has no children, processing of
the left subtree is complete.
Processing of <title_reference>A&lt;</title_reference>'s right subtree now begins.
The coordinates of record <title_reference>C</title_reference> are checked and found not to
fall within the circle.
Thus, it should not be reported.
However, it is possible that cities within <title_reference>C</title_reference>'s subtrees
could fall within the search circle even if <title_reference>C</title_reference> does not.
As <title_reference>C</title_reference> is at level 1, the discriminator at this level is the
<title_reference>y</title_reference>-coordinate.
Because <title_reference>65-25 &gt; 10</title_reference>, no record in <title_reference>C</title_reference>'s left subtree
(i.e., records above <title_reference>C</title_reference>) could possibly be in the search
circle.
Thus, <title_reference>C</title_reference>'s left subtree (if it had one) need not be
searched.
However, cities in <title_reference>C</title_reference>'s right subtree could fall within the
circle.
Thus, search proceeds to the node containing record <title_reference>D</title_reference>.
Again, <title_reference>D</title_reference> is outside the search circle.
Because <title_reference>25+25 &lt; 69</title_reference>, no record in <title_reference>D&lt;</title_reference>'s right subtree
could be within the search circle.
Thus, only <title_reference>D</title_reference>'s left subtree need be searched.
This leads to comparing record <title_reference>E</title_reference>'s coordinates against the
search circle.
Record <title_reference>E</title_reference> falls outside the search circle, and processing is
complete.
So we see that we only search subtrees whose rectangles fall within
the search circle.</paragraph></topic><target refid="kdsearch"></target><raw format="xml" ids="kdsearch" names="kdsearch" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>Here is an implementation for the region search method.</paragraph><literal_block xml:space="preserve">private void rshelp(KDNode&lt;E&gt; rt, int[] point,
                    int radius, int lev) {
  if (rt == null) return;
  int[] rtkey = rt.key();
  if (InCircle(point, radius, rtkey))
    System.out.println(rt.element());
  if (rtkey[lev] &gt; (point[lev] - radius))
    rshelp(rt.left(), point, radius, (lev+1)%D);
  if (rtkey[lev] &lt; (point[lev] + radius))
    rshelp(rt.right(), point, radius, (lev+1)%D);
}</literal_block><paragraph>When a node is visited, function <literal>InCircle</literal> is used to
check the Euclidean distance between the node's record and the query
point.
It is not enough to simply check that the differences between the
<title_reference>x</title_reference>- and <title_reference>y</title_reference>-coordinates are each less than the query
distances because the the record could still be outside the search
circle, as illustrated by Figure <title_reference>Figure #InCirc</title_reference>.</paragraph><target refid="incirc"></target><raw format="xml" ids="incirc" names="incirc" xml:space="preserve"><odsafig>null</odsafig></raw><paragraph>Here is a visualization of building a kd-tree.
&lt;/p&gt;</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="kd-treeAV"
    long_name="kd-treeAV"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><paragraph>Here is a version where you can click to get the node inserted.</paragraph><raw format="xml" xml:space="preserve"><todo>null</todo></raw><raw format="xml" xml:space="preserve"><avembed
    type="ss"
    exer_name="kd-interact"
    long_name="kd-interact"
    points="0.0"
    required="True"
    threshold="1.0">
</avembed>
</raw><raw format="xml" xml:space="preserve"><todo>null</todo></raw><footnote auto="1" ids="id2" names="1"><label>1</label><paragraph>A more efficient computation is
<title_reference>(P_x - N_x)^2 + (P_y - N_y)^{2} leq d^{2}</title_reference>.
This avoids performing a square root function.</paragraph></footnote></document>