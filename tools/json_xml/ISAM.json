{"document": {"@ids": "isam", "@names": "isam", "@source": "<string>", "@title": "ISAM", "title": "ISAM", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@ids": "isamfig", "@names": "isamfig", "@xml:space": "preserve", "odsafig": "null"}], "paragraph": [{"math": ["\\mathrm{B}^+", "\\mathrm{B}^+"], "#text": "How do we handle large databases that require frequent update?\nThe main problem with the linear index is that it is a single, large\narray that does not adjust well to updates because a single update can\nrequire changing the position of every key in the index.\nInverted lists reduce this problem, but they are only suitable for\nsecondary key indices with many fewer secondary key values than records.\nThe linear index would perform well as a primary key index if it could\nsomehow be broken into pieces such that individual updates affect only\na part of the index.\nThis concept will be pursued throughout the rest of this chapter,\neventually culminating in the\n Tree\nthe most widely used indexing method today.\nBut first, we begin by studying ISAM, an early attempt to solve the\nproblem of large databases requiring frequent update.\nIts weaknesses help to illustrate why the  Tree\nworks so well."}, "Before the invention of effective tree indexing\nschemes, a variety of disk-based indexing methods were in use.\nAll were rather cumbersome, largely because no adequate method for\nhandling updates was known.\nTypically, updates would cause the index to degrade in performance.\nISAM is one example of such an index and was\nwidely used by IBM prior to adoption of the B-tree.", {"title_reference": ["linear index", "Figure #ISAMfig", "cylinders <cylinder>", "cylinder overflow", "cylinder index"], "#text": "ISAM is based on a modified form of the , as\nillustrated by Figure .\nRecords are stored in sorted order by primary key.\nThe disk file is divided among a number of\n on disk.\nEach cylinder holds a section of the list in sorted order.\nInitially, each cylinder is not filled to capacity, and the extra\nspace is set aside in the .\nIn memory is a table listing the lowest key value stored in each\ncylinder of the file.\nEach cylinder contains a table listing the lowest key value for\neach block in that cylinder, called the .\nWhen new records are inserted, they are placed in the correct\ncylinder's overflow area (in effect, a cylinder acts as a bucket).\nIf a cylinder's overflow area fills completely, then a system-wide\noverflow area is used.\nSearch proceeds by determining the proper cylinder from the\nsystem-wide table kept in main memory.\nThe cylinder's block table is brought in from disk and\nconsulted to determine the correct block.\nIf the record is found in that block, then the search is complete.\nOtherwise, the cylinder's overflow area is searched.\nIf that is full, and the record is not found, then the system-wide\noverflow is searched."}, "After initial construction of the database,\nso long as no new records are inserted or deleted, access is\nefficient because it requires only two disk fetches.\nThe first disk fetch recovers the block table for the desired\ncylinder.\nThe second disk fetch recovers the block that, under good conditions,\ncontains the record.\nAfter many inserts, the overflow list becomes too long, resulting in\nsignificant search time as the cylinder overflow area fills up.\nUnder extreme conditions, many searches might eventually lead to the\nsystem overflow area.\nThe \"solution\" to this problem is to periodically reorganize the\nentire database.\nThis means re-balancing the records among the cylinders, sorting\nthe records within each cylinder, and updating both the system\nindex table and the within-cylinder block table.\nSuch reorganization was typical of database systems during the 1960s\nand would normally be done each night or weekly."], "target": {"@refid": "isamfig"}}}