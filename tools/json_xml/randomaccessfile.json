{"document": {"@ids": "random-access-files-in-java", "@names": "random\\ access\\ files\\ in\\ java", "@source": "<string>", "@title": "Random Access Files In Java", "title": "Random Access Files In Java", "subtitle": {"@ids": "understanding-file-i-o", "@names": "understanding\\ file\\ i/o", "#text": "Understanding File I/O"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": {"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, "paragraph": [{"raw": {"@format": "html", "@xml:space": "preserve", "#text": "<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html\" target = \"_blank\">RandomAccessFile API</a>"}, "#text": "In earlier tutorials we saw how we can use Java's scanner class to read sequential\ntext files. Scanners are great for reading files, but we can take a\nstep farther out and conceptualize our data even more abstractly, instead of\nreading in files as strings we can instead read the raw bytes and then write\nthose bytes to the file. By doing this we have no limits on the types of data\nwe can store. Additionally, RandomAccessFiles, allow reading and writing anywhere\nwithing the file, jumping to any legal location within the file itself.\nBefore reading this tutorial be sure to check the ."}, "Before getting started using the RandomAccessFile class, be sure you understand\nthe following concepts.", "1) Reading - Read a chunk of data (bytes) at a location on disk. These bytes\ncan be located anywhere within the file.", "2) Writing - Write a chunk of data (bytes) at a location on disk. We can \"write\"\nanywhere within the file.", "3) File Pointer - A number representing the byte position we are at in the file.\nWe can manipulate the File Pointer to point anywhere within our file. A\nRandomAccessFile should be trated similar to an array of bytes. It's index will\nstart at 0 and it's last position will be one less than the total size of the\nfile.", "One very important thing to note about the RandomAccessFile class. It is very\neasy to seek past the end of the file and write to that location (as the RandomAccessFile\nclass assumes that one might wish to grow a file), however, if the file pointer is\nmoved past the end of file and written to at that location, if the user tries to\nread it may encounter the EndOfFile or EOF at the old size and as such will throw\nan error."], "substitution_definition": {"@names": "external_link", "raw": {"@format": "html", "@xml:space": "preserve", "#text": "<a href=\"https://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html\" target = \"_blank\">RandomAccessFile API</a>"}}, "section": {"@ids": "using-randomaccessfile-class", "@names": "using\\ randomaccessfile\\ class", "title": "Using RandomAccessFile Class", "paragraph": ["Consider the code example below. It will generate a file of a size 0 to 999\nbytes and it will then fill those bytes in order with numbers from 65 to 90\n(randomly chosen). The program will output a plaintext file randomly filled with\ncapital English alphabet letters. Why does this work? Remember that to a computer\ndata is nothing but a collection of bits. For ASCII text we have a set of\ncharacters whose numeric values range from 0 to 255 (or the maximum value of one\nbyte). The capital letters in ASCII range from values 65 to 90, thus when I\nwrite a value of 65-90 to a file it will be interpreted as a letter.", "So we have generated a file and filled it with bytes that are randomly created.\nHow do we read the file? The RandomAccessFile class has a number of read\nfunctions. The following example demos a few below. The example starts by reading\nin the entire file (generated from above) and outputing the contents to the\nterminal. The program then randomly generates a new position in the file and\nsets our file pointer to there, outputing the position, the int value of the\nbyte, and the character it represents. Finally the program creates a new byte\narray the size of the file and attempts to read that many bytes, using the read\nmethod. As the comments explain, the read method returns an int representing\nhow many bytes were actually read. After reading in the array, the program then\noutputs the position read started at, the amount of bytes read and the size of\nthe array given to read. Running this program on my machine (after generating\na file from the above code), produced the following output.", "There you go, reading and writing using bytes!"], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}], "literal_block": {"@xml:space": "preserve", "#text": "EXUHIULUQKLZICYUQIKMWZCQPXKYBEHKCJVUIBCIYHKJPCPENWXJLZEMDHVLPNBXDOTNVZIUYNMQTLZVTITTVMMLDWJTMEHSUZUBTSEQPATLOQRUOODL\nSet pos to 111, value 85, character U\nTried reading at position 112, read 4 bytes, array was size 116"}}}}