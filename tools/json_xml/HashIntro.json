{"document": {"@dupnames": "introduction", "@ids": "introduction", "@source": "<string>", "@title": "Introduction", "title": "Introduction", "subtitle": {"@dupnames": "introduction", "@ids": "id1", "#text": "Introduction"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Hashing/hashIntroCON.css"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "hashIntroCON1", "@long_name": "hashIntroCON1", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/hashIntroCON.js"}], "paragraph": [{"math": ["O(\\log n)", "n", "O(\\log n)"], "#text": "Hashing is a method for storing and retrieving records from a database.\nIt lets you insert, delete, and search for records based on a search\nkey value.\nWhen properly implemented, these operations can be performed\nin constant time.\nIn fact, a properly tuned hash system typically looks at only\none or two records for each search, insert, or delete operation.\nThis is far better than the  average cost required\nto do a binary search on a sorted array of  records,\nor the  average cost required to do an operation\non a binary search tree.\nHowever, even though hashing is based on a very simple idea,\nit is surprisingly difficult to implement properly.\nDesigners need to pay careful attention to all of the details\ninvolved with implementing a hash system."}, {"title_reference": ["hash table", "hash function <hash function> <HashFuncExamp>", "slot"], "literal": ["HT", "K", "HT", "K", "HT"], "strong": "h", "math": ["M", "M-1"], "#text": "A hash system stores records in an array called a ,\nwhich we will call .\nHashing works by performing a computation on a search key\n in a way that is intended to identify the position in\n that contains the record with key .\nThe function that does this calculation is called the\n,\nand will be denoted by the letter .\nSince hashing schemes place records in the table in whatever order\nsatisfies the needs of the address calculation, records are\nnot ordered by value.\nA position in the hash table is also known as a .\nThe number of slots in hash table  will be denoted by the\nvariable  with slots numbered from 0 to ."}, {"literal": ["K", "HT[i]", "K"], "math": ["h", "i = \\mathbf{h}(K)", "0 <= i < M"], "#text": "The goal for a hashing system is to arrange things such that,\nfor any key value  and some hash function ,\n is a slot in the table such that\n,\nand we have the key of the record stored at\n equal to ."}, {"literal": "K", "strong": "For applications where all search is done by exact-match queries,\nhashing is the search method of choice because it is extremely\nefficient when implemented correctly.", "#text": "Hashing is not good for applications where multiple\nrecords with the same key value are permitted.\nHashing is not a good method for answering range searches.\nIn other words, we cannot easily find all records (if any) whose key\nvalues fall within a certain range.\nNor can we easily find the record with the minimum or maximum key\nvalue, or visit the records in key order.\nHashing is most appropriate for answering the question, 'What record,\nif any, has key value ?'\n\nAs this tutorial shows, however, there are many approaches\nto hashing and it is easy to devise an inefficient implementation.\nHashing is suitable for both in-memory and disk-based searching and\nis one of the two most widely used methods for organizing large\ndatabases stored on disk (the other is the B-tree)."}, {"math": ["n", "n-1", "\\mathbf{h}(k) = k"], "literal": ["k", "HT[k]", "k", "HT[k]"], "#text": "As a simple (though unrealistic) example of hashing,\nconsider storing  records, each with a unique key value in\nthe range 0 to .\nA record with key  can be stored in\n, and so the hash function is\n.\nTo find the record with key value , look in\n."}, {"strong": ["h", "h"], "math": ["k_1", "k_2", "\\mathbf{h}(k_1) = \\beta = \\mathbf{h}(k_2)", "\\beta", "k_1", "k_2", "\\beta"], "title_reference": "collision", "#text": "In most applications, there are many more values in the key range\nthan there are slots in the hash table.\nFor a more realistic example, suppose the key can take any value in\nthe range 0 to 65,535 (i.e., the key is a two-byte unsigned integer),\nand that we expect to store approximately 1000 records at any given time.\nIt is impractical in this situation to use a hash table with\n65,536 slots, because then the vast majority of the slots would be\nleft empty.\nInstead, we must devise a hash function that allows us to store the\nrecords in a much smaller table.\nBecause the key range is larger than the size of the table,\nat least some of the slots must be mapped to from multiple key values.\nGiven a hash function  and two keys  and\n, if\n\nwhere  is a slot in\nthe table, then we say that  and  have a\n at slot  under hash function ."}, {"literal": "K", "#text": "Finding a record with key value  in a database organized by hashing\nfollows a two-step procedure:"}], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"math": "\\mathbf{h}(K)", "#text": "Compute the table location ."}}, {"paragraph": {"math": "\\mathbf{h}(K)", "literal": "K", "title_reference": "collision resolution <collision resolution> <HashCSimple>", "#text": "Starting with slot , locate the record\ncontaining key  using (if necessary) a\n\npolicy ."}}]}}}