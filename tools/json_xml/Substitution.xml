<?xml version="1.0" encoding="utf8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document ids="the-substitution-based-model-of-evaluation" names="the\ substitution-based\ model\ of\ evaluation" source="&lt;string&gt;" title="The Substitution-Based Model of Evaluation"><title>The Substitution-Based Model of Evaluation</title><comment xml:space="preserve">This file is part of the OpenDSA eTextbook project. See</comment><comment xml:space="preserve">http://algoviz.org/OpenDSA for more details.</comment><comment xml:space="preserve">Copyright (c) 2012-13 by the OpenDSA Project Contributors, and</comment><comment xml:space="preserve">distributed under an MIT open source license.</comment><raw format="xml" xml:space="preserve"><avmetadata>null</avmetadata></raw><raw format="xml" xml:space="preserve"><odsalink>AV/PL/main.css</odsalink></raw><section ids="substitution-algorithm" names="substitution\ algorithm"><title>Substitution Algorithm</title><paragraph>In this section, we continue our investigation of the semantics of the
lambda calculus. Now that we understand the meaning of each one of the
three types of lambda expressions (see
<title_reference>semantics-of-the-lambda-calculus</title_reference>), the meaning of free and
bound variables (see <title_reference>free-and-bound-variables</title_reference>) and how bound
variables can be systematically renamed (see <title_reference>alpha-conversion</title_reference>),
we have all of the tools we need to explain the meaning of function
calls in the lambda calculus. Note that, since functions are the only
entities in the lambda calculus, interpreting a lambda calculus
program boils down to executing function calls.</paragraph><paragraph>First, consider how you would execute the following function call in
your head:</paragraph><literal_block classes="code" xml:space="preserve">f(8)</literal_block><paragraph>You would first look up the definition of the function <title_reference>f</title_reference>, say:</paragraph><literal_block classes="code" xml:space="preserve">var f = function(x) { return  2 * x - 5; };</literal_block><paragraph>Then you could compute the value of <title_reference>f(8)</title_reference> by computing the
value of the body of <title_reference>f</title_reference> after substituting <title_reference>8</title_reference> for
<title_reference>x</title_reference> in it, yielding <title_reference>2*8 - 5 = 11</title_reference>. This intuitive
approach to evaluating function calls naturally leads to a
<emphasis>substitution-based model of interpretation</emphasis>. In this section, we
discuss a well-known algorithm for performing substitutions in the
lambda calculus.</paragraph><paragraph>Since both the body of a function and the argument of a function call
can be arbitrary lambda expressions, we need an algorithm that can
substitute any lambda expression <title_reference>a</title_reference> (the argument) for the
variable <title_reference>p</title_reference> (the parameter of the function) in the lambda
expression <title_reference>b</title_reference> (the body of the function). In this section, we
forget about the interpretation of <title_reference>a</title_reference>, <title_reference>p</title_reference> and <title_reference>b</title_reference>
as components of a function call. Instead, we describe the algorithm
in general terms, that is, as an algorithm to substitute <title_reference>a</title_reference> for
<title_reference>p</title_reference> in <title_reference>b</title_reference>, which we denote by:</paragraph><math_block xml:space="preserve">subst(a, p, b)</math_block><paragraph>where <title_reference>a</title_reference> and <title_reference>b</title_reference> are arbitrary lambda expressions and
<title_reference>p</title_reference> is any variable.</paragraph><paragraph>Note that <title_reference>subst(a, p, b)</title_reference> means "substitute <title_reference>a</title_reference> for
<title_reference>p</title_reference> in <title_reference>b</title_reference>" or equivalently, "replace <title_reference>p</title_reference> by
<title_reference>a</title_reference> in <title_reference>b</title_reference>. Whichever way you choose to phrase it,
<title_reference>b</title_reference> is always the expression inside which we are performing the
substitution, <title_reference>p</title_reference> is always the expression that gets taken out
of <title_reference>b</title_reference> and <title_reference>a</title_reference> is always the expression that gets
inserted into <title_reference>b</title_reference>.</paragraph><paragraph>Now, back to the substitution algorithm. Since <title_reference>b</title_reference> is an
arbitrary lambda expression, looking back at the BNF grammar for the
<title_reference>lambda calculus &lt;lambda calculus&gt; &lt;Semantics&gt;</title_reference>,
we see that we must
consider three cases for <title_reference>b</title_reference>, namely a variable, a lambda
abstraction or an application expression. Therefore, our description
of the algorithm is broken down into three numbered cases.</paragraph><paragraph><strong>Case 1:</strong> If <title_reference>b</title_reference> is a variable, say <title_reference>x</title_reference>, then
<title_reference>subst(a, p, b)</title_reference> becomes <title_reference>subst(a, p,x)</title_reference>. Recall that
<title_reference>p</title_reference> and <title_reference>x</title_reference> are generic variables. So we need to
distinguish two subcases. First, if <title_reference>p</title_reference> and <title_reference>x</title_reference> are the
same variable, say <title_reference>v</title_reference>, then <title_reference>subst(a,p,x)</title_reference> is really
<title_reference>subst(a,v,v)</title_reference>, whose value is <title_reference>a</title_reference>, because that is what
we get when we replace <title_reference>v</title_reference> by <title_reference>a</title_reference>. We call this part of the
algorithm <strong>Case 1a</strong>. Second, if <title_reference>p</title_reference> and <title_reference>x</title_reference> are two
different variables, then <title_reference>subst(a,p,x)</title_reference> is equal to <title_reference>x</title_reference>,
because the variable <title_reference>p</title_reference> does not occur in <title_reference>x</title_reference> and no
substitutions are needed or possible. We call this part of the
algorithm <strong>Case 1b</strong></paragraph><paragraph>Let's look at two examples of substitutions that belong to
Case 1. First, in <title_reference>subst(lambda x.x, u, v)</title_reference>, <title_reference>v</title_reference> is a
variable that is different from <title_reference>u</title_reference>. Therefore, this example
matches Case 1b, and the output of the algorithm is <title_reference>v</title_reference>. On the
other hand, <title_reference>subst(lambda y.(yx), u, u)</title_reference> falls into Case 1a,
since both <title_reference>p</title_reference> and <title_reference>b</title_reference> are equal to the same variable
<title_reference>u</title_reference>. So, the algorithm returns <title_reference>lambda y.(yx)</title_reference>.</paragraph><comment xml:space="preserve">.. inlineav:: substCase1b ss</comment><comment xml:space="preserve">show</comment><paragraph><strong>Case 2:</strong> To be completed</paragraph><paragraph><strong>Case 3:</strong> If <title_reference>b</title_reference> is an application expression, say
<title_reference>(e_1e_2)</title_reference>, where <title_reference>e_1</title_reference> and <title_reference>e_2</title_reference> are arbitrary
lambda expressions, then the value of <title_reference>subst(a,p,b)</title_reference>, really
<title_reference>subst(a,p,(e_1e_2))</title_reference>, is <title_reference>(subst(a,p,e_1)subst(a,p,e_2))</title_reference>, that is, the application expression that is obtained
by substituting <title_reference>a</title_reference> for <title_reference>p</title_reference> recursively in each component
of the original application expression.</paragraph><paragraph>As an example, consider <title_reference>subst(lambda y.(yx), u, (lambda
v.uu))</title_reference>. Since the expression we are substituting into (i.e., the
third one) is an application expression, the algorithm requires us to
return the application that results from recursively substituting
<title_reference>lambda y.(yx)</title_reference> for <title_reference>u</title_reference> in both components of this
application. Since we already performed these two substitutions in the
examples listed above, the final result of the algorithm is
<title_reference>(lambda v.lambda y.(yx)lambda y.(yx))</title_reference>.</paragraph></section><section ids="rp-15-part-2" names="rp\ 15\ part\ 2"><title>RP 15 part 2</title><paragraph>The following exercise is good practice for identifying which case
applies at each step of the substitution algorithm. To get credit for
this randomized problem, you must solve it correctly three times in
a row.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP15part2"
    long_name="RP15part2"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw></section><section ids="rp-15-part-3" names="rp\ 15\ part\ 3"><title>RP 15 part 3</title><paragraph>The following exercise will test your ability to complete a full
substitution by applying the algorithm scrupulously. To get credit for
this randomized problem, you must solve it correctly three times in
a row.</paragraph><raw format="xml" xml:space="preserve"><avembed
    type="ka"
    exer_name="RP15part3"
    long_name="RP15part3"
    points="1.0"
    required="True"
    threshold="5">
</avembed>
</raw><comment xml:space="preserve">.. odsascript:: AV/PL/AV/substCase1b.js</comment></section></document>