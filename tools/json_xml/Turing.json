{"document": {"@ids": "turing-machines", "@names": "turing\\ machines", "@source": "<string>", "@title": "Turing Machines", "title": "Turing Machines", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/SeniorAlgAnal/Turing1CON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/SeniorAlgAnal/Turing2CON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/SeniorAlgAnal/Turing3CON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/SeniorAlgAnal/TuringCopyCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/SeniorAlgAnal/TuringShiftCON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/SeniorAlgAnal/TuringExt1CON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/SeniorAlgAnal/TuringExt2CON.css"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/SeniorAlgAnal/TuringExt3CON.css"}], "section": [{"@ids": "a-general-model-of-computation", "@names": "a\\ general\\ model\\ of\\ computation", "title": "A General Model of Computation", "paragraph": ["We would like to define a general model of computation that is as\nsimple as possible.\nThe reason is that we want to be able to understand the limits of what\nis possible in computing, but that is rather hard to do with a\ncomplicated definition for a \"computer\" is.\nBut then, we need to be confident that whatever model we do pick, that\nit actually represents all of the fundamental capabilities of a\n\"computer\".", {"title_reference": "Turing machine", "emphasis": ["ability", "efficiency"], "#text": "\"State machines\" are simple to understand.\nThere are a number of different state machines, with a range of\ncapabilities.\nWe will discuss a particular one, called a .\nAs we define \"capability\", the key is , not ."}, "The necessary capabilites for any such \"machine\" are these:", {"title_reference": "states", "#text": "A Turing machine is defined as follows.\nIt has a tape, divided into squares, with a fixed left end and\nextending infinitely to the right.\nEach square can store one character.\nThe machine has a single I/O head that at any instant in time is \"on\"\none of the squares.\nThe control unit of the machine is defined by a set of abstract\n.\nAt any given instant, the machine is said to be\n\"in\" one of the states, and has a set of actions that can be performed\nwhen in that state.\nFrom the current state, the machine will read the symbol on the\ncurrent state, and can then do one of the following:"}, {"title_reference": "halt state", "#text": "By convention, the machine ceases to perate if the head moves off the\nleft end of the tape, or if the control unit sends the machine into a\nspecially designated ."}, {"title_reference": "alphabet", "math": "\\#", "#text": "The input to the machine is the intial contents of the tape, which is\ndescribed by listing all of the tape squares from the left to the\nrightmost non-blank tape.\nNaturally, there must be a finite number of non-blank symbols on the\ntape.\nThe  of the machine consists of some letters,\nincluding the special symbol  which means a blank symbol on the\ngiven square."}, {"math": ["K", "\\Sigma"], "#text": "A Turing machine is formally defined as a quadruple\n(, , $delta$, $s$) where"}, {"math": "\\#", "#text": "Note that including  in the language is for convenience\nonly.\nWe want to be able to read our specifications without being confused."}, {"math": ["q \\in K", "a \\in \\Sigma", "\\delta(q, a) = (p, b)", "q", "a", "p"], "#text": "If ,  and\n,\nthen when in state  and scanning ,\nenter state  and"}], "bullet_list": [{"@bullet": "*", "list_item": [{"paragraph": "Read"}, {"paragraph": "Write"}, {"paragraph": "Compute"}]}, {"@bullet": "*", "list_item": [{"paragraph": "Change the current symbol."}, {"paragraph": "Move the I/O head one square to either the left or the right."}]}, {"@bullet": "*", "list_item": [{"paragraph": {"math": ["K", "h"], "#text": "is a finite set of states (not including , the\nhalt state)."}}, {"paragraph": {"math": ["\\Sigma", "\\#", "L", "R"], "#text": "is an alphabet (containing , not \nor )."}}, {"paragraph": {"math": "s \\in K", "#text": "is the :term`initial state`."}}, {"paragraph": {"math": ["\\delta", "K \\times \\Sigma", "(K \\cup \\{h\\}) \\times (\\Sigma \\cup \\{L, R\\})"], "#text": "is a function from  to\n."}}]}], "enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": {"math": ["b \\in \\Sigma", "a", "b"], "#text": "If  then replace  with ."}}, {"paragraph": {"math": ["b", "L", "R"], "#text": "Else ( is  or ): move head."}}]}, "topic": [{"title": "Example", "paragraph": [{"math": "M = (K, \\Sigma, \\delta, s)", "#text": "where"}, {"math": ["(q_1, a)", "q_0", "\\delta"], "#text": "Note that state  cannot happen if the start state\nis .\nThis is included only for completness (to make  a\ntotal function."}, {"math": ["a", "\\#", "\\#"], "#text": "This machine will scan right, changing any  that it sees\nto a .\nWhen it first hits a , it will halt."}], "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": {"math": "K = \\{q_0, q_1\\}", "#text": ","}}, {"paragraph": {"math": "\\Sigma = \\{a, \\#\\}", "#text": ","}}, {"paragraph": {"math": "s = q_0"}}, {"paragraph": {"math": "\\delta ="}, "math_block": {"@xml:space": "preserve", "#text": "\\begin{array}{lll}\n\\hline\nq&\\sigma&\\delta(q, \\sigma)\\\\\n\\hline\nq_0&a&(q_1, \\#)\\\\\nq_0&\\#&(h, \\#)\\\\\nq_1&a&(q_0, a)\\\\\nq_1&\\#&(q_0, R)\\\\\n\\end{array}"}}]}}, {"title": "Example", "paragraph": [{"math": "M = (K, \\Sigma, \\delta, s)", "#text": "where"}, {"math": "\\#", "#text": "This machine will scan left until it encounters , and\nthen halt."}], "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": {"math": "K = \\{q_0\\}", "#text": ","}}, {"paragraph": {"math": "\\Sigma = \\{a, \\#\\}", "#text": ","}}, {"paragraph": {"math": "s = q_0", "#text": ","}}, {"paragraph": {"math": "\\delta ="}, "math_block": {"@xml:space": "preserve", "#text": "\\begin{array}{lll}\n\\hline\nq&\\sigma&\\delta(q, \\sigma)\\\\\n\\hline\nq_0&a&(q_0, L)\\\\\nq_0&\\#&(h, \\#)\\\\\n\\end{array}"}}]}}]}, {"@ids": "interpreting-turing-machines", "@names": "interpreting\\ turing\\ machines", "title": "Interpreting Turing Machines", "paragraph": [{"title_reference": "configuration", "#text": "A  for a Turing machine looks like this:"}, {"title_reference": "halted configuration", "math": ["q", "h"], "#text": "A  occurs when  is , the\nhalt state."}, {"title_reference": "hanging configuration", "#text": "A  occurs when the I/O head moves to the\nleft from the left-most square of the tape."}, {"title_reference": "computation", "math": "n \\geq 0", "#text": "A  is a sequence of configurations for some\nlength .\nExecution on the first machine example from the starting configuration\nshow would appear as follows:"}, {"math": ["M", "(s, \\#w\\underline{\\#})"], "strong": "halt on input :math:`w`", "#text": "is said to  iff\n yields some halted configuration."}, {"math": ["M", "(s, \\#w\\underline{\\#})"], "strong": "hang on input :math:`w`", "emphasis": ["either", "or"], "#text": "is said to  if\n yields some hanging configuration.\nThat means  move left from left end  go into an infinite loop."}, {"math": ["f", "\\Sigma^*_0", "\\Sigma^*_1", "M", "f", "w \\in \\Sigma^*_0", "f(w) = u"], "strong": "compute", "#text": "Turing machines compute functions from strings to strings.\nFormally: Let  be a function from  to\n.\nTuring machine  is said to   when,\nfor any , if  then"}, {"math": "f", "title_reference": "Turing-computable function", "#text": "Such a function  is said to be a ."}, {"math": "f(w_1, ..., w_k) = u", "#text": "Here is how we express multiple parameters:\nFor ,"}, {"title_reference": "unary notation", "math": ["f: \\mathbb{N} \\rightarrow \\mathbb{N}", "M", "M", "f': \\{I\\}^* \\rightarrow \\{I\\}^*", "f'(I^n) = I^{f(n)}", "n \\in \\mathbb{N}"], "#text": "One way to express functions on natural numbers is to represent a\nnumber using .\n(Remember, we are not concerned about is efficient, we are concerned\nabout what is possible.)\nIn this case, we represent the value 0 as an empty string.\nWe say that \nis computed by  if \ncomputes  where\n for each ."}], "math_block": [{"@xml:space": "preserve", "#text": "(q, aaba\\#\\underline{\\#}a)"}, {"@xml:space": "preserve", "#text": "\\begin{eqnarray*}\n(q_0, \\underline{a}aaa) &\\vdash_M&(q_1, \\underline{\\#}aaa)\\\\\n&\\vdash_M&(q_0, \\#\\underline{a}aa)\\\\\n&\\vdash_M&(q_1, \\#\\underline{\\#}aa)\\\\\n&\\vdash_M&(q_0, \\#\\#\\underline{a}a)\\\\\n&\\vdash_M&(q_1, \\#\\#\\underline{\\#}a)\\\\\n&\\vdash_M&(q_0, \\#\\#\\#\\underline{a})\\\\\n&\\vdash_M&(q_1, \\#\\#\\#\\underline{\\#})\\\\\n&\\vdash_M&(q_0, \\#\\#\\#\\#\\underline{\\#})\\\\\n&\\vdash_M&(h, \\#\\#\\#\\#\\underline{\\#})\\\\\n\\end{eqnarray*}"}, {"@xml:space": "preserve", "#text": "(s, \\#w\\underline{\\#}) \\vdash^*_M (h, \\#u\\underline{\\#})."}, {"@xml:space": "preserve", "#text": "(s, \\#w_1\\#w_2\\#...\\#w_k\\underline{\\#}) \\vdash^*_M (h, \\#u\\underline{\\#})."}], "topic": {"title": "Example", "paragraph": [{"math": ["f(n) = n + 1", "n \\in \\mathbb{N}"], "#text": "Compute  for each ."}, "An example computation:", {"math": ["(q_0, \\#I^n\\underline{\\#}) \\vdash^*_M (h, \\#I^{n+1}\\underline{\\#})", "n = 0"], "#text": "In general,\n.\nWhat about ?\nThe input is no marks in unary, and it works OK."}], "math_block": [{"@xml:space": "preserve", "#text": "\\begin{array}{lll}\n\\hline\nq&\\sigma&\\delta(q, \\sigma)\\\\\n\\hline\nq_0&I&(h, R)\\\\\nq_0&\\#&(q_0, I)\\\\\n\\end{array}"}, {"@xml:space": "preserve", "#text": "(q_0, \\#II\\underline{\\#}) \\vdash_M (q_0, \\#II\\underline{I}) \\vdash_M\n(h, \\#III\\underline{\\#})."}]}}, {"@ids": "turing-decideable-vs-turing-acceptable-languages", "@names": "turing-decideable\\ vs.\\ turing-acceptable\\ languages", "title": "Turing-Decideable vs. Turing-Acceptable Languages", "paragraph": [{"math": ["L \\subset \\Sigma_0^*", "\\chi_L: \\Sigma^*_0 \\rightarrow \\{\\fbox{Y}, \\fbox{N}\\}", "w \\in \\Sigma^*_0"], "title_reference": "Turing-decidable", "#text": "A language  is \niff function \nis Turing-computable, where for each ,"}, {"math": ["\\Sigma_0 = \\{a\\}", "L = \\{w \\in \\Sigma^*_0: |w|\\ \\mbox{is even}\\}"], "#text": "Example: Let , and let\n."}, {"math": ["M", "\\fbox{Y}", "\\fbox{N}"], "#text": "erases the marks from right to left, with current parity\nencode by state.\nOnce blank at left is reached, mark  or\n as appropriate."}, {"math": "N \\rightarrow N", "#text": "There are many views of computation.\nOne is functions mapping input to output\n(, or\nstrings to strings, for examples).\nAnother is deciding if a string is in a language."}, {"math": ["M", "w", "M", "w"], "title_reference": "accepts", "#text": "a string  if  halts on\ninput ."}, {"math": ["\\Sigma_0 = \\{a, b\\}", "L = \\{w \\in \\Sigma^*_0: w\\ \\mbox{contains at least one}\\ a\\}"], "#text": "Example: ,\n."}, {"math": ["a", "\\fbox{Y}", "\\#", "\\fbox{N}"], "#text": "Is this language Turing decidable?\nOf course. Instead of just running left, invoke another state that\nmeans \"seen an \", and print  if we reach\n in that state,  otherwise."}, {"math": ["\\fbox{Y}", "\\fbox{N}"], "#text": "Every Turing-decidable language is Turing-acceptable,\nbecause if the machine would have printed ,\nthen the machine can halt instead,\nor if the machine would have printed ,\nthen it can hang left."}, "Is every Turing-acceptible language Turing decidable?\nThis is the Halting Problem.", {"math": ["\\fbox{Y}", "\\fbox{N}"], "emphasis": "always", "#text": "Of course, if the Turing-acceptible language would halt,\nwe write .\nBut if the Turing-acceptible language would hang,\ncan we  replace it with logic to write \ninstead?\nExample: Collatz function."}], "math_block": [{"@xml:space": "preserve", "#text": "\\chi_L(w) = \\left\\{\n\\begin{array}{ll}\n\\fbox{Y} & \\mbox{if $w \\in L$}\\\\\n\\fbox{N}  & \\mbox{otherwise}\n\\end{array}\n\\right."}, {"@xml:space": "preserve", "#text": "\\begin{array}{lll}\n\\hline\nq&\\sigma&\\delta(q, \\sigma)\\\\\n\\hline\nq_0&a&(h, a)\\\\\nq_0&b&(q_0, L)\\\\\nq_0&\\#&(q_0, L)\\\\\n\\hline\n\\end{array}"}], "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": {"math": ["M", "w", "w \\in L"], "#text": "accepts a language iff :math:M` halts on  iff\n."}}, {"paragraph": {"math": "Turing-acceptable", "#text": "A language is  if there is some Turing\nmachine that accepts it."}}]}}, {"@ids": "making-more-complicated-machines", "@names": "making\\ more\\ complicated\\ machines", "title": "Making More Complicated Machines", "paragraph": [{"strong": "Lemma", "#text": ": If"}, {"math": "w", "#text": "for string  and"}, "then", {"math": ["(q_2, w_2\\underline{a_2}u_2) \\vdash^*_M (q_3, w_3\\underline{a_3}u_3)", "w_2", "w_2"], "#text": "Insight: Since\n,\nthis computation must take place without moving the head left of \nThe machine cannot \"sense\" the left end of the tape.\n(And if it had moved left, it would have hung.)\nThus, the head won't move left of  even if it is not at the\nleft end of the tape."}, "This means that Turing machine computations can be combined into\nlarger machines:", "Here are some basic machines and notation"], "math_block": [{"@xml:space": "preserve", "#text": "(q_1, w_1\\underline{a_1}u_1) \\vdash_M^* (q_2, ww_2\\underline{a_2}u_2)"}, {"@xml:space": "preserve", "#text": "(q_2, w_2\\underline{a_2}u_2) \\vdash^*_M (q_3, w_3\\underline{a_3}u_3),"}, {"@xml:space": "preserve", "#text": "(q_1, w_1\\underline{a_1}u_1) \\vdash^*_M (q_3, ww_3\\underline{a_3}u_3)."}], "bullet_list": [{"@bullet": "*", "list_item": [{"paragraph": {"math": ["M_2", "M_1"], "#text": "prepares string as input to ."}}, {"paragraph": {"math": ["M_2", "M_1"], "#text": "passes control to  with I/O head at end of input."}}, {"paragraph": {"math": ["M_2", "M_1"], "#text": "retrieves control when  has completed."}}]}, {"@bullet": "*", "list_item": [{"paragraph": {"math": ["|\\Sigma|", "\\sigma", "\\sigma"], "#text": "symbol-writing machines (one for each symbol):\nAny give letter  has a symbol-writing machine named\n."}}, {"paragraph": {"math": ["R", "L"], "#text": "Head-moving machines, named  and , move the head\nappropriately."}}, {"paragraph": {"math": ">", "#text": "Start state indicated with ."}}, {"paragraph": {"math": ["\\#", "\\overline{\\#}"], "#text": "Transitions on anything other than (for example)  are\nlabeled"}}, {"paragraph": {"math": "R^2", "#text": "Multiple copies of a machine get a superscript:  means\nmove right twice."}}]}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "Turing1CON", "@long_name": "Turing1CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "Turing2CON", "@long_name": "Turing2CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "Turing3CON", "@long_name": "Turing3CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "TuringCopyCON", "@long_name": "TuringCopyCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "TuringShiftCON", "@long_name": "TuringShiftCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}], "line_block": [{"line": null}, {"line": null}, {"line": null}, {"line": null}]}, {"@ids": "turing-machine-extensions", "@names": "turing\\ machine\\ extensions", "title": "Turing Machine Extensions", "paragraph": {"strong": "might", "#text": "When we give extentions or new functionality to a computing system,\nsometimes they change something fundamental about the capabilies of\nthe system.\nFor example, when we add non-determinism to an algorithm, we \nchange the cost of the underlying problem from exponential to\npolynomial time.\nBut, other changes do nothing fundamental.\nIn terms of Turing machines, our concern is what the machine can do,\nrather than how long it takes to do it.\nDoes non-determinism help us to solve the Halting problem?\nNo.\nLikewise, the following extensions do not increase the power of Turing\nMachines."}, "bullet_list": {"@bullet": "*", "list_item": [{"paragraph": ["Provide a two-way infinite tape", "This does not give Turing machines new capability.\nTo make this clear, we can simulate the behavior of a two-way\ninfinite tape using a standard one-way infinite tape.\nJust bend infinite tape in the middle, and store both directions of\nthe tape into a single cell.\nThis requires a greatly expanded alphabet, because we now need to be\nable to represent any combination of two characters.\nThis will need more states, and probably more time.\nBut it does not allow anything new in terms of capability."], "raw": {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "TuringExt1CON", "@long_name": "TuringExt1CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}}, {"paragraph": ["Multiple tapes (each with its own head)", "Again, we can simulate this with encoding multiple symbols into a\nsingle table cell.\nFor example, to simulate two tapes (each with a head), we encode in\neach cell the corresponding two symbols, and a two binary markers to\nindicate if the tape head is currently in the corresponding cell of\nthe two tapes."], "raw": {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "TuringExt2CON", "@long_name": "TuringExt2CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}}, {"paragraph": ["Multiple heads on one tape", "This is easier than encoding multiple tapes.\nWe merely encode the heads onto the tape, and simulate moving them\naround."]}, {"paragraph": [{"literal": "tape", "#text": "A two-dimensional"}, "All that we need to do is find a mapping from 2D to 1D, which is\nfairly easy.\nOne approach is to work in diagonals, in the order (0, 0), (0, 1),\n(1, 0), (0, 2), (1, 1), (2, 0), and so on."], "raw": {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "dgm", "@exer_name": "TuringExt3CON", "@long_name": "TuringExt3CON", "@points": "0", "@required": "True", "@threshold": "1.0"}}}, {"paragraph": ["Non-determinism", "We can simulate nondeterministic behavior in sequence, doing all\nlength 1 computations, then length 2, etc., until we reach a halt\nstate for one of the non-deteriministic choices.\nSo we see that while non-determinism can save a lot of time, it does\nnot change what can (eventually) be done."]}]}, "raw": [{"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/SeniorAlgAnal/Turing1CON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/SeniorAlgAnal/Turing2CON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/SeniorAlgAnal/Turing3CON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/SeniorAlgAnal/TuringCopyCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/SeniorAlgAnal/TuringShiftCON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/SeniorAlgAnal/TuringExt1CON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/SeniorAlgAnal/TuringExt2CON.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/SeniorAlgAnal/TuringExt3CON.js"}]}]}}