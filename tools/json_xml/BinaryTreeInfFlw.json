{"document": {"@dupnames": "information\\ flow\\ in\\ recursive\\ functions", "@ids": "information-flow-in-recursive-functions", "@source": "<string>", "@title": "Information Flow in Recursive Functions", "title": "Information Flow in Recursive Functions", "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2016 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Binary/WriteTrav.css"}], "section": [{"@dupnames": "information\\ flow\\ in\\ recursive\\ functions", "@ids": "id1", "title": "Information Flow in Recursive Functions", "paragraph": ["Handling information flow in a recursive function can be a challenge.\nIn any given function, we might need to be concerned with either or\nboth of:", "Any given problems might need to do either or both.\nHere are some examples and exercises."], "block_quote": {"enumerated_list": {"@enumtype": "arabic", "@prefix": "", "@suffix": ".", "list_item": [{"paragraph": "Passing down the correct information needed by the function to do\nits work,"}, {"paragraph": "Returning (passing up) information to the recursive function's\ncaller."}]}}, "section": [{"@ids": "local", "@names": "local", "title": "Local", "paragraph": "Local traversal involves going to each node in the tree to do some\noperation.\nSuch functions need no information from the parent (other than a\npointer to the current node), and pass no information back.\nExamples include preorder traversal and incrementing the value of\nevery node by one."}, {"@ids": "passing-down-information", "@names": "passing\\ down\\ information", "title": "Passing Down Information", "paragraph": ["Slightly more complicated is the situation where every node needs the\nsame piece of information to be passed to it.\nAn example would be incrementing the value for all nodes by some\namount.\nIn this case, the value parameter is simply passed on\nunchanged in all recursive calls.", "Many functions need information that changes from node to node.\nA simple example is a function to set the value for each node of the\ntree to be its depth.\nIn this case, the depth is passed as a parameter to the function, and\neach recursive call must adjust that value (by adding one)."]}]}, {"@ids": "binary-tree-set-depth-exercise", "@names": "binary\\ tree\\ set\\ depth\\ exercise", "title": "Binary Tree Set Depth Exercise", "raw": {"@format": "xml", "@xml:space": "preserve", "extertool": {"@resource_name": "Binary Tree Set Depth Exercise", "@resource_type": "external_assignment", "@learning_tool": "code-workout", "@points": "1"}}}, {"@ids": "collect-and-return", "@names": "collect-and-return", "title": "Collect-and-return", "paragraph": ["Collect-and-return requires that we communicate information back up\nthe tree to the caller.\nSimple examples are to count the number of nodes in a tree,\nor to sum the values of all the nodes.", "When you write a recursive function that returns a value,\nsuch as counting the number of nodes in the subtree,\nyou have to make sure that your function actually returns a value.\nA common mistake is to make a recursive call and not capture the\nreturned value.\nAnother common mistake is to not return a value."], "topic": {"title": "Example", "paragraph": [{"literal": ["count", "count"], "#text": "Consider the problem of counting (and returning) the number of\nnodes in a binary tree.\nThe key insight is that the total count for any (non-empty) subtree is\none for the root plus the counts for the left and right subtrees.\nWhere do left and right subtree counts come from?\nCalls to function  on the subtrees will compute this for\nus.\nThus, we can implement  as follows."}, "The following solution is correct but inefficient as it does\nredundant checks on the left and the right child of each visited\nnode."], "raw": [{"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}, {"@format": "xml", "@xml:space": "preserve", "codeinclude": "null"}]}, "raw": {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "BinaryTreeMistakesCON", "@long_name": "BinaryTreeMistakesCON", "@points": "0", "@required": "True", "@threshold": "1.0"}}}, {"@ids": "binary-tree-check-sum-exercise", "@names": "binary\\ tree\\ check\\ sum\\ exercise", "title": "Binary Tree Check Sum Exercise", "raw": {"@format": "xml", "@xml:space": "preserve", "extertool": {"@resource_name": "Binary Tree Check Sum Exercise", "@resource_type": "external_assignment", "@learning_tool": "code-workout", "@points": "1"}}}, {"@ids": "binary-tree-leaf-nodes-count-exercise", "@names": "binary\\ tree\\ leaf\\ nodes\\ count\\ exercise", "title": "Binary Tree Leaf Nodes Count Exercise", "raw": {"@format": "xml", "@xml:space": "preserve", "extertool": {"@resource_name": "Binary Tree Leaf Nodes Count Exercise", "@resource_type": "external_assignment", "@learning_tool": "code-workout", "@points": "1"}}}, {"@ids": "binary-tree-sum-nodes-exercise", "@names": "binary\\ tree\\ sum\\ nodes\\ exercise", "title": "Binary Tree Sum Nodes Exercise", "raw": {"@format": "xml", "@xml:space": "preserve", "extertool": {"@resource_name": "Binary Tree Sum Nodes Exercise", "@resource_type": "external_assignment", "@learning_tool": "code-workout", "@points": "1"}}}, {"@ids": "combining-information-flows", "@names": "combining\\ information\\ flows", "title": "Combining Information Flows", "paragraph": "Many functions require both that information be passed in, and that\ninformation be passed back.\nLet's start with a relatively simple case.\nIf we want to check if some node in the tree has a\nparticular value, that value has to be passed down, and the count has\nto be passed back up.\nThe downward flow is simple, as the value being checked for never\nchanges.\nThe information passed up has the simple collect-and-return style:\nReturn True if and only if one of the children returns True."}, {"@ids": "binary-tree-check-value-exercise", "@names": "binary\\ tree\\ check\\ value\\ exercise", "title": "Binary Tree Check Value Exercise", "raw": {"@format": "xml", "@xml:space": "preserve", "extertool": {"@resource_name": "Binary Tree Check Value Exercise", "@resource_type": "external_assignment", "@learning_tool": "code-workout", "@points": "1"}}}, {"@ids": "combination-problems", "@names": "combination\\ problems", "title": "Combination Problems", "paragraph": "Slightly more complicated problems combine what we have seen so far.\nInformation passing down the tree changes from node to node.\nData passed back up the tree uses the collect-and-return paradigm."}, {"@ids": "binary-tree-height-exercise", "@names": "binary\\ tree\\ height\\ exercise", "title": "Binary Tree Height Exercise", "raw": {"@format": "xml", "@xml:space": "preserve", "extertool": {"@resource_name": "Binary Tree Height Exercise", "@resource_type": "external_assignment", "@learning_tool": "code-workout", "@points": "1"}}}, {"@ids": "binary-tree-get-difference-exercise", "@names": "binary\\ tree\\ get\\ difference\\ exercise", "title": "Binary Tree Get Difference Exercise", "raw": {"@format": "xml", "@xml:space": "preserve", "extertool": {"@resource_name": "Binary Tree Get Difference Exercise", "@resource_type": "external_assignment", "@learning_tool": "code-workout", "@points": "1"}}}, {"@ids": "binary-tree-has-path-sum-exercise", "@names": "binary\\ tree\\ has\\ path\\ sum\\ exercise", "title": "Binary Tree Has Path Sum Exercise", "raw": [{"@format": "xml", "@xml:space": "preserve", "extertool": {"@resource_name": "Binary Tree Has Path Sum Exercise", "@resource_type": "external_assignment", "@learning_tool": "code-workout", "@points": "1"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Binary/BinaryTreeMistakesCON.js"}]}]}}