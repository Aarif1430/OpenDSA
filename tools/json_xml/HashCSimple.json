{"document": {"@dupnames": "collision\\ resolution", "@ids": "collision-resolution", "@source": "<string>", "@title": "Collision Resolution", "title": "Collision Resolution", "subtitle": {"@dupnames": "collision\\ resolution", "@ids": "id1", "#text": "Collision Resolution"}, "comment": [{"@xml:space": "preserve", "#text": "This file is part of the OpenDSA eTextbook project. See"}, {"@xml:space": "preserve", "#text": "http://algoviz.org/OpenDSA for more details."}, {"@xml:space": "preserve", "#text": "Copyright (c) 2012-2013 by the OpenDSA Project Contributors, and"}, {"@xml:space": "preserve", "#text": "distributed under an MIT open source license."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "avmetadata": "null"}, {"@format": "xml", "@xml:space": "preserve", "index": "null"}, {"@format": "xml", "@xml:space": "preserve", "odsalink": "AV/Hashing/linProbeCON.css"}, {"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "linProbeCON1", "@long_name": "linProbeCON1", "@points": "0", "@required": "True", "@threshold": "1.0"}}], "paragraph": [{"title_reference": ["closed hashing <closed hash system>", "collision resolution policy"], "#text": "We now turn to the most commonly used form of hashing:\n with no bucketing, and a\n that can potentially use any slot\nin the hash table."}, {"title_reference": ["collision resolution", "probe sequence", "probe function"], "strong": "p", "#text": "During insertion, the goal of  is to find\na free slot in the hash table when the home position for the record is\nalready occupied.\nWe can view any collision resolution method as generating a sequence\nof hash table slots that can potentially hold the record.\nThe first slot in the sequence will be the home position for the key.\nIf the home position is occupied, then the collision resolution policy\ngoes to the next slot in the sequence.\nIf this is occupied as well, then another slot must be found, and\nso on.\nThis sequence of slots is known as the\n, and it is generated by some\n that we will call .\nInsertion works as follows:"}, {"literal": ["hashInsert", "for", "hashInsert"], "title_reference": ["textbf{p}(k, i)", "k", "i", "K", "textbf{p}(K, 1)", "textbf{p}(K, 2)", "i", "i"], "strong": ["p", "p"], "#text": "Method  first checks to see if the home slot for the\nkey is empty.\nIf the home slot is occupied, then we use the probe function\n to locate a free slot in the table.\nFunction  has two parameters, the key  and a\ncount  of where in the probe sequence we wish to be.\nThat is, to get the first position in the probe sequence after the\nhome slot for key , we call .\nFor the next slot in the probe sequence, call .\nNote that the probe function returns an offset from the original home\nposition, rather than a slot in the hash table.\nThus, the  loop in  is computing positions\nin the table at each iteration by adding the value returned from the\nprobe function to the home position.\nThe  th call to  returns the  th offset to be used."}, "Searching in a hash table follows the same probe sequence that was\nfollowed when inserting records.\nIn this way, a record not in its home position can be recovered.\nAn implementation for the search procedure is as\nfollows.:", "Both the insert and the search routines assume that at least\none slot on the probe sequence of every key will be empty.\nOtherwise they will continue in an infinite loop on unsuccessful\nsearches.\nThus, the hash system should keep a count of the number of records stored,\nand refuse to insert into a table that has only one free slot.", {"title_reference": ["linear probing", "textbf{p}(K, i) = i", "i", "i", "i", "i"], "#text": "The simplest approach to collsion resolution is simply to move down\nthe table from the home slot until a free slot is found.\nThis is known as .\nThe probe function for simple linear probing is\n.\nThat is, the  th offset on the probe sequence is just\n,\nmeaning that the  th step is simply to move down  \nslots in the table.\nOnce the bottom of the table is reached, the probe sequence\nwraps around to the beginning of the table (since the last step is to\nmod the result to the table size).\nLinear probing has the virtue that all slots in the table will be\ncandidates for inserting a new record before the probe sequence\nreturns to the home position."}, "Can you see any reason why this might not be the best approach\nto collision resolution?"], "literal_block": [{"@xml:space": "preserve", "#text": "// Insert e into hash table HT\nvoid hashInsert(const Key& k, const Elem& e) {\n  int home;                     // Home position for e\n  int pos = home = h(k);        // Init probe sequence\n  for (int i=1; EMPTYKEY != (HT[pos]).key(); i++) {\n    pos = (home + p(k, i)) % M; // probe\n    if (k == HT[pos].key()) {\n      println(\"Duplicates not allowed\");\n      return;\n    }\n  }\n  HT[pos] = e;\n}"}, {"@xml:space": "preserve", "#text": "// Search for the record with Key K\nbool hashSearch(const Key& K, Elem& e) const {\n  int home;              // Home position for K\n  int pos = home = h(K); // Initial position is the home slot\n  for (int i = 1;\n       (K != (HT[pos]).key()) && (EMPTYKEY != (HT[pos]).key());\n       i++)\n    pos = (home + p(K, i)) % M; // Next on probe sequence\n  if (K == (HT[pos]).key()) {   // Found it\n    e = HT[pos];\n    return true;\n  }\n  else return false;            // K not in hash table\n}"}], "section": {"@ids": "the-problem-with-linear-probing", "@names": "the\\ problem\\ with\\ linear\\ probing", "title": "The Problem with Linear Probing", "paragraph": [{"strong": "p", "#text": "While linear probing is probably\nthe first idea that comes to mind when considering collision\nresolution policies, it is not the only one possible.\nProbe function  allows us many options for how to do collision\nresolution.\nIn fact, linear probing is one of the worst collision resolution\nmethods.\nThe main problem is illustrated by the next slideshow."}, {"title_reference": "primary clustering", "#text": "Again, the ideal behavior for a collision resolution mechanism is that\neach empty slot in the table will have equal probability of\nreceiving the next record inserted (assuming that every slot in the\ntable has equal probability of being hashed to initially).\nThis tendency of linear probing to cluster items together is known as\n.\nSmall clusters tend to merge into big clusters, making the problem\nworse.\nThe objection to primary clustering is that it leads to\nlong probe sequences."}], "raw": [{"@format": "xml", "@xml:space": "preserve", "inlineav": {"@type": "ss", "@exer_name": "linProbeCON2", "@long_name": "linProbeCON2", "@points": "0", "@required": "True", "@threshold": "1.0"}}, {"@format": "xml", "@xml:space": "preserve", "avembed": {"@type": "ka", "@exer_name": "HashLinearPPRO", "@long_name": "HashLinearPPRO", "@points": "1.0", "@required": "True", "@threshold": "5"}}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/linProbeCON1.js"}, {"@format": "xml", "@xml:space": "preserve", "odsascript": "AV/Hashing/linProbeCON2.js"}]}}}