<!DOCTYPE html>
<html>
<head>
	<title>OpenDSA Textbook: Huffman Coding Tree</title>
	<meta charset="utf-8" />
	<link href="../JSAV/css/JSAV.css" rel="stylesheet" type="text/css" />
	<script type="text/javascript"
		src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>
	<script  src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js">
	</script>
	<script  src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js">
	</script>
	<script src="../JSAV/lib/jquery.transform.light.js"></script>
	<script src="../JSAV/lib/raphael.js"></script>
	<script src="../JSAV/build/JSAV-min.js"></script>
	<script src="../JSAV/build/JSAV.js"></script>
</head>
	
<body>
	<div id="av">
		<div class="jsavcontrols"></div>
		<p class="jsavoutput jsavline"></p>
	</div>
	<script>

		// sorting the elements of an array from a assigned postion with Bubble Sort
		var sortArray = function (anArray, startPos, endPos) {
			for (var i = startPos; i < endPos; i++) {
				for (var j = i + 1; j <= endPos; j++) {
					if (parseInt(anArray[j].value()) < parseInt(anArray[i].value())) {

					//	var tmp = parseInt(anArray[j].value());
					//	anArray[j].value(parseInt(anArray[i].value()));
					//	anArray[i].value(tmp); 
						
					// swap the two nodes
						tmpNode.value(anArray[j].value());
						tmpNode.parent(anArray[j].parent());
						tmpNode.left(anArray[j].left());
						tmpNode.right(anArray[j].right());

						anArray[j].value(anArray[i].value());
						anArray[j].parent(anArray[i].parent());
						anArray[j].left(anArray[i].left());
						anArray[j].right(anArray[i].right());

						anArray[i].value(tmpNode.value());
						anArray[i].parent(tmpNode.parent());
						anArray[i].left(tmpNode.left());
						anArray[i].right(tmpNode.right()); 
					}
				}
			}
			indexLeft = startPos;		// index for left child
			indexRight = startPos + 1;	// index for right child
			s1 = parseInt(anArray[indexLeft].value());		// s1: the left child
			s2 = parseInt(anArray[indexRight].value());		// s2: the right child
		}
		
		// Constructing the huffmanCodingTree
		var HCTree = function (anArray, nNode){
			var total = 2 * nNode - 1;		// the total node of HuffmanCoding Tree
			var startPos = 0;
			var endPos = nNode - 1;
			for (var i = nNode; i < total; i++){
				sortArray(anArray, startPos, endPos);
				anArray[indexLeft].parent(anArray[i]);
				anArray[indexRight].parent(anArray[i]);
				anArray[i].left(anArray[indexLeft]);
				anArray[i].right(anArray[indexRight]);
				anArray[i].value(s1 + s2);
				startPos += 2;
				endPos++;
			}
		}

    // traverse to re-set background color of the entire tree
    var traverse_color = function(node, col) {
		var val = node.value();

		// the node is an empty node	
		if (!val || val === "jsavnull") {	
			return;
		} 
		else {
			// if the node is an internal node, then display an circle
			if (node.left()) {
				node.css("background-color", col);
				node.edgeToParent();
				traverse_color(node.left(),col);
			}
			if (node.right()) {
				node.css("background-color", col);
				traverse_color(node.right(),col);
			}
			// if the node is a leaf node, then display an rectangle
			else
			node.css({"height": "90px", "width": "45px", "border-radius":1});
		}
    }
    
		var jsav = new JSAV("av");
		var bt = jsav.ds.bintree();
		var caption_label = jsav.label("Huffman Coding Tree Construction", {before: bt});
		var caption_text = "";
//		jsav.step();	

		var huffTree = new Array(15);

		huffTree[0] = bt.newNode(2);
		huffTree[1] = bt.newNode(7);
		huffTree[2] = bt.newNode(24);
		huffTree[3] = bt.newNode(32);
		huffTree[4] = bt.newNode(37);
		huffTree[5] = bt.newNode(42);
		huffTree[6] = bt.newNode(42);
		huffTree[7] = bt.newNode(120);
		huffTree[8] = bt.newNode(9);
		huffTree[9] = bt.newNode(33);
		huffTree[10] = bt.newNode(65);
		huffTree[11] = bt.newNode(79);
		huffTree[12] = bt.newNode(107);
		huffTree[13] = bt.newNode(186);
		huffTree[14] = bt.newNode(306);
		
		//for (var i = 0; i <= 14; i++) {
		//	huffTree[i].left(0);
		//}

	bt.root(306);
	bt.root().left(120 + "<br />" + "E");
	bt.root().right(186);

	bt.root().right().left(79);
	bt.root().right().right(107);

	bt.root().right().left().right(42 + "<br />" + "D");
	bt.root().right().left().left(37 + "<br />" + "U");

	bt.root().right().right().left(42 + "<br />" + "L");
	bt.root().right().right().right(65);

	bt.root().right().right().right().left(32 + "<br />" + "C");
	bt.root().right().right().right().right(33);

	bt.root().right().right().right().right().left(9);
	bt.root().right().right().right().right().right(24 + "<br />" + "M");

	bt.root().right().right().right().right().left().left(2 + "<br />" + "Z");
	bt.root().right().right().right().right().left().right(7 + "<br />" + "K");

		huffTree[14].left(huffTree[12]);
		huffTree[14].right(huffTree[13]);

		huffTree[13].left(huffTree[11]);
		huffTree[13].right(huffTree[12]);

		huffTree[12].left(huffTree[6]);
		huffTree[12].right(huffTree[10]);

		huffTree[11].left(huffTree[4]);
		huffTree[11].right(huffTree[5]);

		huffTree[10].left(huffTree[3]);
		huffTree[10].right(huffTree[9]);

		huffTree[9].left(huffTree[8]);
		huffTree[9].right(huffTree[2]);

		huffTree[8].left(huffTree[0]);
		huffTree[8].right(huffTree[1]);


		/* tesing the sorting fuction
		var st = 0;
		var ed = 4; 
		sortArray(huffTree, st, ed);
		for (var i = 0; i < 7; i++) {
			document.write(huffTree[i].value() + " ");
		}

		document.write(huffTree[0].parent().value()); */

		traverse_color(bt.root(), "white");
		bt.layout();
	
    jsav.recorded(); // done recording changes, will rewind
    
    $(".jsavtreenode").live("hover", function() {
	//console.log($(this).text(), $(this).offset().left, $(this).offset().top);
    });
    $("path").live("hover", function() {
	//console.log($(this).attr("d"));
    });
// end hiding contents from old browsers  -->
    </script>
</body>
