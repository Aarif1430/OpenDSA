<!DOCTYPE html>
<html>
<head>
	<title>Huffman Coding Tree</title>
	<meta charset="utf-8" />
	<link href="opendsaAV.css" title="CSS" rel="stylesheet" type="text/css" />
	<link href="../JSAV/css/JSAV.css" rel="stylesheet" type="text/css" />
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js"></script>
	<script src="../JSAV/lib/jquery.transform.light.js"></script>
	<script src="../JSAV/lib/raphael.js"></script>
	<script src="../JSAV/build/JSAV-min.js"></script>
	<script src="../JSAV/build/JSAV.js"></script>

	<style>
	#container {
	  width: 800px;
	  height: 850px;
	  background-color: #efe;
	  border:1px solid #A5B6C8;
	  padding: 10px;
	  overflow-x: hidden;
	  overflow-y: visible;
	}

	#av{
		overflow: visible;	
	}
	
	div h1 {
	  background-color: #efe;
	  margin: 5px;
	}
	.jsavcontainer {
	  background-color: #efe;
	  border: none;
	  padding 0px;
	}
	.jsavcounter {
	  float: left;
	  width: 100px;
	}
	.jsavarray {
	  padding-left:0;
	  position: absolute;
	}
	p.jsavoutput.jsavline {
	  height: 30px;
	  margin: 0;
	}
	#about {
	  float: right;
	}
	a.jsavsettings {
	display: block;
	margin-top: 10px;
	margin-left: 10px;
	}
	form {
	  clear: both;
	}
</style>
</head>
	
<body>
	<div id="container">
		<input type="button" id="about" name="about" value="about" style="margin-top:10px; height:24px"/>
		<a class="jsavsettings" href="#">Settings</a>
		<h1 style="">Huffman Coding Tree Visualization</h1>
		<div id="av">
			<span class="jsavcounter"></span>
			<div class="jsavcontrols"></div>
			<p class="jsavoutput jsavline" readonly="readonly"></p>
		</div> <!--av-->
	</div> <!--container-->

	<script>
	
	// extend BinaryTree by adding a function to swap two trees in DOM
    JSAV._types.ds.BinaryTree.prototype.swapWithTree = JSAV.anim(function(otherTree) { // wrap in JSAV.anim to make animatable
      // calculate position differences before swap
      var posdiffX = JSAV.position(this.element).left - JSAV.position(otherTree.element).left,
          posdiffY = JSAV.position(this.element).top - JSAV.position(otherTree.element).top;

      // swap the elements in the DOM tree
      var el1 = this.element[0], // the DOM element for this tree
          el2 = otherTree.element[0], // the DOM element for the other tree
          aparent = el1.parentNode, // their parent node
          asibling = el1.nextSibling===el2 ? el1 : el1.nextSibling; // get the sibling node of el1
      el2.parentNode.insertBefore(el1, el2); // add el1 before el2 in DOM
      aparent.insertBefore(el2, asibling); // add el2 before el1's sibling
      
      // .. then set the position of the trees so that the order appears unchanged..
      this.element.css({"transform": "translate(" + (posdiffX) + "px, " + (posdiffY) + "px)"});
      otherTree.element.css({"transform": "translate(" + (-posdiffX) + "px, " + (-posdiffY) + "px)"});
      // ..animate the translation to 0, so they'll be in their final positions..
      this.element.animate({"transform": "translate(0, 0)"}, JSAV.speed, 'linear');
      otherTree.element.animate({"transform": "translate(0, 0)"}, JSAV.speed, 'linear');

      return [otherTree]; // return otherTree to get animation working
    });
	
	// sorting the elements of an array with Insertation Sort
	var sortArray = function (anArray, hfArray) {
		for (var i = 1; i < anArray.length; i++) {
			var key = anArray[i];
			var tmpTree = hfArray[i];
			var j = i - 1;
			while(j >= 0 && key < anArray[j]) {
				anArray[j + 1] = anArray[j];
				hfArray[j + 1] = hfArray[j];
				j--;
			}
			anArray[j + 1] = key;
			hfArray[j + 1] = tmpTree;
			//hfArray[j + 1].swapWithTree(hfArray[j]);
		}
	}

	// Shuffle the array by moving left
	var shuffle = function (anArray, hfArray) {
		for (var i = 0; i < anArray.length - 1; i++) {
			anArray[i] = anArray[i + 2];
			hfArray[i] = hfArray[i + 2];
		}
		anArray.length -= 2;
		hfArray.length -= 2;
	}

	// Constructing the huffmanCodingTree
	var huffTree = function (anArray, hfArray) {
		while (anArray.length > 1) {

			sortArray(anArray, hfArray);
			var key = anArray[0] + anArray[1];
			
			// Extend the numArray
			var newIndex = anArray.length;
			anArray.length += 1;
			anArray[newIndex] = key;
			
			// construct a new tree
			hfArray.length += 1;
			hfArray[newIndex] = jsav.ds.bintree({visible: false, center: false});
			hfArray[newIndex].root(key);
			hfArray[newIndex].root().left(hfArray[0].root());
			hfArray[newIndex].root().right(hfArray[1].root());

			shuffle(anArray, hfArray);
		}	
	}

	// Constructing the huffmanCodingTree with animation
	var huffTree_animation = function (anArray, hfArray) {
		while (anArray.length > 1) {
			sortArray(anArray, hfArray);
			jsav.umsg("Sorting the data by their frequency, and the results are as follows: ");
			// Display all the trees
			for(var i = 0; i < hfArray.length; i++) {
				var cor = 40 + 75 * i;
				hfArray[i].css({"left":cor, "top": "5px"});
			}
			jsav.step();	
			
			jsav.umsg("Choose the two samllest number: " + anArray[0] + " and " + anArray[1]);
			// Hightlight two elements that will be chosen
			hfArray[0].root().highlight();
			hfArray[1].root().highlight();
			jsav.step();
			var key = anArray[0] + anArray[1];
			
			// Extend the numArray
			var newIndex = anArray.length;
			anArray.length += 1;
			anArray[newIndex] = key;
			
			// construct a new tree
			hfArray.length += 1;
			hfArray[newIndex] = jsav.ds.bintree({visible: false, center: false});
			hfArray[newIndex].root(key);
			hfArray[newIndex].root().left(hfArray[0].root());
			hfArray[newIndex].root().right(hfArray[1].root());

			jsav.umsg("Merge them together, and the result is " + key);
		
			// Hide all the trees display before.
			for (var i = 0; i < hfArray.length; i++) {
				hfArray[i].hide();
			}
			
			// Dispay the procedure for merging two trees.
			hfArray[newIndex].css({"left":"300px", "top": "5px"});
			hfArray[newIndex].show();
			jsav.step();
			
			jsav.umsg("Use " + key + " to replace " + anArray[0] + " and " + anArray[1] + ", and update the data as follows: ");
			shuffle(anArray, hfArray);
			// Display all the trees
			for(var i = 0; i < hfArray.length; i++) {
				var cor = 40 + 75 * i;
				hfArray[i].css({"left":cor, "top": "5px"});
				hfArray[i].show();
			}
			jsav.step();		
		}	
	}						

    // traverse to re-set background color of the entire tree
    var traverse_color = function(node, col, col2) {
		var val = node.value();

		// the node is an empty node	
		if (!val || val === "jsavnull") {	
			return;
		} 
		else {
			// if the node is an internal node, then display an circle
			if (node.left()) {
				node.css("background-color", col);
				traverse_color(node.left(),col);
			}
			if (node.right()) {
				node.css("background-color", col);
				traverse_color(node.right(),col);
			}
			// if the node is a leaf node, then display an rectangle
			else 
			//	node.css({"height": "60px", "width": "40px", "border-radius":1, "background-color":"YELLOW", "line-height":"28px"});
			{  
				if (typeof(node.value().length) == 'undefined') {
					//node.css({"height": "45px", "width": "40px", "background-color": "yellow"});
					node.css("background-color", "pink");
					}
				else {					
					node.css({"height": "60px", "width": "40px", "border-radius":1, "background-color":"orange", "line-height":"28px"});
					}
			}
		}
    }

	var jsav = new JSAV("av");
	
	// numArray: used for logic control
	var numArray = new Array();

	// hfArray: used for holding the root of several binary trees
	var hfArray = new Array();

	// userArry: an array to store the number and character
	var userArray = new Array();
	userArray[0] = 32;
	userArray[1] = "C";
	userArray[2] = 42;
	userArray[3] = "D";
	userArray[4] = 120;
	userArray[5] = "E";
	userArray[6] = 7;
	userArray[7] = "K"
	userArray[8] = 42;
	userArray[9] = "L"
	userArray[10] = 24;
	userArray[11] = "M";
	userArray[12] = 37;
	userArray[13] = "U";
	userArray[14] = 2;
	userArray[15] = "Z";
	
	// initialization for all the arrays
	for (var i = 0, j = 0; i < userArray.length - 1; i += 2, j++) {
		value = userArray[i] + "<br>" + userArray[i + 1];
		hfArray[j] = jsav.ds.bintree({visible: false, center: false});	
		hfArray[j].root(value);
		numArray[j] = userArray[i];
	}

	jsav.umsg("The initial data are as follows (the first line is frequency and the second line is the chracter): ");
	// Display the initial data
	for (var i = 0; i < hfArray.length; i++) {
		traverse_color(hfArray[i].root(), "white");
		var cor = 40 + 75 * i;
		hfArray[i].css({"left":cor, "top": "5px"});
	}	
	jsav.step();
	
	// Constructing Huffman Coding Tree with animation.
	huffTree_animation(numArray, hfArray);

	jsav.umsg("The Huffman Coding Tree is as follows: ");
	var final = hfArray.length - 1;
	traverse_color(hfArray[final].root(), "white");
	hfArray[final].css({"center":"yes"});
//	hfArray[final].layout();
	jsav.step();
    jsav.recorded(); // done recording changes, will rewind
    
    $(".jsavtreenode").live("hover", function() {
	//console.log($(this).text(), $(this).offset().left, $(this).offset().top);
    });
    $("path").live("hover", function() {
	//console.log($(this).attr("d"));
	});

	(function($) {
		var context = $("#ssperform");

		// create a new settings panel and specify the link to show it
		var settings = new JSAV.utils.Settings($(".jsavsettings"));
		// Connect action callbacks to the HTML entities
		$('input[name="about"]').click(about);

		// Process About button: Pop up a message with an Alert
		function about() {
			var mystring = "HuffmanCoding Tree Visualization\nWritten by Maoyuan Sun\nCreated as part of the OpenDSA hypertextbook project.\nFor more information, see http://algoviz.org/eBook\nWritten during April, 2012\nLast update: April 29, 2012\nJSAV library version " + JSAV.version();
			alert(mystring);
		}
		})(jQuery);  

	</script>
</body>
