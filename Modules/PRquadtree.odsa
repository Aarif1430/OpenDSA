<div id="content">
<ODSAtitle>The PR Quadree</ODSAtitle>
<ODSAauthor>Clifford A. Shaffer</ODSAauthor>
<ODSAyear>2012</ODSAyear>
<ODSAprereq "Spatial" />
<ODSAprereq "Trie" />

\index{pr quadtree@\PRquad|(}
In the Point-Region Quadtree (hereafter referred to as the \PRquad)
each node either has exactly four children or is a leaf.
That is, the \PRquad\ is a full four-way branching
(4-ary) tree in shape.\index{kary@\Kary\ tree}
The \PRquad\ represents a collection of data points in two dimensions
by decomposing the region containing the data points
into four equal quadrants, subquadrants, and so on, until no leaf node
contains more than a single point.
In other words, if a region contains zero or one data points, then it
is represented by a \PRquad\ consisting of a single leaf node.
If the region contains more than a single data point, then the region
is split into four equal quadrants.
The corresponding \PRquad\ then contains an internal node and four
subtrees, each subtree representing a single quadrant of the region,
which might in turn be split into subquadrants.
Each internal node of a \PRquad\ represents a single split
of the two-dimensional region.
The four quadrants of the region (or equivalently, the corresponding
subtrees) are designated (in order) NW, NE, SW, and~SE.
Each quadrant containing more than a single point would
in turn be recursively divided into subquadrants until each leaf of
the corresponding \PRquad\ contains at most one point.

For example, consider the region of Figure~\ref{PRExamp}(a)
and the corresponding \PRquad\ in Figure~\ref{PRExamp}(b).
The decomposition process demands a fixed key range.
In this example, the region is assumed to be of size
$128 \times 128$.
Note that the internal nodes of the \PRquad\ are used solely to
indicate decomposition of the region; internal nodes do not store data
records.
Because the decomposition lines are predetermined (i.e, key-space
decomposition is used), the \PRquad\ is a trie.

\begin{figure}
\pdffig{PRexamp}
\vspace{-\medskipamount}
\vspace{-\smallskipamount}
\capt{4.5in}{\PRquad\ example}
{Example of a \PRquad.
(a)~A map of data points.
We define the region to be square with origin at the upper-left-hand
corner and sides of length~128.
(b)~The \PRquad\ for the points in~(a).
(a)~also shows the block decomposition imposed by the \PRquad\ for
this region.}{PRExamp}
\bigskip
\end{figure}

Search for a record matching point~\svar{Q} in the \PRquad\ is
straightforward.
Beginning at the root, we continuously branch to the quadrant that
contains \svar{Q} until our search reaches a leaf node.
If~the root is a leaf, then just check to see if the node's data
record matches point~\svar{Q}.
If~the root is an internal node, proceed to the child that contains
the search coordinate.
For example, the~NW quadrant of Figure~\ref{PRExamp} contains points
whose $x$ and $y$~values each fall in the range 0 to~63.
The NE~quadrant contains points whose $x$~value falls in the range 64
to~127, and whose $y$~value falls in the range 0 to~63.
If the root's child is a leaf node, then that child is checked to see
if \svar{Q} has been found.
If the child is another internal node, the search process continues
through the tree until a leaf node is found.
If this leaf node stores a record whose position matches \svar{Q} then
the query is successful; otherwise \svar{Q} is not in the tree.

Inserting record~\svar{P} into the \PRquad\ is performed by first
locating the leaf node that contains the location of~\svar{P}.
If this leaf node is empty, then \svar{P} is stored at this
leaf.
If the leaf already contains \svar{P} (or a record with \svar{P}'s
coordinates), then a duplicate record should be reported.
If the leaf node already contains another record, then the node
must be repeatedly decomposed until the existing record and \svar{P}
fall into different leaf nodes.
Figure~\ref{PRinsert} shows an example of such an insertion.

\begin{figure}
\pdffig{PRinsert}
\vspace{-\smallskipamount}

\capt{4.5in}{\PRquad\ insertion example}
{\PRquad\ insertion example.
(a)~The initial \PRquad\ containing two data points.
(b)~The result of inserting point~\svar{C}.
The block containing~\svar{A} must be decomposed into four sub-blocks.
Points~\svar{A} and \svar{C} would still be in the same block if only
one subdivision takes place, so a second decomposition is required to
separate them.}{PRinsert}
\bigskip
\end{figure}

Deleting a record~\svar{P} is performed by first locating the
node~\svar{N} of the \PRquad\ that contains~\svar{P}. 
Node~\svar{N} is then changed to be empty.
The next step is to look at~\svar{N}'s three siblings.
\svar{N}~and its siblings must be merged together to form a single
node~$\svar{N}\,'$ if only one point is contained among them.
This merging process continues until some level is reached at which
at least two points are contained in the subtrees represented by
node~$\svar{N}\,'$ and its siblings.
For example, if point~\svar{C} is to be deleted from the \PRquad\
representing Figure~\ref{PRinsert}(b), the resulting node must be
merged with its siblings, and that larger node again merged with its
siblings to restore the \PRquad\ to the decomposition of
Figure~\ref{PRinsert}(a).

Region search is easily performed with the \PRquad.
To locate all points within radius~$r$ of query
point~\svar{Q}, begin at the root.
If the root is an empty leaf node, then no data points are found.
If the root is a leaf containing a data record, then the location of
the data point is examined to determine if it falls within the 
circle.
If the root is an internal node, then the process is performed
recursively, but \emph{only} on those subtrees containing some part of
the search circle.\index{pr quadtree@\PRquad|)}

\index{object-oriented programming!class hierarchy|(}
Let us now consider how the structure of the \PRquad\ affects the
design of its node representation.
The \PRquad\ is actually a trie (as defined in Section~\ref{Trie}).
Decomposition takes place at the mid-points for internal nodes,
regardless of where the data points actually fall.
The placement of the data points does determine \emph{whether} a
decomposition for a node takes place, but not \emph{where} the
decomposition for the node takes place.
Internal nodes of the \PRquad\ are quite different from leaf nodes, in
that internal nodes have children (leaf nodes do not) and leaf nodes
have data fields (internal nodes do not).
Thus, it is likely to be beneficial to represent internal nodes
differently from leaf nodes.
Finally, there is the fact that approximately half of the leaf nodes
will contain no data field.

Another issue to consider is: How does a routine traversing the
\PRquad\ get the coordinates for the square represented by the current 
\PRquad\ node?
One possibility is to store with each node its spatial description
(such as upper-left corner and width).
However, this will take a lot of space --- perhaps as much as the
space needed for the data records, depending on what information is
being stored.

Another possibility is to pass in the coordinates when the recursive
call is made.
For example, consider the search process.
Initially, the search visits the root node of the tree, which has
origin at (0, 0), and whose width is the full size of the space being 
covered.
When the appropriate child is visited, it is a simple matter for the
search routine to determine the origin for the child, and the width of 
the square is simply half that of the parent.
Not only does passing in the size and position information for a node
save considerable space, but avoiding storing such information
in the nodes enables a good design choice for
empty leaf nodes, as discussed next.

How should we represent empty leaf nodes?
On average, half of the leaf nodes in a \PRquad\ are empty
(i.e., do not store a data point). 
One implementation option is to use a \NULL\ pointer in internal
nodes to represent empty nodes.
This will solve the problem of excessive space requirements.
There is an unfortunate side effect that using a \NULL\ pointer requires
the \PRquad\ processing methods to understand this convention.
In other words, you are breaking encapsulation on the node
representation because the tree now must know things about how the
nodes are implemented.
This is not too horrible for this particular application, because the
node class can be considered private to the tree class, in which case
the node implementation is completely invisible to the outside world.
However, it is undesirable if there is another reasonable alternative.

\index{design pattern!flyweight|(}
Fortunately, there is a good alternative.
It is called the Flyweight design pattern.
In the \PRquad, a flyweight is a single empty leaf node that
is reused in all places where an empty leaf node is needed.
You simply have \emph{all} of the internal nodes with empty leaf
children point to the same node object.
This node object is created once at the beginning of the program,
and is never removed.
The node class recognizes from the pointer value that the flyweight is
being accessed, and acts accordingly.

Note that when using the Flyweight design pattern, you \emph{cannot}
store coordinates for the node in the node.
This is an example of the concept of intrinsic versus extrinsic state.
Intrinsic state for an object is state information stored in the object.
If you stored the coordinates for a node in the node object, those
coordinates would be intrinsic state.
Extrinsic state is state information about an object stored elsewhere
in the environment, such as in global variables or passed to the
method.
If your recursive calls that process the tree pass in the coordinates
for the current node, then the coordinates will be extrinsic state.
A flyweight can have in its intrinsic state \emph{only}
information that is accurate for \emph{all} instances of the flyweight.
Clearly coordinates do not qualify, because each empty
leaf node has its own location.
So, if you want to use a flyweight, you must pass in coordinates.

Another design choice is: Who controls the work, the node
class or the tree class?
For example, on an insert operation, you could have the tree class
control the flow down the tree, looking at (querying) the nodes to see
their type and reacting accordingly.
This is the approach used by the BST\index{bst@BST} implementation in
Section~\ref{BST}.
An alternate approach is to have the node class do the work.
That is, you have an insert method for the nodes.
If the node is internal, it passes the city record to the appropriate
child (recursively).
If the node is a flyweight, it replaces itself with a new leaf node.
If the node is a full node, it replaces itself with a subtree.
This is an example of the Composite design pattern, discussed in
Section~\ref{PointerBin}.\index{design pattern!composite}
Use of the composite design would be difficult if \NULL\ pointers are
used to represent empty leaf nodes.
It turns out that the \PRquad\ insert and delete methods are easier to
implement when using the composite design.

\index{design pattern!flyweight|)}
\index{object-oriented programming!class hierarchy|)}

\subsection{Other Point Data Structures}
\label{OtherSpat}

The differences between the\index{k-d tree} \KDtree\ and
the \PRquad\ illustrate many\index{pr quadtree@\PRquad}
of the design choices encountered when creating spatial data
structures.
The \KDtree\ provides an object space decomposition of the
region, while the \PRquad\ provides a key space decomposition
(thus, it is a trie).
The \KDtree\ stores records at all nodes, while the
\PRquad\ stores records only at the leaf nodes.
Finally, the two trees have different structures.
The \KDtree\ is a binary tree (and need not be full),
while the \PRquad\ is a full tree with
$2^d$ branches (in the two-dimensional case, $2^2 = 4$).
Consider the extension of this concept to three dimensions.
A \KDtree\ for three dimensions would alternate the discriminator
through the $x$, $y$, and $z$~dimensions.
The three-dimensional equivalent of the \PRquad\ would be a tree with
$2^3$ or eight branches.
Such a tree is called an \defit{octree}.\index{octree}

We can also devise a binary trie based on a key space decomposition in
each dimension, or a quadtree that uses the two-dimensional equivalent
to an object space decomposition.
The \defit{bintree}\index{bintree} is a binary trie that
uses keyspace decomposition and alternates discriminators at each
level in a manner similar to the \KDtree.
The bintree for the points of Figure~\ref{kdExamp} is shown in
Figure~\ref{Bintree}.
Alternatively, we can use a four-way decomposition of space centered
on the data points.
The tree resulting from such a decomposition is called a
\defit{point quadtree}.\index{point quadtree}
The point quadtree for the data points of Figure~\ref{kdExamp} is
shown in Figure~\ref{PtQuad}.

\begin{figure}
\pdffig{Bintree}
\vspace{-\bigskipamount}
\capt{4.5in}{A bintree for two-dimensional data}
{An example of the bintree, a binary tree using key space
decomposition and discriminators rotating among the dimensions.
Compare this with the \KDtree\ of Figure~\ref{kdExamp} and the
\PRquad\ of Figure~\ref{PRExamp}.}{Bintree}
\bigskip
\end{figure}

\begin{figure}
\pdffig{PtQuad}
\vspace{-\bigskipamount}
\vspace{-\medskipamount}
\capt{4.5in}{A point quadtree for two-dimensional data}
{An example of the point quadtree, a 4-ary tree using object space
decomposition.
Compare this with the \PRquad\ of Figure~\ref{kdExamp}.}{PtQuad}
\smallskip
\end{figure}

\newpage

\subsection{Other Spatial Data Structures}
\label{OtherSpatial}

This section has barely scratched the surface of the field of spatial
data structures.
Dozens of distinct spatial data structures have been
invented, many with variations and alternate implementations.
Spatial data structures exist for storing many forms of spatial data
other than points.
The most important distinctions between are the tree structure
(binary or not, regular decompositions or not) and the decomposition
rule used to decide when the data contained within a region is so
complex that the region must be subdivided.

One such spatial data structure is the Region
Quadtree for storing images where the pixel values tend to be
blocky, such as a map of the countries of the world.
The region quadtree uses a four-way regular decomposition scheme
similar to the \PRquad.
The decomposition rule is simply to divide any node containing pixels
of more than one color or value.

Spatial data structures can also be used to store line object,
rectangle object, or objects of arbitrary shape (such as polygons in
two dimensions or polyhedra in three dimensions).
A simple, yet effective, data structure for storing rectangles or
arbitrary polygonal shapes can be derived from the \PRquad.
Pick a threshold value \svar{c}, and subdivide any region into four
quadrants if it contains more than \svar{c} objects.
A special case must be dealt with when more than \svar{c} object
intersect.

Some of the most interesting developments in spatial data structures
have to do with adapting them for disk-based applications.
However, all such disk-based implementations boil down to storing the
spatial data structure within some variant
on either \Btrees\ or\index{btree@\Btree}
hashing.\index{hashing}\index{spatial data structure|)}

</div>